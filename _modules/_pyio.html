

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>_pyio &mdash; ArcherBashPYDocs 1.0.0. documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ArcherBashPYDocs 1.0.0. documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> ArcherBashPYDocs</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">ArcherBashPYDocs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>_pyio</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for _pyio</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Python implementation of the io module.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="c"># Import _thread instead of threading to reduce startup cost</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">allocate_lock</span> <span class="k">as</span> <span class="n">Lock</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_dummy_thread</span> <span class="kn">import</span> <span class="n">allocate_lock</span> <span class="k">as</span> <span class="n">Lock</span>

<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="p">(</span><span class="n">__all__</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">)</span>

<span class="n">valid_seek_flags</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>  <span class="c"># Hardwired values</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&#39;SEEK_HOLE&#39;</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">valid_seek_flags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">SEEK_HOLE</span><span class="p">)</span>
    <span class="n">valid_seek_flags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">SEEK_DATA</span><span class="p">)</span>

<span class="c"># open() uses st_blksize whenever we can</span>
<span class="n">DEFAULT_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span>  <span class="c"># bytes</span>

<span class="c"># NOTE: Base classes defined here are registered with the &quot;official&quot; ABCs</span>
<span class="c"># defined in io.py. We don&#39;t use real inheritance though, because we don&#39;t</span>
<span class="c"># want to inherit the C implementations.</span>

<span class="c"># Rebind for compatibility</span>
<span class="n">BlockingIOError</span> <span class="o">=</span> <span class="n">BlockingIOError</span>


<span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">newline</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="sd">r&quot;&quot;&quot;Open file and return a stream.  Raise OSError upon failure.</span>

<span class="sd">    file is either a text or byte string giving the name (and the path</span>
<span class="sd">    if the file isn&#39;t in the current working directory) of the file to</span>
<span class="sd">    be opened or an integer file descriptor of the file to be</span>
<span class="sd">    wrapped. (If a file descriptor is given, it is closed when the</span>
<span class="sd">    returned I/O object is closed, unless closefd is set to False.)</span>

<span class="sd">    mode is an optional string that specifies the mode in which the file is</span>
<span class="sd">    opened. It defaults to &#39;r&#39; which means open for reading in text mode. Other</span>
<span class="sd">    common values are &#39;w&#39; for writing (truncating the file if it already</span>
<span class="sd">    exists), &#39;x&#39; for exclusive creation of a new file, and &#39;a&#39; for appending</span>
<span class="sd">    (which on some Unix systems, means that all writes append to the end of the</span>
<span class="sd">    file regardless of the current seek position). In text mode, if encoding is</span>
<span class="sd">    not specified the encoding used is platform dependent. (For reading and</span>
<span class="sd">    writing raw bytes use binary mode and leave encoding unspecified.) The</span>
<span class="sd">    available modes are:</span>

<span class="sd">    ========= ===============================================================</span>
<span class="sd">    Character Meaning</span>
<span class="sd">    --------- ---------------------------------------------------------------</span>
<span class="sd">    &#39;r&#39;       open for reading (default)</span>
<span class="sd">    &#39;w&#39;       open for writing, truncating the file first</span>
<span class="sd">    &#39;x&#39;       create a new file and open it for writing</span>
<span class="sd">    &#39;a&#39;       open for writing, appending to the end of the file if it exists</span>
<span class="sd">    &#39;b&#39;       binary mode</span>
<span class="sd">    &#39;t&#39;       text mode (default)</span>
<span class="sd">    &#39;+&#39;       open a disk file for updating (reading and writing)</span>
<span class="sd">    &#39;U&#39;       universal newline mode (deprecated)</span>
<span class="sd">    ========= ===============================================================</span>

<span class="sd">    The default mode is &#39;rt&#39; (open for reading text). For binary random</span>
<span class="sd">    access, the mode &#39;w+b&#39; opens and truncates the file to 0 bytes, while</span>
<span class="sd">    &#39;r+b&#39; opens the file without truncation. The &#39;x&#39; mode implies &#39;w&#39; and</span>
<span class="sd">    raises an `FileExistsError` if the file already exists.</span>

<span class="sd">    Python distinguishes between files opened in binary and text modes,</span>
<span class="sd">    even when the underlying operating system doesn&#39;t. Files opened in</span>
<span class="sd">    binary mode (appending &#39;b&#39; to the mode argument) return contents as</span>
<span class="sd">    bytes objects without any decoding. In text mode (the default, or when</span>
<span class="sd">    &#39;t&#39; is appended to the mode argument), the contents of the file are</span>
<span class="sd">    returned as strings, the bytes having been first decoded using a</span>
<span class="sd">    platform-dependent encoding or using the specified encoding if given.</span>

<span class="sd">    &#39;U&#39; mode is deprecated and will raise an exception in future versions</span>
<span class="sd">    of Python.  It has no effect in Python 3.  Use newline to control</span>
<span class="sd">    universal newlines mode.</span>

<span class="sd">    buffering is an optional integer used to set the buffering policy.</span>
<span class="sd">    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select</span>
<span class="sd">    line buffering (only usable in text mode), and an integer &gt; 1 to indicate</span>
<span class="sd">    the size of a fixed-size chunk buffer.  When no buffering argument is</span>
<span class="sd">    given, the default buffering policy works as follows:</span>

<span class="sd">    * Binary files are buffered in fixed-size chunks; the size of the buffer</span>
<span class="sd">      is chosen using a heuristic trying to determine the underlying device&#39;s</span>
<span class="sd">      &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.</span>
<span class="sd">      On many systems, the buffer will typically be 4096 or 8192 bytes long.</span>

<span class="sd">    * &quot;Interactive&quot; text files (files for which isatty() returns True)</span>
<span class="sd">      use line buffering.  Other text files use the policy described above</span>
<span class="sd">      for binary files.</span>

<span class="sd">    encoding is the str name of the encoding used to decode or encode the</span>
<span class="sd">    file. This should only be used in text mode. The default encoding is</span>
<span class="sd">    platform dependent, but any encoding supported by Python can be</span>
<span class="sd">    passed.  See the codecs module for the list of supported encodings.</span>

<span class="sd">    errors is an optional string that specifies how encoding errors are to</span>
<span class="sd">    be handled---this argument should not be used in binary mode. Pass</span>
<span class="sd">    &#39;strict&#39; to raise a ValueError exception if there is an encoding error</span>
<span class="sd">    (the default of None has the same effect), or pass &#39;ignore&#39; to ignore</span>
<span class="sd">    errors. (Note that ignoring encoding errors can lead to data loss.)</span>
<span class="sd">    See the documentation for codecs.register for a list of the permitted</span>
<span class="sd">    encoding error strings.</span>

<span class="sd">    newline is a string controlling how universal newlines works (it only</span>
<span class="sd">    applies to text mode). It can be None, &#39;&#39;, &#39;\n&#39;, &#39;\r&#39;, and &#39;\r\n&#39;.  It works</span>
<span class="sd">    as follows:</span>

<span class="sd">    * On input, if newline is None, universal newlines mode is</span>
<span class="sd">      enabled. Lines in the input can end in &#39;\n&#39;, &#39;\r&#39;, or &#39;\r\n&#39;, and</span>
<span class="sd">      these are translated into &#39;\n&#39; before being returned to the</span>
<span class="sd">      caller. If it is &#39;&#39;, universal newline mode is enabled, but line</span>
<span class="sd">      endings are returned to the caller untranslated. If it has any of</span>
<span class="sd">      the other legal values, input lines are only terminated by the given</span>
<span class="sd">      string, and the line ending is returned to the caller untranslated.</span>

<span class="sd">    * On output, if newline is None, any &#39;\n&#39; characters written are</span>
<span class="sd">      translated to the system default line separator, os.linesep. If</span>
<span class="sd">      newline is &#39;&#39;, no translation takes place. If newline is any of the</span>
<span class="sd">      other legal values, any &#39;\n&#39; characters written are translated to</span>
<span class="sd">      the given string.</span>

<span class="sd">    closedfd is a bool. If closefd is False, the underlying file descriptor will</span>
<span class="sd">    be kept open when the file is closed. This does not work when a file name is</span>
<span class="sd">    given and must be True in that case.</span>

<span class="sd">    The newly created file is non-inheritable.</span>

<span class="sd">    A custom opener can be used by passing a callable as *opener*. The</span>
<span class="sd">    underlying file descriptor for the file object is then obtained by calling</span>
<span class="sd">    *opener* with (*file*, *flags*). *opener* must return an open file</span>
<span class="sd">    descriptor (passing os.open as *opener* results in functionality similar to</span>
<span class="sd">    passing None).</span>

<span class="sd">    open() returns a file object whose type depends on the mode, and</span>
<span class="sd">    through which the standard file operations such as reading and writing</span>
<span class="sd">    are performed. When open() is used to open a file in a text mode (&#39;w&#39;,</span>
<span class="sd">    &#39;r&#39;, &#39;wt&#39;, &#39;rt&#39;, etc.), it returns a TextIOWrapper. When used to open</span>
<span class="sd">    a file in a binary mode, the returned class varies: in read binary</span>
<span class="sd">    mode, it returns a BufferedReader; in write binary and append binary</span>
<span class="sd">    modes, it returns a BufferedWriter, and in read/write mode, it returns</span>
<span class="sd">    a BufferedRandom.</span>

<span class="sd">    It is also possible to use a string or bytearray as a file for both</span>
<span class="sd">    reading and writing. For strings StringIO can be used like a file</span>
<span class="sd">    opened in a text mode, and for bytes a BytesIO can be used like a file</span>
<span class="sd">    opened in a binary mode.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid file: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buffering</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid buffering: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">buffering</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid encoding: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid errors: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">errors</span><span class="p">)</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">modes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="s">&quot;axrwb+tU&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">creating</span> <span class="o">=</span> <span class="s">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">reading</span> <span class="o">=</span> <span class="s">&quot;r&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">writing</span> <span class="o">=</span> <span class="s">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">appending</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">updating</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="s">&quot;b&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="k">if</span> <span class="s">&quot;U&quot;</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">creating</span> <span class="ow">or</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t use U and writing mode at once&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;&#39;U&#39; mode is deprecated&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">reading</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">text</span> <span class="ow">and</span> <span class="n">binary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have text and binary mode at once&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">creating</span> <span class="o">+</span> <span class="n">reading</span> <span class="o">+</span> <span class="n">writing</span> <span class="o">+</span> <span class="n">appending</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have read/write/append mode at once&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">creating</span> <span class="ow">or</span> <span class="n">reading</span> <span class="ow">or</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;must have exactly one of read/write/append mode&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take an encoding argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take an errors argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">newline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take a newline argument&quot;</span><span class="p">)</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="n">FileIO</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span>
                 <span class="p">(</span><span class="n">creating</span> <span class="ow">and</span> <span class="s">&quot;x&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">reading</span> <span class="ow">and</span> <span class="s">&quot;r&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">writing</span> <span class="ow">and</span> <span class="s">&quot;w&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">appending</span> <span class="ow">and</span> <span class="s">&quot;a&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">updating</span> <span class="ow">and</span> <span class="s">&quot;+&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                 <span class="n">closefd</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">raw</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">line_buffering</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">buffering</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">raw</span><span class="o">.</span><span class="n">isatty</span><span class="p">():</span>
            <span class="n">buffering</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">line_buffering</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">buffering</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER_SIZE</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fstat</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span><span class="o">.</span><span class="n">st_blksize</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">buffering</span> <span class="o">=</span> <span class="n">bs</span>
        <span class="k">if</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid buffering size&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buffering</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have unbuffered text I/O&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">updating</span><span class="p">:</span>
            <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedRandom</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">creating</span> <span class="ow">or</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">:</span>
            <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedWriter</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reading</span><span class="p">:</span>
            <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unknown mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">buffer</span>
        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">TextIOWrapper</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">newline</span><span class="p">,</span> <span class="n">line_buffering</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">text</span>
        <span class="n">text</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">raise</span>


<span class="k">class</span> <span class="nc">DocDescriptor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper for builtins.open.__doc__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s">&quot;open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, &quot;</span>
                 <span class="s">&quot;errors=None, newline=None, closefd=True)</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">+</span>
            <span class="nb">open</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OpenWrapper</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for builtins.open</span>

<span class="sd">    Trick so that open won&#39;t become a bound method when stored</span>
<span class="sd">    as a class variable (as dbm.dumb does).</span>

<span class="sd">    See initstdio() in Python/pythonrun.c.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__doc__</span> <span class="o">=</span> <span class="n">DocDescriptor</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c"># In normal operation, both `UnsupportedOperation`s should be bound to the</span>
<span class="c"># same object.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">UnsupportedOperation</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">UnsupportedOperation</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">UnsupportedOperation</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">IOBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;The abstract base class for all I/O classes, acting on streams of</span>
<span class="sd">    bytes. There is no public constructor.</span>

<span class="sd">    This class provides dummy implementations for many methods that</span>
<span class="sd">    derived classes can override selectively; the default implementations</span>
<span class="sd">    represent a file that cannot be read, written or seeked.</span>

<span class="sd">    Even though IOBase does not declare read, readinto, or write because</span>
<span class="sd">    their signatures will vary, implementations and clients should</span>
<span class="sd">    consider those methods part of the interface. Also, implementations</span>
<span class="sd">    may raise UnsupportedOperation when operations they do not support are</span>
<span class="sd">    called.</span>

<span class="sd">    The basic type used for binary data read from or written to a file is</span>
<span class="sd">    bytes. bytearrays are accepted too, and in some cases (such as</span>
<span class="sd">    readinto) needed. Text I/O classes work with str data.</span>

<span class="sd">    Note that calling any method (even inquiries) on a closed stream is</span>
<span class="sd">    undefined. Implementations may raise OSError in this case.</span>

<span class="sd">    IOBase (and its subclasses) support the iterator protocol, meaning</span>
<span class="sd">    that an IOBase object can be iterated over yielding the lines in a</span>
<span class="sd">    stream.</span>

<span class="sd">    IOBase also supports the :keyword:`with` statement. In this example,</span>
<span class="sd">    fp is closed after the suite of the with statement is complete:</span>

<span class="sd">    with open(&#39;spam.txt&#39;, &#39;r&#39;) as fp:</span>
<span class="sd">        fp.write(&#39;Spam and eggs!&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">### Internal ###</span>

    <span class="k">def</span> <span class="nf">_unsupported</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an OSError exception for unsupported operations.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">() not supported&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="c">### Positioning ###</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change stream position.</span>

<span class="sd">        Change the stream position to byte offset pos. Argument pos is</span>
<span class="sd">        interpreted relative to the position indicated by whence.  Values</span>
<span class="sd">        for whence are ints:</span>

<span class="sd">        * 0 -- start of stream (the default); offset should be zero or positive</span>
<span class="sd">        * 1 -- current stream position; offset may be negative</span>
<span class="sd">        * 2 -- end of stream; offset is usually negative</span>
<span class="sd">        Some operating systems / file systems could provide additional values.</span>

<span class="sd">        Return an int indicating the new absolute position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;seek&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an int indicating the current stream position.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate file to size bytes.</span>

<span class="sd">        Size defaults to the current IO position as reported by tell().  Return</span>
<span class="sd">        the new size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;truncate&quot;</span><span class="p">)</span>

    <span class="c">### Flush and close ###</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush write buffers, if applicable.</span>

<span class="sd">        This is not implemented for read-only and non-blocking streams.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="c"># XXX Should this return the number of bytes written???</span>

    <span class="n">__closed</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush and close the IO object.</span>

<span class="sd">        This method has no effect if the file is already closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destructor.  Calls close().&quot;&quot;&quot;</span>
        <span class="c"># The try/except block is in case this is called at program</span>
        <span class="c"># exit time, when it&#39;s possible that globals have already been</span>
        <span class="c"># deleted, and then the close() call might fail.  Since</span>
        <span class="c"># there&#39;s nothing we can do about such failures and they annoy</span>
        <span class="c"># the end users, we suppress the traceback.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c">### Inquiries ###</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a bool indicating whether object supports random access.</span>

<span class="sd">        If False, seek(), tell() and truncate() will raise UnsupportedOperation.</span>
<span class="sd">        This method may need to do a test seek().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_checkSeekable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise UnsupportedOperation if file is not seekable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seekable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;File or stream is not seekable.&quot;</span>
                                       <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a bool indicating whether object was opened for reading.</span>

<span class="sd">        If False, read() will raise UnsupportedOperation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_checkReadable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise UnsupportedOperation if file is not readable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">readable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;File or stream is not readable.&quot;</span>
                                       <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a bool indicating whether object was opened for writing.</span>

<span class="sd">        If False, write() and truncate() will raise UnsupportedOperation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_checkWritable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise UnsupportedOperation if file is not writable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;File or stream is not writable.&quot;</span>
                                       <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;closed: bool.  True iff the file has been closed.</span>

<span class="sd">        For backwards compatibility, this is a property, not a predicate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span>

    <span class="k">def</span> <span class="nf">_checkClosed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an ValueError if file is closed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span>
                             <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="c">### Context manager ###</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># That&#39;s a forward reference</span>
        <span class="sd">&quot;&quot;&quot;Context management protocol.  Returns self (an instance of IOBase).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context management protocol.  Calls close()&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">### Lower-level APIs ###</span>

    <span class="c"># XXX Should these be present even if unimplemented?</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns underlying file descriptor (an int) if one exists.</span>

<span class="sd">        An OSError is raised if the IO object does not use a file descriptor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;fileno&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a bool indicating whether this is an &#39;interactive&#39; stream.</span>

<span class="sd">        Return False if it can&#39;t be determined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c">### Readline[s] and writelines ###</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Read and return a line of bytes from the stream.</span>

<span class="sd">        If size is specified, at most size bytes will be read.</span>
<span class="sd">        Size should be an int.</span>

<span class="sd">        The line terminator is always b&#39;\n&#39; for binary files; for text</span>
<span class="sd">        files, the newlines argument to open can be used to select the line</span>
<span class="sd">        terminator(s) recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># For backwards compatibility, a (slowish) readline().</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;peek&quot;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">nreadahead</span><span class="p">():</span>
                <span class="n">readahead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">readahead</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">readahead</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">readahead</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">nreadahead</span><span class="p">():</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;size must be an integer&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nreadahead</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">b</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">line</span>

    <span class="k">def</span> <span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of lines from the stream.</span>

<span class="sd">        hint can be specified to control the number of lines read: no more</span>
<span class="sd">        lines will be read if the total size (in bytes/characters) of all</span>
<span class="sd">        lines so far exceeds hint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">hint</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">hint</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">lines</span>

    <span class="k">def</span> <span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">IOBase</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RawIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for raw binary I/O.&quot;&quot;&quot;</span>

    <span class="c"># The read() method is implemented by calling readinto(); derived</span>
    <span class="c"># classes that want to support read() only need to implement</span>
    <span class="c"># readinto() as a primitive operation.  In general, readinto() can be</span>
    <span class="c"># more efficient than read().</span>

    <span class="c"># (It would be tempting to also provide an implementation of</span>
    <span class="c"># readinto() in terms of read(), in case the latter is a more suitable</span>
    <span class="c"># primitive operation, but that would lead to nasty recursion in case</span>
    <span class="c"># a subclass doesn&#39;t implement either.)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read and return up to size bytes, where size is an int.</span>

<span class="sd">        Returns an empty bytes object on EOF, or None if the object is</span>
<span class="sd">        set not to block and has no data to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">readall</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">__index__</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read until EOF, using multiple read() call.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># b&#39;&#39; or None</span>
            <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read up to len(b) bytes into bytearray b.</span>

<span class="sd">        Returns an int representing the number of bytes read (0 for EOF), or</span>
<span class="sd">        None if the object is set not to block and has no data to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;readinto&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the given buffer to the IO stream.</span>

<span class="sd">        Returns the number of bytes written, which may be less than len(b).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>

<span class="n">io</span><span class="o">.</span><span class="n">RawIOBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">RawIOBase</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">_io</span> <span class="kn">import</span> <span class="n">FileIO</span>
<span class="n">RawIOBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FileIO</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BufferedIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for buffered IO objects.</span>

<span class="sd">    The main difference with RawIOBase is that the read() method</span>
<span class="sd">    supports omitting the size argument, and does not have a default</span>
<span class="sd">    implementation that defers to readinto().</span>

<span class="sd">    In addition, read(), readinto() and write() may raise</span>
<span class="sd">    BlockingIOError if the underlying raw stream is in non-blocking</span>
<span class="sd">    mode and not ready; unlike their raw counterparts, they will never</span>
<span class="sd">    return None.</span>

<span class="sd">    A typical implementation should not inherit from a RawIOBase</span>
<span class="sd">    implementation, but wrap one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read and return up to size bytes, where size is an int.</span>

<span class="sd">        If the argument is omitted, None, or negative, reads and</span>
<span class="sd">        returns all data until EOF.</span>

<span class="sd">        If the argument is positive, and the underlying raw stream is</span>
<span class="sd">        not &#39;interactive&#39;, multiple raw reads may be issued to satisfy</span>
<span class="sd">        the byte count (unless EOF is reached first).  But for</span>
<span class="sd">        interactive raw streams (XXX and for pipes?), at most one raw</span>
<span class="sd">        read will be issued, and a short result does not imply that</span>
<span class="sd">        EOF is imminent.</span>

<span class="sd">        Returns an empty bytes array on EOF.</span>

<span class="sd">        Raises BlockingIOError if the underlying raw stream has no</span>
<span class="sd">        data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read up to size bytes with at most one read() system call,</span>
<span class="sd">        where size is an int.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;read1&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read up to len(b) bytes into bytearray b.</span>

<span class="sd">        Like read(), this may issue multiple reads to the underlying raw</span>
<span class="sd">        stream, unless the latter is &#39;interactive&#39;.</span>

<span class="sd">        Returns an int representing the number of bytes read (0 for EOF).</span>

<span class="sd">        Raises BlockingIOError if the underlying raw stream has no</span>
<span class="sd">        data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># XXX This ought to work with anything that supports the buffer API</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">b</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">array</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">err</span>
            <span class="n">b</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the given bytes buffer to the IO stream.</span>

<span class="sd">        Return the number of bytes written, which is never less than</span>
<span class="sd">        len(b).</span>

<span class="sd">        Raises BlockingIOError if the buffer is full and the</span>
<span class="sd">        underlying raw stream cannot accept more data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separate the underlying raw stream from the buffer and return it.</span>

<span class="sd">        After the raw stream has been detached, the buffer is in an unusable</span>
<span class="sd">        state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;detach&quot;</span><span class="p">)</span>

<span class="n">io</span><span class="o">.</span><span class="n">BufferedIOBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_BufferedIOMixin</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A mixin implementation of BufferedIOBase with an underlying raw stream.</span>

<span class="sd">    This passes most requests on to the underlying raw stream.  It</span>
<span class="sd">    does *not* provide implementations of read(), readinto() or</span>
<span class="sd">    write().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">raw</span>

    <span class="c">### Positioning ###</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">new_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;seek() returned an invalid position&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_position</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;tell() returned an invalid position&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Flush the stream.  We&#39;re mixing buffered I/O with lower-level I/O,</span>
        <span class="c"># and a flush may be necessary to synch both views of the current</span>
        <span class="c"># file state.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="c"># XXX: Should seek() be used, instead of passing the position</span>
        <span class="c"># XXX  directly to truncate?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="c">### Flush and close ###</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;flush of closed file&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># may raise BlockingIOError or BrokenPipeError etc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;raw stream already detached&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">raw</span>

    <span class="c">### Inquiries ###</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">closed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">mode</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can not serialize a &#39;{0}&#39; object&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">clsname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&lt;_pyio.{0}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clsname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&lt;_pyio.{0} name={1!r}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c">### Lower-level APIs ###</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">BytesIO</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Buffered I/O implementation using an in-memory bytes buffer.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_bytes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">initial_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="n">initial_bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">buf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;__getstate__ on closed file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bytes value (contents) of the buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;getvalue on closed file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getbuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a readable and writable view of the buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">memoryview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;read from closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="n">newpos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="p">:</span> <span class="n">newpos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">newpos</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is the same as read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write str to binary stream&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">):</span>
            <span class="c"># Inserts null bytes between the current end of the file</span>
            <span class="c"># and the new write position.</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">b</span><span class="s">&#39;</span><span class="se">\x00</span><span class="s">&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;seek on closed file&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">__index__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;an integer is required&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative seek position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unsupported whence value&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tell on closed file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;truncate on closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pos</span><span class="o">.</span><span class="n">__index__</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;an integer is required&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative truncate position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,))</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">BufferedReader</span><span class="p">(</span><span class="n">_BufferedIOMixin</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;BufferedReader(raw[, buffer_size])</span>

<span class="sd">    A buffer for a readable, sequential BaseRawIO object.</span>

<span class="sd">    The constructor creates a BufferedReader for the given readable raw</span>
<span class="sd">    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE</span>
<span class="sd">    is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new buffered reader using the given readable raw IO object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="o">.</span><span class="n">readable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&#39;&quot;raw&quot; argument must be readable.&#39;</span><span class="p">)</span>

        <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buffer_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid buffer size&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset_read_buf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read size bytes.</span>

<span class="sd">        Returns exactly size bytes of data unless the underlying raw IO</span>
<span class="sd">        stream reaches EOF or if the call would block in non-blocking</span>
<span class="sd">        mode. If size is negative, read until EOF or until read() would</span>
<span class="sd">        block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid number of bytes to read&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_unlocked</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="n">empty_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>

        <span class="c"># Special case for when the number of bytes to read is unspecified.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="s">&#39;readall&#39;</span><span class="p">):</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">readall</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span> <span class="ow">or</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span> <span class="o">+</span> <span class="n">chunk</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]]</span>  <span class="c"># Strip the consumed bytes.</span>
            <span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="c"># Read until EOF or until read() would block.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">InterruptedError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">empty_values</span><span class="p">:</span>
                    <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">chunk</span>
                    <span class="k">break</span>
                <span class="n">current_size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nodata_val</span>

        <span class="c"># The number of bytes to read is specified, return at most n bytes.</span>
        <span class="n">avail</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span>  <span class="c"># Length of the available buffered data.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">avail</span><span class="p">:</span>
            <span class="c"># Fast path: the data to read is fully buffered.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="n">n</span><span class="p">]</span>
        <span class="c"># Slow path: read from the stream until enough bytes are read,</span>
        <span class="c"># or until an EOF occurs or until read() would block.</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]]</span>
        <span class="n">wanted</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">avail</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">wanted</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">InterruptedError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">empty_values</span><span class="p">:</span>
                <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">chunk</span>
                <span class="k">break</span>
            <span class="n">avail</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="c"># n is more then avail only when an EOF occurred or when</span>
        <span class="c"># read() would have blocked.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">avail</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>  <span class="c"># Save the extra data in the buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">out</span> <span class="k">else</span> <span class="n">nodata_val</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns buffered bytes without advancing the position.</span>

<span class="sd">        The argument indicates a desired minimal number of bytes; we</span>
<span class="sd">        do at most one raw read to satisfy it.  We never return more</span>
<span class="sd">        than self.buffer_size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peek_unlocked</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_peek_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">want</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="n">have</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>
        <span class="k">if</span> <span class="n">have</span> <span class="o">&lt;</span> <span class="n">want</span> <span class="ow">or</span> <span class="n">have</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">have</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">to_read</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">InterruptedError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">:]</span> <span class="o">+</span> <span class="n">current</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads up to size bytes, with at most one read() system call.&quot;&quot;&quot;</span>
        <span class="c"># Returns up to size bytes.  If at least one byte is buffered, we</span>
        <span class="c"># only return buffered bytes.  Otherwise, we do one raw read.</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;number of bytes to read must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_peek_unlocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_unlocked</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_seek_flags</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid whence value&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">pos</span>

<span class="k">class</span> <span class="nc">BufferedWriter</span><span class="p">(</span><span class="n">_BufferedIOMixin</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffer for a writeable sequential RawIO object.</span>

<span class="sd">    The constructor creates a BufferedWriter for the given writeable raw</span>
<span class="sd">    stream. If the buffer_size is not given, it defaults to</span>
<span class="sd">    DEFAULT_BUFFER_SIZE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="o">.</span><span class="n">writable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&#39;&quot;raw&quot; argument must be writable.&#39;</span><span class="p">)</span>

        <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buffer_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid buffer size&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write str to binary stream&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="c"># XXX we can implement some more tricks to try and avoid</span>
            <span class="c"># partial writes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">:</span>
                <span class="c"># We&#39;re full, so let&#39;s pre-flush the buffer.  (This may</span>
                <span class="c"># raise BlockingIOError with characters_written == 0.)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
            <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">written</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">before</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">BlockingIOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">:</span>
                        <span class="c"># We&#39;ve hit the buffer_size. We have to accept a partial</span>
                        <span class="c"># write and cut back our buffer.</span>
                        <span class="n">overage</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span>
                        <span class="n">written</span> <span class="o">-=</span> <span class="n">overage</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">]</span>
                        <span class="k">raise</span> <span class="n">BlockingIOError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="n">written</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">written</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flush_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;flush of closed file&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">InterruptedError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;self.raw should implement RawIOBase: it &quot;</span>
                                   <span class="s">&quot;should not raise BlockingIOError&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BlockingIOError</span><span class="p">(</span>
                    <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">,</span>
                    <span class="s">&quot;write could not complete without blocking&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;write() returned incorrect number of bytes&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_seek_flags</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid whence value&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BufferedRWPair</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffered reader and writer object together.</span>

<span class="sd">    A buffered reader object and buffered writer object put together to</span>
<span class="sd">    form a sequential IO object that can read and write. This is typically</span>
<span class="sd">    used with a socket or two-way pipe.</span>

<span class="sd">    reader and writer are RawIOBase objects that are readable and</span>
<span class="sd">    writeable respectively. If the buffer_size is omitted it defaults to</span>
<span class="sd">    DEFAULT_BUFFER_SIZE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># XXX The usefulness of this (compared to having two separate IO</span>
    <span class="c"># objects) is questionable.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        The arguments are two RawIO instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reader</span><span class="o">.</span><span class="n">readable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&#39;&quot;reader&quot; argument must be readable.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">writer</span><span class="o">.</span><span class="n">writable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&#39;&quot;writer&quot; argument must be writable.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="n">BufferedWriter</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">closed</span>


<span class="k">class</span> <span class="nc">BufferedRandom</span><span class="p">(</span><span class="n">BufferedWriter</span><span class="p">,</span> <span class="n">BufferedReader</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffered interface to random access streams.</span>

<span class="sd">    The constructor creates a reader and writer for a seekable stream,</span>
<span class="sd">    raw, given in the first argument. If the buffer_size is omitted it</span>
<span class="sd">    defaults to DEFAULT_BUFFER_SIZE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">):</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">_checkSeekable</span><span class="p">()</span>
        <span class="n">BufferedReader</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_seek_flags</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid whence value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">:</span>
            <span class="c"># Undo read ahead.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># First do the raw seek, then empty the read buffer, so that</span>
        <span class="c"># if the raw seek fails, we don&#39;t lose buffered data forever.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;seek() returned invalid position&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="c"># Use seek to flush the read buffer.</span>
        <span class="k">return</span> <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">:</span>
            <span class="c"># Undo readahead</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TextIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for text I/O.</span>

<span class="sd">    This class provides a character and line based interface to stream</span>
<span class="sd">    I/O. There is no readinto method because Python&#39;s character strings</span>
<span class="sd">    are immutable. There is no public constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read at most size characters from stream, where size is an int.</span>

<span class="sd">        Read from underlying buffer until we have size characters or we hit EOF.</span>
<span class="sd">        If size is negative or omitted, read until EOF.</span>

<span class="sd">        Returns a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write string s to stream and returning an int.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate size to pos, where pos is an int.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;truncate&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read until newline or EOF.</span>

<span class="sd">        Returns an empty string if EOF is hit immediately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;readline&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separate the underlying buffer from the TextIOBase and return it.</span>

<span class="sd">        After the underlying buffer has been detached, the TextIO is in an</span>
<span class="sd">        unusable state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;detach&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclasses should override.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Line endings translated so far.</span>

<span class="sd">        Only line endings translated during reading are considered.</span>

<span class="sd">        Subclasses should override.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Error setting of the decoder or encoder.</span>

<span class="sd">        Subclasses should override.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

<span class="n">io</span><span class="o">.</span><span class="n">TextIOBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">TextIOBase</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IncrementalNewlineDecoder</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">IncrementalDecoder</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Codec used when reading a file in universal newlines mode.  It wraps</span>
<span class="sd">    another incremental decoder, translating \r\n and \r into \n.  It also</span>
<span class="sd">    records the types of newlines encountered.  When used with</span>
<span class="sd">    translate=False, it ensures that the newline sequence is returned in</span>
<span class="sd">    one piece.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;strict&#39;</span><span class="p">):</span>
        <span class="n">codecs</span><span class="o">.</span><span class="n">IncrementalDecoder</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># decode input (with the eventual \r from a previous pass)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="n">final</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="ow">and</span> <span class="p">(</span><span class="n">output</span> <span class="ow">or</span> <span class="n">final</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># retain last \r even when not translating data:</span>
        <span class="c"># then readline() is sure to get \r\n in one pass</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Record which newlines are read</span>
        <span class="n">crlf</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">cr</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">crlf</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">crlf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">lf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CR</span><span class="p">)</span> \
                    <span class="o">|</span> <span class="p">(</span><span class="n">crlf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CRLF</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crlf</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cr</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">getstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
        <span class="n">flag</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">|=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span>

    <span class="k">def</span> <span class="nf">setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="n">_LF</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_CR</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">_CRLF</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span>
               <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">seennl</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TextIOWrapper</span><span class="p">(</span><span class="n">TextIOBase</span><span class="p">):</span>

    <span class="sd">r&quot;&quot;&quot;Character and line based layer over a BufferedIOBase object, buffer.</span>

<span class="sd">    encoding gives the name of the encoding that the stream will be</span>
<span class="sd">    decoded or encoded with. It defaults to locale.getpreferredencoding(False).</span>

<span class="sd">    errors determines the strictness of encoding and decoding (see the</span>
<span class="sd">    codecs.register) and defaults to &quot;strict&quot;.</span>

<span class="sd">    newline can be None, &#39;&#39;, &#39;\n&#39;, &#39;\r&#39;, or &#39;\r\n&#39;.  It controls the</span>
<span class="sd">    handling of line endings. If it is None, universal newlines is</span>
<span class="sd">    enabled.  With this enabled, on input, the lines endings &#39;\n&#39;, &#39;\r&#39;,</span>
<span class="sd">    or &#39;\r\n&#39; are translated to &#39;\n&#39; before being returned to the</span>
<span class="sd">    caller. Conversely, on output, &#39;\n&#39; is translated to the system</span>
<span class="sd">    default line separator, os.linesep. If newline is any other of its</span>
<span class="sd">    legal values, that newline becomes the newline when the file is read</span>
<span class="sd">    and it is returned untranslated. On output, &#39;\n&#39; is converted to the</span>
<span class="sd">    newline.</span>

<span class="sd">    If line_buffering is True, a call to flush is implied when a call to</span>
<span class="sd">    write contains a newline character.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_CHUNK_SIZE</span> <span class="o">=</span> <span class="mi">2048</span>

    <span class="c"># The write_through argument has no effect here since this</span>
    <span class="c"># implementation always writes through.  The argument is present only</span>
    <span class="c"># so that the signature can match the signature of the C version.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">line_buffering</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">write_through</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">newline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newline</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;illegal newline type: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">newline</span><span class="p">),))</span>
        <span class="k">if</span> <span class="n">newline</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;illegal newline value: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newline</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">device_encoding</span><span class="p">(</span><span class="nb">buffer</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">UnsupportedOperation</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">locale</span>
                <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                    <span class="c"># Importing locale may fail if Python is being built</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="s">&quot;ascii&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">locale</span><span class="o">.</span><span class="n">getpreferredencoding</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid encoding: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">_is_text_encoding</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%r</span><span class="s"> is not a text encoding; &quot;</span>
                   <span class="s">&quot;use codecs.open() to handle arbitrary codecs&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="s">&quot;strict&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid errors: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">errors</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="nb">buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span> <span class="o">=</span> <span class="n">line_buffering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">newline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span> <span class="o">=</span> <span class="n">newline</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span> <span class="o">=</span> <span class="n">newline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="o">=</span> <span class="n">newline</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span> <span class="o">=</span> <span class="n">newline</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># buffer for text returned from decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># offset into _decoded_chars for read()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># info for reconstructing decoder state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_read1</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#39;read1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b2cratio</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">():</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_encoder</span><span class="p">()</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                    <span class="c"># Sometimes the encoder doesn&#39;t exist</span>
                    <span class="k">pass</span>

    <span class="c"># self._snapshot is either None, or a tuple (dec_flags, next_input)</span>
    <span class="c"># where dec_flags is the second (integer) item of the decoder state</span>
    <span class="c"># and next_input is the chunk of input bytes that comes next after the</span>
    <span class="c"># snapshot point.  We use this to reconstruct decoder states in tell().</span>

    <span class="c"># Naming convention:</span>
    <span class="c">#   - &quot;bytes_...&quot; for integer variables that count input bytes</span>
    <span class="c">#   - &quot;chars_...&quot; for integer variables that count decoded characters</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;&lt;_pyio.TextIOWrapper&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; name={0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; mode={0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="s">&quot; encoding={0!r}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">line_buffering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">closed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s">&#39;Write data, where s is a str&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write </span><span class="si">%s</span><span class="s"> to text stream&quot;</span> <span class="o">%</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">haslf</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="ow">in</span> <span class="n">s</span>
        <span class="k">if</span> <span class="n">haslf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span> <span class="o">!=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span><span class="p">)</span>
        <span class="n">encoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_encoder</span><span class="p">()</span>
        <span class="c"># XXX What if we were just reading?</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span> <span class="ow">and</span> <span class="p">(</span><span class="n">haslf</span> <span class="ow">or</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">_get_encoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">make_encoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getincrementalencoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="o">=</span> <span class="n">make_encoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span>

    <span class="k">def</span> <span class="nf">_get_decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">make_decoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getincrementaldecoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">make_decoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span><span class="p">:</span>
            <span class="n">decoder</span> <span class="o">=</span> <span class="n">IncrementalNewlineDecoder</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="k">return</span> <span class="n">decoder</span>

    <span class="c"># The following three methods implement an ADT for _decoded_chars.</span>
    <span class="c"># Text returned from the decoder is buffered here until the client</span>
    <span class="c"># requests it by calling our read() or readline() method.</span>
    <span class="k">def</span> <span class="nf">_set_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_get_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advance into the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">[</span><span class="n">offset</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">_rewind_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rewind the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;rewind decoded_chars out of bounds&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">-=</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">_read_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read and decode the next chunk of data from the BufferedReader.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The return value is True unless EOF was reached.  The decoded</span>
        <span class="c"># string is placed in self._decoded_chars (replacing its previous</span>
        <span class="c"># value).  The entire input chunk is sent to the decoder, though</span>
        <span class="c"># some of it may remain buffered in the decoder, yet to be</span>
        <span class="c"># converted.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no decoder&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="c"># To prepare for tell(), we need to snapshot a point in the</span>
            <span class="c"># file where the decoder&#39;s input buffer is empty.</span>

            <span class="n">dec_buffer</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
            <span class="c"># Given this, we know there was a valid snapshot point</span>
            <span class="c"># len(dec_buffer) bytes ago with decoder state (b&#39;&#39;, dec_flags).</span>

        <span class="c"># Read a chunk, decode it, and put the result in self._decoded_chars.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_read1</span><span class="p">:</span>
            <span class="n">input_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span><span class="p">)</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">input_chunk</span>
        <span class="n">decoded_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">input_chunk</span><span class="p">,</span> <span class="n">eof</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="n">decoded_chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">decoded_chars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_b2cratio</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_chunk</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_b2cratio</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="c"># At the snapshot point, len(dec_buffer) bytes before the read,</span>
            <span class="c"># the next input to be decoded is dec_buffer + input_chunk.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">dec_buffer</span> <span class="o">+</span> <span class="n">input_chunk</span><span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">eof</span>

    <span class="k">def</span> <span class="nf">_pack_cookie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">bytes_to_feed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">need_eof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">chars_to_skip</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c"># The meaning of a tell() cookie is: seek to position, set the</span>
        <span class="c"># decoder flags to dec_flags, read bytes_to_feed bytes, feed them</span>
        <span class="c"># into the decoder with need_eof as the EOF flag, then skip</span>
        <span class="c"># chars_to_skip characters of the decoded result.  For most simple</span>
        <span class="c"># decoders, tell() will often just give a byte offset in the file.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">position</span> <span class="o">|</span> <span class="p">(</span><span class="n">dec_flags</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bytes_to_feed</span><span class="o">&lt;&lt;</span><span class="mi">128</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">(</span><span class="n">chars_to_skip</span><span class="o">&lt;&lt;</span><span class="mi">192</span><span class="p">)</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">(</span><span class="n">need_eof</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">256</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpack_cookie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bigint</span><span class="p">):</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">bigint</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">bytes_to_feed</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="n">bytes_to_feed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;underlying stream is not seekable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;telling position disabled by next() call&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span>
        <span class="k">if</span> <span class="n">decoder</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                <span class="c"># This should never happen.</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;pending decoded text&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">position</span>

        <span class="c"># Skip backward to the snapshot point (see _read_chunk).</span>
        <span class="n">dec_flags</span><span class="p">,</span> <span class="n">next_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span>
        <span class="n">position</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_input</span><span class="p">)</span>

        <span class="c"># How many decoded characters have been used up since the snapshot?</span>
        <span class="n">chars_to_skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span>
        <span class="k">if</span> <span class="n">chars_to_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># We haven&#39;t moved from the snapshot point.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack_cookie</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">)</span>

        <span class="c"># Starting from the snapshot position, we will walk the decoder</span>
        <span class="c"># forward until it gives us enough decoded characters.</span>
        <span class="n">saved_state</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Fast search for an acceptable start point, close to our</span>
            <span class="c"># current pos.</span>
            <span class="c"># Rationale: calling decoder.decode() has a large overhead</span>
            <span class="c"># regardless of chunk size; we want the number of such calls to</span>
            <span class="c"># be O(1) in most situations (common decoders, non-crazy input).</span>
            <span class="c"># Actually, it will be exactly 1 for fixed-size codecs (all</span>
            <span class="c"># 8-bit codecs, also UTF-16 and UTF-32).</span>
            <span class="n">skip_bytes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b2cratio</span> <span class="o">*</span> <span class="n">chars_to_skip</span><span class="p">)</span>
            <span class="n">skip_back</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">skip_bytes</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_input</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">skip_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">))</span>
                <span class="c"># Decode up to temptative start point</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">next_input</span><span class="p">[:</span><span class="n">skip_bytes</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                        <span class="c"># Before pos and no bytes buffered in decoder =&gt; OK</span>
                        <span class="n">dec_flags</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="n">chars_to_skip</span> <span class="o">-=</span> <span class="n">n</span>
                        <span class="k">break</span>
                    <span class="c"># Skip back by buffered amount and reset heuristic</span>
                    <span class="n">skip_bytes</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">skip_back</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># We&#39;re too far ahead, skip back a bit</span>
                    <span class="n">skip_bytes</span> <span class="o">-=</span> <span class="n">skip_back</span>
                    <span class="n">skip_back</span> <span class="o">=</span> <span class="n">skip_back</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">skip_bytes</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">))</span>

            <span class="c"># Note our initial start point.</span>
            <span class="n">start_pos</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">skip_bytes</span>
            <span class="n">start_flags</span> <span class="o">=</span> <span class="n">dec_flags</span>
            <span class="k">if</span> <span class="n">chars_to_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># We haven&#39;t moved from the start point.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack_cookie</span><span class="p">(</span><span class="n">start_pos</span><span class="p">,</span> <span class="n">start_flags</span><span class="p">)</span>

            <span class="c"># Feed the decoder one byte at a time.  As we go, note the</span>
            <span class="c"># nearest &quot;safe start point&quot; before the current location</span>
            <span class="c"># (a point where the decoder has nothing buffered, so seek()</span>
            <span class="c"># can safely start from there and advance to this location).</span>
            <span class="n">bytes_fed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">need_eof</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c"># Chars decoded since `start_pos`</span>
            <span class="n">chars_decoded</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skip_bytes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_input</span><span class="p">)):</span>
                <span class="n">bytes_fed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">chars_decoded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">next_input</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">dec_buffer</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dec_buffer</span> <span class="ow">and</span> <span class="n">chars_decoded</span> <span class="o">&lt;=</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="c"># Decoder buffer is empty, so this is a safe start point.</span>
                    <span class="n">start_pos</span> <span class="o">+=</span> <span class="n">bytes_fed</span>
                    <span class="n">chars_to_skip</span> <span class="o">-=</span> <span class="n">chars_decoded</span>
                    <span class="n">start_flags</span><span class="p">,</span> <span class="n">bytes_fed</span><span class="p">,</span> <span class="n">chars_decoded</span> <span class="o">=</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">chars_decoded</span> <span class="o">&gt;=</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># We didn&#39;t get enough decoded data; signal EOF to get more.</span>
                <span class="n">chars_decoded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                <span class="n">need_eof</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">chars_decoded</span> <span class="o">&lt;</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;can&#39;t reconstruct logical file position&quot;</span><span class="p">)</span>

            <span class="c"># The returned cookie corresponds to the last safe start point.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack_cookie</span><span class="p">(</span>
                <span class="n">start_pos</span><span class="p">,</span> <span class="n">start_flags</span><span class="p">,</span> <span class="n">bytes_fed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">saved_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;buffer is already detached&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="nb">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="nb">buffer</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tell on closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;underlying stream is not seekable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># seek relative to current position</span>
            <span class="k">if</span> <span class="n">cookie</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;can&#39;t do nonzero cur-relative seeks&quot;</span><span class="p">)</span>
            <span class="c"># Seeking to the current position should attempt to</span>
            <span class="c"># sync the underlying buffer with the current position.</span>
            <span class="n">whence</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cookie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># seek relative to end of file</span>
            <span class="k">if</span> <span class="n">cookie</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;can&#39;t do nonzero end-relative seeks&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">position</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unsupported whence (</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">whence</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">cookie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative seek position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cookie</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c"># The strategy of seek() is to go back to the safe start point</span>
        <span class="c"># and replay the effect of read(chars_to_skip) from there.</span>
        <span class="n">start_pos</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="n">bytes_to_feed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpack_cookie</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>

        <span class="c"># Seek back to the safe start point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start_pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Restore the decoder to its state from the safe start point.</span>
        <span class="k">if</span> <span class="n">cookie</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="n">dec_flags</span> <span class="ow">or</span> <span class="n">chars_to_skip</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chars_to_skip</span><span class="p">:</span>
            <span class="c"># Just like _read_chunk, feed the decoder and save a snapshot.</span>
            <span class="n">input_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">bytes_to_feed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">input_chunk</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">input_chunk</span><span class="p">)</span>

            <span class="c"># Skip chars_to_skip of the decoded characters.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s">&quot;can&#39;t restore logical file position&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="n">chars_to_skip</span>

        <span class="c"># Finally, reset the encoder (merely useful for proper BOM handling)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">encoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_encoder</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
            <span class="c"># Sometimes the encoder doesn&#39;t exist</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cookie</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">encoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">encoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cookie</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkReadable</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">size</span><span class="o">.</span><span class="n">__index__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;an integer is required&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Read everything.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span> <span class="o">+</span>
                      <span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Keep reading chunks until we have size characters to return.</span>
            <span class="n">eof</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eof</span><span class="p">:</span>
                <span class="n">eof</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_chunk</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">line</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;read from closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;size must be an integer&quot;</span><span class="p">)</span>

        <span class="c"># Grab all the decoded text (we will rewind any extra bits later).</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># Make the decoder if it doesn&#39;t already exist.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">endpos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span><span class="p">:</span>
                <span class="c"># Newlines are already translated, only search for \n</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span><span class="p">:</span>
                <span class="c"># Universal newline search. Find any of \r, \r\n, \n</span>
                <span class="c"># The decoder ensures that \r\n are not split in two pieces</span>

                <span class="c"># In C we&#39;d look for these in parallel of course.</span>
                <span class="n">nlpos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">crpos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">crpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c"># Nothing found</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># Found \n</span>
                        <span class="n">endpos</span> <span class="o">=</span> <span class="n">nlpos</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Found lone \r</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">&lt;</span> <span class="n">crpos</span><span class="p">:</span>
                    <span class="c"># Found \n</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">nlpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Found \r\n</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Found \r</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># non-universal</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">endpos</span> <span class="o">=</span> <span class="n">size</span>  <span class="c"># reached length size</span>
                <span class="k">break</span>

            <span class="c"># No line ending seen yet - get more data&#39;</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_chunk</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># end of file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="n">line</span>

        <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">endpos</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">size</span>  <span class="c"># don&#39;t exceed size</span>

        <span class="c"># Rewind _decoded_chars to just after the line ending we found.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_decoded_chars</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="n">endpos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line</span><span class="p">[:</span><span class="n">endpos</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">newlines</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="k">else</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">StringIO</span><span class="p">(</span><span class="n">TextIOWrapper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Text I/O implementation using an in-memory buffer.</span>

<span class="sd">    The initial_value argument sets the value of object.  The newline</span>
<span class="sd">    argument is like the one of TextIOWrapper&#39;s constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringIO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(),</span>
                                       <span class="n">encoding</span><span class="o">=</span><span class="s">&quot;utf-8&quot;</span><span class="p">,</span>
                                       <span class="n">errors</span><span class="o">=</span><span class="s">&quot;surrogatepass&quot;</span><span class="p">,</span>
                                       <span class="n">newline</span><span class="o">=</span><span class="n">newline</span><span class="p">)</span>
        <span class="c"># Issue #5645: make universal newlines semantics the same as in the</span>
        <span class="c"># C version, even under Windows.</span>
        <span class="k">if</span> <span class="n">newline</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">initial_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;initial_value must be str or None, not {0}&quot;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>
        <span class="n">old_state</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
        <span class="n">decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># TextIOWrapper tells the encoding in its repr. In StringIO,</span>
        <span class="c"># that&#39;s a implementation detail.</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># This doesn&#39;t make sense on StringIO.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;detach&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Weldon Henson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0.',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>