

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>importlib._bootstrap &mdash; ArcherBashPYDocs 1.0.0. documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ArcherBashPYDocs 1.0.0. documentation" href="../../index.html"/>
        <link rel="up" title="importlib" href="../importlib.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> ArcherBashPYDocs</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">ArcherBashPYDocs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../importlib.html">importlib</a> &raquo;</li>
      
    <li>importlib._bootstrap</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for importlib._bootstrap</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Core implementation of import.</span>

<span class="sd">This module is NOT meant to be directly imported! It has been designed such</span>
<span class="sd">that it can be bootstrapped into Python as the implementation of import. As</span>
<span class="sd">such it requires the injection of specific modules and attributes in order to</span>
<span class="sd">work. One should use importlib as the public-facing version of this module.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c"># IMPORTANT: Whenever making changes to this module, be sure to run</span>
<span class="c"># a top-level make in order to get the frozen version of the module</span>
<span class="c"># update. Not doing so will result in the Makefile to fail for</span>
<span class="c"># all others who don&#39;t have a ./python around to freeze the module</span>
<span class="c"># in the early stages of compilation.</span>
<span class="c">#</span>

<span class="c"># See importlib._setup() for what is injected into the global namespace.</span>

<span class="c"># When editing this code be aware that code executed at import time CANNOT</span>
<span class="c"># reference any injected objects! This includes not only global code but also</span>
<span class="c"># anything specified at the class level.</span>

<span class="c"># Bootstrap-related code ######################################################</span>

<span class="n">_CASE_INSENSITIVE_PLATFORMS</span> <span class="o">=</span> <span class="s">&#39;win&#39;</span><span class="p">,</span> <span class="s">&#39;cygwin&#39;</span><span class="p">,</span> <span class="s">&#39;darwin&#39;</span>


<span class="k">def</span> <span class="nf">_make_relax_case</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_CASE_INSENSITIVE_PLATFORMS</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_relax_case</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;True if filenames must be checked case-insensitively.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&#39;PYTHONCASEOK&#39;</span> <span class="ow">in</span> <span class="n">_os</span><span class="o">.</span><span class="n">environ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_relax_case</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;True if filenames must be checked case-insensitively.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">_relax_case</span>


<span class="k">def</span> <span class="nf">_w_long</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a 32-bit integer to little-endian.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&#39;little&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_r_long</span><span class="p">(</span><span class="n">int_bytes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert 4 bytes in little-endian to an integer.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">int_bytes</span><span class="p">,</span> <span class="s">&#39;little&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_path_join</span><span class="p">(</span><span class="o">*</span><span class="n">path_parts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replacement for os.path.join().&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">path_sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">part</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">path_separators</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">path_parts</span> <span class="k">if</span> <span class="n">part</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_path_split</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replacement for os.path.split().&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_separators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">front</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="n">path_sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">front</span><span class="p">,</span> <span class="n">tail</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">path_separators</span><span class="p">:</span>
            <span class="n">front</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">front</span><span class="p">,</span> <span class="n">tail</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">path</span>


<span class="k">def</span> <span class="nf">_path_stat</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stat the path.</span>

<span class="sd">    Made a separate function to make it easier to override in experiments</span>
<span class="sd">    (e.g. cache stat results).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_path_is_mode_type</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test whether the path is the specified mode type.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stat_info</span> <span class="o">=</span> <span class="n">_path_stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">stat_info</span><span class="o">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="mi">0</span><span class="n">o170000</span><span class="p">)</span> <span class="o">==</span> <span class="n">mode</span>


<span class="k">def</span> <span class="nf">_path_isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replacement for os.path.isfile.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_path_is_mode_type</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="n">o100000</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_path_isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replacement for os.path.isdir.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_path_is_mode_type</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="n">o040000</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_write_atomic</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="n">o666</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Best-effort function to write data to a path atomically.</span>
<span class="sd">    Be prepared to handle a FileExistsError if concurrent writing of the</span>
<span class="sd">    temporary file is attempted.&quot;&quot;&quot;</span>
    <span class="c"># id() is used to generate a pseudo-random filename.</span>
    <span class="n">path_tmp</span> <span class="o">=</span> <span class="s">&#39;{}.{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">,</span>
                  <span class="n">_os</span><span class="o">.</span><span class="n">O_EXCL</span> <span class="o">|</span> <span class="n">_os</span><span class="o">.</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">_os</span><span class="o">.</span><span class="n">O_WRONLY</span><span class="p">,</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">0</span><span class="n">o666</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># We first write data to a temporary file, and then use os.replace() to</span>
        <span class="c"># perform an atomic rename.</span>
        <span class="k">with</span> <span class="n">_io</span><span class="o">.</span><span class="n">FileIO</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
            <span class="nb">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">_os</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>


<span class="k">def</span> <span class="nf">_wrap</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple substitute for functools.update_wrapper.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">replace</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;__module__&#39;</span><span class="p">,</span> <span class="s">&#39;__name__&#39;</span><span class="p">,</span> <span class="s">&#39;__qualname__&#39;</span><span class="p">,</span> <span class="s">&#39;__doc__&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">replace</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">replace</span><span class="p">))</span>
    <span class="n">new</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_new_module</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys</span><span class="p">)(</span><span class="n">name</span><span class="p">)</span>


<span class="n">_code_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">_wrap</span><span class="o">.</span><span class="n">__code__</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">_ManageReload</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Manages the possible clean-up of sys.modules for load_module().&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_reload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reload</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

<span class="c"># Module-level locking ########################################################</span>

<span class="c"># A dict mapping module names to weakrefs of _ModuleLock instances</span>
<span class="n">_module_locks</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c"># A dict mapping thread ids to _ModuleLock instances</span>
<span class="n">_blocking_on</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">_DeadlockError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_ModuleLock</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A recursive lock implementation which is able to detect deadlocks</span>
<span class="sd">    (e.g. thread 1 trying to take locks A then B, and thread 2 trying to</span>
<span class="sd">    take locks B then A).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">allocate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">allocate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiters</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">has_deadlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Deadlock avoidance for concurrent circular imports.</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">_blocking_on</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">tid</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">owner</span>
            <span class="k">if</span> <span class="n">tid</span> <span class="o">==</span> <span class="n">me</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acquire the module lock.  If a potential deadlock is detected,</span>
<span class="sd">        a _DeadlockError is raised.</span>
<span class="sd">        Otherwise, the lock is always acquired and True is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>
        <span class="n">_blocking_on</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">tid</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">tid</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_deadlock</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="n">_DeadlockError</span><span class="p">(</span><span class="s">&#39;deadlock detected by </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wakeup</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">waiters</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c"># Wait for a release() call</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wakeup</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wakeup</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_blocking_on</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">tid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;cannot release un-acquired lock&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waiters</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">waiters</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wakeup</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;_ModuleLock({!r}) at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_DummyModuleLock</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple _ModuleLock equivalent for Python builds without</span>
<span class="sd">    multi-threading support.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;cannot release un-acquired lock&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;_DummyModuleLock({!r}) at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_ModuleLockManager</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">_get_module_lock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">_imp</span><span class="o">.</span><span class="n">release_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="c"># The following two functions are for consumption by Python/import.c.</span>

<span class="k">def</span> <span class="nf">_get_module_lock</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get or create the module lock for a given module name.</span>

<span class="sd">    Should only be called with the import lock taken.&quot;&quot;&quot;</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">_module_locks</span><span class="p">[</span><span class="n">name</span><span class="p">]()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_thread</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">_DummyModuleLock</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">_ModuleLock</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">cb</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">_module_locks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">_module_locks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lock</span>

<span class="k">def</span> <span class="nf">_lock_unlock_module</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Release the global import lock, and acquires then release the</span>
<span class="sd">    module lock for a given module name.</span>
<span class="sd">    This is used to ensure a module is completely initialized, in the</span>
<span class="sd">    event it is being imported by another thread.</span>

<span class="sd">    Should only be called with the import lock taken.&quot;&quot;&quot;</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">_get_module_lock</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">_imp</span><span class="o">.</span><span class="n">release_lock</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">_DeadlockError</span><span class="p">:</span>
        <span class="c"># Concurrent circular import, we&#39;ll accept a partially initialized</span>
        <span class="c"># module object.</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c"># Frame stripping magic ###############################################</span>

<span class="k">def</span> <span class="nf">_call_with_frames_removed</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;remove_importlib_frames in import.c will always remove sequences</span>
<span class="sd">    of importlib frames that end with a call to this function</span>

<span class="sd">    Use it instead of a normal call in places where including the importlib</span>
<span class="sd">    frames introduces unwanted noise into the traceback (e.g. when executing</span>
<span class="sd">    module code)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="c"># Finder/loader utility code ###############################################</span>

<span class="c"># Magic word to reject .pyc files generated by other Python versions.</span>
<span class="c"># It should change for each incompatible change to the bytecode.</span>
<span class="c">#</span>
<span class="c"># The value of CR and LF is incorporated so if you ever read or write</span>
<span class="c"># a .pyc file in text mode the magic number will be wrong; also, the</span>
<span class="c"># Apple MPW compiler swaps their values, botching string constants.</span>
<span class="c">#</span>
<span class="c"># The magic numbers must be spaced apart at least 2 values, as the</span>
<span class="c"># -U interpeter flag will cause MAGIC+1 being used. They have been</span>
<span class="c"># odd numbers for some time now.</span>
<span class="c">#</span>
<span class="c"># There were a variety of old schemes for setting the magic number.</span>
<span class="c"># The current working scheme is to increment the previous value by</span>
<span class="c"># 10.</span>
<span class="c">#</span>
<span class="c"># Starting with the adoption of PEP 3147 in Python 3.2, every bump in magic</span>
<span class="c"># number also includes a new &quot;magic tag&quot;, i.e. a human readable string used</span>
<span class="c"># to represent the magic number in __pycache__ directories.  When you change</span>
<span class="c"># the magic number, you must also set a new unique magic tag.  Generally this</span>
<span class="c"># can be named after the Python major version of the magic number bump, but</span>
<span class="c"># it can really be anything, as long as it&#39;s different than anything else</span>
<span class="c"># that&#39;s come before.  The tags are included in the following table, starting</span>
<span class="c"># with Python 3.2a0.</span>
<span class="c">#</span>
<span class="c"># Known values:</span>
<span class="c">#  Python 1.5:   20121</span>
<span class="c">#  Python 1.5.1: 20121</span>
<span class="c">#     Python 1.5.2: 20121</span>
<span class="c">#     Python 1.6:   50428</span>
<span class="c">#     Python 2.0:   50823</span>
<span class="c">#     Python 2.0.1: 50823</span>
<span class="c">#     Python 2.1:   60202</span>
<span class="c">#     Python 2.1.1: 60202</span>
<span class="c">#     Python 2.1.2: 60202</span>
<span class="c">#     Python 2.2:   60717</span>
<span class="c">#     Python 2.3a0: 62011</span>
<span class="c">#     Python 2.3a0: 62021</span>
<span class="c">#     Python 2.3a0: 62011 (!)</span>
<span class="c">#     Python 2.4a0: 62041</span>
<span class="c">#     Python 2.4a3: 62051</span>
<span class="c">#     Python 2.4b1: 62061</span>
<span class="c">#     Python 2.5a0: 62071</span>
<span class="c">#     Python 2.5a0: 62081 (ast-branch)</span>
<span class="c">#     Python 2.5a0: 62091 (with)</span>
<span class="c">#     Python 2.5a0: 62092 (changed WITH_CLEANUP opcode)</span>
<span class="c">#     Python 2.5b3: 62101 (fix wrong code: for x, in ...)</span>
<span class="c">#     Python 2.5b3: 62111 (fix wrong code: x += yield)</span>
<span class="c">#     Python 2.5c1: 62121 (fix wrong lnotab with for loops and</span>
<span class="c">#                          storing constants that should have been removed)</span>
<span class="c">#     Python 2.5c2: 62131 (fix wrong code: for x, in ... in listcomp/genexp)</span>
<span class="c">#     Python 2.6a0: 62151 (peephole optimizations and STORE_MAP opcode)</span>
<span class="c">#     Python 2.6a1: 62161 (WITH_CLEANUP optimization)</span>
<span class="c">#     Python 2.7a0: 62171 (optimize list comprehensions/change LIST_APPEND)</span>
<span class="c">#     Python 2.7a0: 62181 (optimize conditional branches:</span>
<span class="c">#                          introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE)</span>
<span class="c">#     Python 2.7a0  62191 (introduce SETUP_WITH)</span>
<span class="c">#     Python 2.7a0  62201 (introduce BUILD_SET)</span>
<span class="c">#     Python 2.7a0  62211 (introduce MAP_ADD and SET_ADD)</span>
<span class="c">#     Python 3000:   3000</span>
<span class="c">#                    3010 (removed UNARY_CONVERT)</span>
<span class="c">#                    3020 (added BUILD_SET)</span>
<span class="c">#                    3030 (added keyword-only parameters)</span>
<span class="c">#                    3040 (added signature annotations)</span>
<span class="c">#                    3050 (print becomes a function)</span>
<span class="c">#                    3060 (PEP 3115 metaclass syntax)</span>
<span class="c">#                    3061 (string literals become unicode)</span>
<span class="c">#                    3071 (PEP 3109 raise changes)</span>
<span class="c">#                    3081 (PEP 3137 make __file__ and __name__ unicode)</span>
<span class="c">#                    3091 (kill str8 interning)</span>
<span class="c">#                    3101 (merge from 2.6a0, see 62151)</span>
<span class="c">#                    3103 (__file__ points to source file)</span>
<span class="c">#     Python 3.0a4: 3111 (WITH_CLEANUP optimization).</span>
<span class="c">#     Python 3.0a5: 3131 (lexical exception stacking, including POP_EXCEPT)</span>
<span class="c">#     Python 3.1a0: 3141 (optimize list, set and dict comprehensions:</span>
<span class="c">#             change LIST_APPEND and SET_ADD, add MAP_ADD)</span>
<span class="c">#     Python 3.1a0: 3151 (optimize conditional branches:</span>
<span class="c">#             introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE)</span>
<span class="c">#     Python 3.2a0: 3160 (add SETUP_WITH)</span>
<span class="c">#                   tag: cpython-32</span>
<span class="c">#     Python 3.2a1: 3170 (add DUP_TOP_TWO, remove DUP_TOPX and ROT_FOUR)</span>
<span class="c">#                   tag: cpython-32</span>
<span class="c">#     Python 3.2a2  3180 (add DELETE_DEREF)</span>
<span class="c">#     Python 3.3a0  3190 __class__ super closure changed</span>
<span class="c">#     Python 3.3a0  3200 (__qualname__ added)</span>
<span class="c">#                      3210 (added size modulo 2**32 to the pyc header)</span>
<span class="c">#     Python 3.3a1  3220 (changed PEP 380 implementation)</span>
<span class="c">#     Python 3.3a4  3230 (revert changes to implicit __class__ closure)</span>
<span class="c">#     Python 3.4a1  3250 (evaluate positional default arguments before</span>
<span class="c">#                        keyword-only defaults)</span>
<span class="c">#     Python 3.4a1  3260 (add LOAD_CLASSDEREF; allow locals of class to override</span>
<span class="c">#                        free vars)</span>
<span class="c">#     Python 3.4a1  3270 (various tweaks to the __class__ closure)</span>
<span class="c">#     Python 3.4a1  3280 (remove implicit class argument)</span>
<span class="c">#     Python 3.4a4  3290 (changes to __qualname__ computation)</span>
<span class="c">#     Python 3.4a4  3300 (more changes to __qualname__ computation)</span>
<span class="c">#     Python 3.4rc2 3310 (alter __qualname__ computation)</span>
<span class="c">#</span>
<span class="c"># MAGIC must change whenever the bytecode emitted by the compiler may no</span>
<span class="c"># longer be understood by older implementations of the eval loop (usually</span>
<span class="c"># due to the addition of new opcodes).</span>

<span class="n">MAGIC_NUMBER</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3310</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;little&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span>
<span class="n">_RAW_MAGIC_NUMBER</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">MAGIC_NUMBER</span><span class="p">,</span> <span class="s">&#39;little&#39;</span><span class="p">)</span>  <span class="c"># For import.c</span>

<span class="n">_PYCACHE</span> <span class="o">=</span> <span class="s">&#39;__pycache__&#39;</span>

<span class="n">SOURCE_SUFFIXES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;.py&#39;</span><span class="p">]</span>  <span class="c"># _setup() adds .pyw as needed.</span>

<span class="n">DEBUG_BYTECODE_SUFFIXES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;.pyc&#39;</span><span class="p">]</span>
<span class="n">OPTIMIZED_BYTECODE_SUFFIXES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;.pyo&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">cache_from_source</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">debug_override</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given the path to a .py file, return the path to its .pyc/.pyo file.</span>

<span class="sd">    The .py file does not need to exist; this simply returns the path to the</span>
<span class="sd">    .pyc/.pyo file calculated as if the .py file were imported.  The extension</span>
<span class="sd">    will be .pyc unless sys.flags.optimize is non-zero, then it will be .pyo.</span>

<span class="sd">    If debug_override is not None, then it must be a boolean and is used in</span>
<span class="sd">    place of sys.flags.optimize.</span>

<span class="sd">    If sys.implementation.cache_tag is None then NotImplementedError is raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">optimize</span> <span class="k">if</span> <span class="n">debug_override</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">debug_override</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="n">DEBUG_BYTECODE_SUFFIXES</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="n">OPTIMIZED_BYTECODE_SUFFIXES</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">base_filename</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">implementation</span><span class="o">.</span><span class="n">cache_tag</span>
    <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;sys.implementation.cache_tag is None&#39;</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">base_filename</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">_path_join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">_PYCACHE</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">source_from_cache</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given the path to a .pyc./.pyo file, return the path to its .py file.</span>

<span class="sd">    The .pyc/.pyo file does not need to exist; this simply returns the path to</span>
<span class="sd">    the .py file calculated to correspond to the .pyc/.pyo file.  If path does</span>
<span class="sd">    not conform to PEP 3147 format, ValueError will be raised. If</span>
<span class="sd">    sys.implementation.cache_tag is None then NotImplementedError is raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">implementation</span><span class="o">.</span><span class="n">cache_tag</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;sys.implementation.cache_tag is None&#39;</span><span class="p">)</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">pycache_filename</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">pycache</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pycache</span> <span class="o">!=</span> <span class="n">_PYCACHE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;{} not bottom-level directory in &#39;</span>
                         <span class="s">&#39;{!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_PYCACHE</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pycache_filename</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expected only 2 dots in &#39;</span>
                         <span class="s">&#39;{!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pycache_filename</span><span class="p">))</span>
    <span class="n">base_filename</span> <span class="o">=</span> <span class="n">pycache_filename</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_path_join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">base_filename</span> <span class="o">+</span> <span class="n">SOURCE_SUFFIXES</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_sourcefile</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a bytecode file path to a source path (if possible).</span>

<span class="sd">    This function exists purely for backwards-compatibility for</span>
<span class="sd">    PyImport_ExecCodeModuleWithFilenames() in the C API.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">rest</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">bytecode_path</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rest</span> <span class="ow">or</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;py&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bytecode_path</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">source_path</span> <span class="o">=</span> <span class="n">source_from_cache</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">source_path</span> <span class="o">=</span> <span class="n">bytecode_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">source_path</span> <span class="k">if</span> <span class="n">_path_isfile</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span> <span class="k">else</span> <span class="n">bytecode_path</span>


<span class="k">def</span> <span class="nf">_calc_mode</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the mode permissions for a bytecode file.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">_path_stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="n">o666</span>
    <span class="c"># We always ensure write access so we can update cached files</span>
    <span class="c"># later even when the source files are read-only on Windows (#6074)</span>
    <span class="n">mode</span> <span class="o">|=</span> <span class="mi">0</span><span class="n">o200</span>
    <span class="k">return</span> <span class="n">mode</span>


<span class="k">def</span> <span class="nf">_verbose_message</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print the message to stderr if -v/PYTHONVERBOSE is turned on.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="n">verbosity</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s">&#39;#&#39;</span><span class="p">,</span> <span class="s">&#39;import &#39;</span><span class="p">)):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;# &#39;</span> <span class="o">+</span> <span class="n">message</span>
        <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_name</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to verify that the module being requested matches the one the</span>
<span class="sd">    loader can handle.</span>

<span class="sd">    The first argument (self) must define _name which the second argument is</span>
<span class="sd">    compared against. If the comparison fails then ImportError is raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_check_name_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;loader cannot handle </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">_wrap</span><span class="p">(</span><span class="n">_check_name_wrapper</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_check_name_wrapper</span>


<span class="k">def</span> <span class="nf">_requires_builtin</span><span class="p">(</span><span class="n">fxn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to verify the named module is built-in.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_requires_builtin_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fullname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;{!r} is not a built-in module&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fullname</span><span class="p">),</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fxn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
    <span class="n">_wrap</span><span class="p">(</span><span class="n">_requires_builtin_wrapper</span><span class="p">,</span> <span class="n">fxn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_requires_builtin_wrapper</span>


<span class="k">def</span> <span class="nf">_requires_frozen</span><span class="p">(</span><span class="n">fxn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to verify the named module is frozen.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_requires_frozen_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;{!r} is not a frozen module&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fullname</span><span class="p">),</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fxn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
    <span class="n">_wrap</span><span class="p">(</span><span class="n">_requires_frozen_wrapper</span><span class="p">,</span> <span class="n">fxn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_requires_frozen_wrapper</span>


<span class="k">def</span> <span class="nf">_find_module_shim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to find a loader for the specified module by delegating to</span>
<span class="sd">    self.find_loader().</span>

<span class="sd">    This method is deprecated in favor of finder.find_spec().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Call find_loader(). If it returns a string (indicating this</span>
    <span class="c"># is a namespace package portion), generate a warning and</span>
    <span class="c"># return None.</span>
    <span class="n">loader</span><span class="p">,</span> <span class="n">portions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">portions</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Not importing directory {}: missing __init__&#39;</span>
        <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">portions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="ne">ImportWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loader</span>


<span class="k">def</span> <span class="nf">_load_module_shim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load the specified module into sys.modules and return it.</span>

<span class="sd">    This method is deprecated.  Use loader.exec_module instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="n">_SpecMethods</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fullname</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">fullname</span><span class="p">]</span>
        <span class="n">methods</span><span class="o">.</span><span class="k">exec</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">fullname</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">methods</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_validate_bytecode_header</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">source_stats</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validate the header of the passed-in bytecode against source_stats (if</span>
<span class="sd">    given) and returning the bytecode that can be compiled by compile().</span>

<span class="sd">    All other arguments are used to enhance error reporting.</span>

<span class="sd">    ImportError is raised when the magic number is incorrect or the bytecode is</span>
<span class="sd">    found to be stale. EOFError is raised when the data is found to be</span>
<span class="sd">    truncated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exc_details</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">exc_details</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># To prevent having to make all messages have a conditional name.</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;&lt;bytecode&gt;&#39;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">exc_details</span><span class="p">[</span><span class="s">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
    <span class="n">magic</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">raw_timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">raw_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">magic</span> <span class="o">!=</span> <span class="n">MAGIC_NUMBER</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;bad magic number in {!r}: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">magic</span><span class="p">)</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">**</span><span class="n">exc_details</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_timestamp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;reached EOF while reading timestamp in {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;reached EOF while reading size of source in {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">source_mtime</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">source_stats</span><span class="p">[</span><span class="s">&#39;mtime&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_r_long</span><span class="p">(</span><span class="n">raw_timestamp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">source_mtime</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s">&#39;bytecode is stale for {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">_verbose_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">**</span><span class="n">exc_details</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">source_size</span> <span class="o">=</span> <span class="n">source_stats</span><span class="p">[</span><span class="s">&#39;size&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_r_long</span><span class="p">(</span><span class="n">raw_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">source_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;bytecode is stale for {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                                  <span class="o">**</span><span class="n">exc_details</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">_compile_bytecode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">source_path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compile bytecode as returned by _validate_bytecode_header().&quot;&quot;&quot;</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">_code_type</span><span class="p">):</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;code object from {!r}&#39;</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_imp</span><span class="o">.</span><span class="n">_fix_co_filename</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">source_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">code</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;Non-code object in {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">),</span>
                          <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">bytecode_path</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_code_to_bytecode</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">mtime</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">source_size</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compile a code object into bytecode for writing out to a byte-compiled</span>
<span class="sd">    file.&quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">MAGIC_NUMBER</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_w_long</span><span class="p">(</span><span class="n">mtime</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_w_long</span><span class="p">(</span><span class="n">source_size</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">marshal</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">decode_source</span><span class="p">(</span><span class="n">source_bytes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode bytes representing source code and return the string.</span>

<span class="sd">    Universal newline support is used in the decoding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">tokenize</span>  <span class="c"># To avoid bootstrap issues.</span>
    <span class="n">source_bytes_readline</span> <span class="o">=</span> <span class="n">_io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">source_bytes</span><span class="p">)</span><span class="o">.</span><span class="n">readline</span>
    <span class="n">encoding</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">detect_encoding</span><span class="p">(</span><span class="n">source_bytes_readline</span><span class="p">)</span>
    <span class="n">newline_decoder</span> <span class="o">=</span> <span class="n">_io</span><span class="o">.</span><span class="n">IncrementalNewlineDecoder</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newline_decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">source_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>


<span class="c"># Module specifications #######################################################</span>

<span class="k">def</span> <span class="nf">_module_repr</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
    <span class="c"># The implementation of ModuleType__repr__().</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__loader__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;module_repr&#39;</span><span class="p">):</span>
        <span class="c"># As soon as BuiltinImporter, FrozenImporter, and NamespaceLoader</span>
        <span class="c"># drop their implementations for module_repr. we can add a</span>
        <span class="c"># deprecation warning here.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loader</span><span class="o">.</span><span class="n">module_repr</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_SpecMethods</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">module_repr</span><span class="p">()</span>

    <span class="c"># We could use module.__class__.__name__ instead of &#39;module&#39; in the</span>
    <span class="c"># various repr permutations.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__file__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;&lt;module {!r}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;&lt;module {!r} ({!r})&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;&lt;module {!r} from {!r}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_installed_safely</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module</span> <span class="o">=</span> <span class="n">module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># This must be done before putting the module in sys.modules</span>
        <span class="c"># (otherwise an optimization shortcut in import.c becomes</span>
        <span class="c"># wrong)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">_initializing</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;import {!r} # {!r}&#39;</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">_initializing</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">class</span> <span class="nc">ModuleSpec</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The specification for a module, used for loading.</span>

<span class="sd">    A module&#39;s spec is the source for information about the module.  For</span>
<span class="sd">    data associated with the module, including source, use the spec&#39;s</span>
<span class="sd">    loader.</span>

<span class="sd">    `name` is the absolute name of the module.  `loader` is the loader</span>
<span class="sd">    to use when loading the module.  `parent` is the name of the</span>
<span class="sd">    package the module is in.  The parent is derived from the name.</span>

<span class="sd">    `is_package` determines if the module is considered a package or</span>
<span class="sd">    not.  On modules this is reflected by the `__path__` attribute.</span>

<span class="sd">    `origin` is the specific location used by the loader from which to</span>
<span class="sd">    load the module, if that information is available.  When filename is</span>
<span class="sd">    set, origin will match.</span>

<span class="sd">    `has_location` indicates that a spec&#39;s &quot;origin&quot; reflects a location.</span>
<span class="sd">    When this is True, `__file__` attribute of the module is set.</span>

<span class="sd">    `cached` is the location of the cached bytecode file, if any.  It</span>
<span class="sd">    corresponds to the `__cached__` attribute.</span>

<span class="sd">    `submodule_search_locations` is the sequence of path entries to</span>
<span class="sd">    search when importing submodules.  If set, is_package should be</span>
<span class="sd">    True--and False otherwise.</span>

<span class="sd">    Packages are simply modules that (may) have submodules.  If a spec</span>
<span class="sd">    has a non-None value in `submodule_search_locations`, the import</span>
<span class="sd">    system will consider modules loaded from the spec as packages.</span>

<span class="sd">    Only finders (see importlib.abc.MetaPathFinder and</span>
<span class="sd">    importlib.abc.PathEntryFinder) should modify ModuleSpec instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loader_state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">is_package</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loader_state</span> <span class="o">=</span> <span class="n">loader_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">is_package</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="c"># file-location attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_fileattr</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="s">&#39;loader={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;origin={!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;submodule_search_locations={}&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">submodule_search_locations</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&#39;{}({})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">smsl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submodule_search_locations</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">loader</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">loader</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">origin</span> <span class="ow">and</span>
                    <span class="n">smsl</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cached</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">cached</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">has_location</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">has_location</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_fileattr</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
                <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="n">cache_from_source</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">BYTECODE_SUFFIXES</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span>

    <span class="nd">@cached.setter</span>
    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cached</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="n">cached</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the module&#39;s parent.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_fileattr</span>

    <span class="nd">@has_location.setter</span>
    <span class="k">def</span> <span class="nf">has_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_fileattr</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">spec_from_loader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_package</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a module spec based on various loader methods.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;get_filename&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_package</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="n">loader</span><span class="p">)</span>
        <span class="n">search</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">is_package</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="n">loader</span><span class="p">,</span>
                                       <span class="n">submodule_search_locations</span><span class="o">=</span><span class="n">search</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_package</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;is_package&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">is_package</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">is_package</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># aka, undefined</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># the default</span>
            <span class="n">is_package</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">is_package</span><span class="o">=</span><span class="n">is_package</span><span class="p">)</span>


<span class="n">_POPULATE</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">spec_from_file_location</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">submodule_search_locations</span><span class="o">=</span><span class="n">_POPULATE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a module spec based on a file location.</span>

<span class="sd">    To indicate that the module is a package, set</span>
<span class="sd">    submodule_search_locations to a list of directory paths.  An</span>
<span class="sd">    empty list is sufficient, though its not otherwise useful to the</span>
<span class="sd">    import system.</span>

<span class="sd">    The loader must take a spec as its only __init__() arg.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># The caller may simply want a partially populated location-</span>
        <span class="c"># oriented spec.  So we set the location to a bogus value and</span>
        <span class="c"># fill in as much as we can.</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s">&#39;&lt;unknown&gt;&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;get_filename&#39;</span><span class="p">):</span>
            <span class="c"># ExecutionLoader</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="c"># If the location is on the filesystem, but doesn&#39;t actually exist,</span>
    <span class="c"># we could return None here, indicating that the location is not</span>
    <span class="c"># valid.  However, we don&#39;t have a good way of testing since an</span>
    <span class="c"># indirect location (e.g. a zip file or URL) will look like a</span>
    <span class="c"># non-existent file relative to the filesystem.</span>

    <span class="n">spec</span> <span class="o">=</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">location</span><span class="p">)</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">_set_fileattr</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c"># Pick a loader if one wasn&#39;t provided.</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">loader_class</span><span class="p">,</span> <span class="n">suffixes</span> <span class="ow">in</span> <span class="n">_get_supported_file_loaders</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)):</span>
                <span class="n">loader</span> <span class="o">=</span> <span class="n">loader_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">location</span><span class="p">)</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># Set submodule_search_paths appropriately.</span>
    <span class="k">if</span> <span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="n">_POPULATE</span><span class="p">:</span>
        <span class="c"># Check the loader.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;is_package&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">is_package</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_package</span><span class="p">:</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="n">submodule_search_locations</span>
    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">if</span> <span class="n">location</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">location</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spec</span>


<span class="k">def</span> <span class="nf">_spec_from_module</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># This function is meant for use in _setup().</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__loader__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># loader will stay None.</span>
            <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__file__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">_ORIGIN</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">location</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__cached__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__path__</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">spec</span> <span class="o">=</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">_set_fileattr</span> <span class="o">=</span> <span class="bp">False</span> <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">True</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">cached</span> <span class="o">=</span> <span class="n">cached</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="n">submodule_search_locations</span>
    <span class="k">return</span> <span class="n">spec</span>


<span class="k">class</span> <span class="nc">_SpecMethods</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Convenience wrapper around spec objects to provide spec-specific</span>
<span class="sd">    methods.&quot;&quot;&quot;</span>

    <span class="c"># The various spec_from_* functions could be made factory methods here.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the repr to use for the module.&quot;&quot;&quot;</span>
        <span class="c"># We mostly replicate _module_repr() using the spec attributes.</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;&lt;module {!r}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;&lt;module {!r} ({!r})&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">has_location</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;&lt;module {!r} from {!r}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;&lt;module {!r} ({})&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_module_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_override</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">_force_name</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the module&#39;s attributes.</span>

<span class="sd">        All missing import-related module attributes will be set.  Here</span>
<span class="sd">        is how the spec attributes map onto the module:</span>

<span class="sd">        spec.name -&gt; module.__name__</span>
<span class="sd">        spec.loader -&gt; module.__loader__</span>
<span class="sd">        spec.parent -&gt; module.__package__</span>
<span class="sd">        spec -&gt; module.__spec__</span>

<span class="sd">        Optional:</span>
<span class="sd">        spec.origin -&gt; module.__file__ (if spec.set_fileattr is true)</span>
<span class="sd">        spec.cached -&gt; module.__cached__ (if __file__ also set)</span>
<span class="sd">        spec.submodule_search_locations -&gt; module.__path__ (if set)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span>

        <span class="c"># The passed in module may be not support attribute assignment,</span>
        <span class="c"># in which case we simply don&#39;t set the attributes.</span>

        <span class="c"># __name__</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_override</span> <span class="ow">or</span> <span class="n">_force_name</span> <span class="ow">or</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__name__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c"># __loader__</span>
        <span class="k">if</span> <span class="n">_override</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__loader__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span>
            <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># A backward compatibility hack.</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">loader</span> <span class="o">=</span> <span class="n">_NamespaceLoader</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">_NamespaceLoader</span><span class="p">)</span>
                    <span class="n">loader</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">loader</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c"># __package__</span>
        <span class="k">if</span> <span class="n">_override</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__package__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">parent</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c"># __spec__</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c"># __path__</span>
        <span class="k">if</span> <span class="n">_override</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__path__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">__path__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">has_location</span><span class="p">:</span>
            <span class="c"># __file__</span>
            <span class="k">if</span> <span class="n">_override</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__file__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">__file__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c"># __cached__</span>
            <span class="k">if</span> <span class="n">_override</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__cached__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">cached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">module</span><span class="o">.</span><span class="n">__cached__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">cached</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new module to be loaded.</span>

<span class="sd">        The import-related module attributes are also set with the</span>
<span class="sd">        appropriate values from the spec.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span>
        <span class="c"># Typically loaders will not implement create_module().</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;create_module&#39;</span><span class="p">):</span>
            <span class="c"># If create_module() returns `None` it means the default</span>
            <span class="c"># module creation should be used.</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># This must be done before open() is ever called as the &#39;io&#39;</span>
            <span class="c"># module implicitly imports &#39;locale&#39; and would otherwise</span>
            <span class="c"># trigger an infinite loop.</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">_new_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_module_attrs</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">_exec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do everything necessary to execute the module.</span>

<span class="sd">        The namespace of `module` is used as the target of execution.</span>
<span class="sd">        This method uses the loader&#39;s `exec_module()` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="c"># Used by importlib.reload() and _load_module_shim().</span>
    <span class="k">def</span> <span class="nf">exec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the spec in an existing module&#39;s namespace.&quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">acquire_lock</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_ModuleLockManager</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">module</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;module {!r} not in sys.modules&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;missing loader&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="c"># namespace package</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_module_attrs</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">_override</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_module_attrs</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">_override</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;exec_module&#39;</span><span class="p">):</span>
                <span class="c"># (issue19713) Once BuiltinImporter and ExtensionFileLoader</span>
                <span class="c"># have exec_module() implemented, we can add a deprecation</span>
                <span class="c"># warning here.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exec</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_load_backward_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># (issue19713) Once BuiltinImporter and ExtensionFileLoader</span>
        <span class="c"># have exec_module() implemented, we can add a deprecation</span>
        <span class="c"># warning here.</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c"># The module must be in sys.modules at this point!</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__loader__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__package__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># Since module.__path__ may not line up with</span>
                <span class="c"># spec.submodule_search_paths, we can&#39;t necessarily rely</span>
                <span class="c"># on spec.parent here.</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__path__&#39;</span><span class="p">):</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__spec__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">_load_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># A helper for direct use by the import system.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># not a namespace package</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s">&#39;exec_module&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_backward_compatible</span><span class="p">()</span>

        <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_installed_safely</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;missing loader&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="c"># A namespace package so do nothing.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exec</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

        <span class="c"># We don&#39;t ensure that the import-related module attributes get</span>
        <span class="c"># set in the sys.modules replacement case.  Such modules are on</span>
        <span class="c"># their own.</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="c"># A method used during testing of _load_unlocked() and by</span>
    <span class="c"># _load_module_shim().</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new module object, loaded by the spec&#39;s loader.</span>

<span class="sd">        The module is not added to its parent.</span>

<span class="sd">        If a module is already in sys.modules, that existing module gets</span>
<span class="sd">        clobbered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">acquire_lock</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_ModuleLockManager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_unlocked</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_fix_up_module</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">cpathname</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># This function is used by PyImport_ExecCodeModuleObject().</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;__loader__&#39;</span><span class="p">)</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;__spec__&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">spec</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span>
        <span class="k">elif</span> <span class="n">pathname</span> <span class="o">==</span> <span class="n">cpathname</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">SourcelessFileLoader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pathname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">SourceFileLoader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pathname</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">spec</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ns</span><span class="p">[</span><span class="s">&#39;__spec__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="n">ns</span><span class="p">[</span><span class="s">&#39;__loader__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loader</span>
        <span class="n">ns</span><span class="p">[</span><span class="s">&#39;__file__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathname</span>
        <span class="n">ns</span><span class="p">[</span><span class="s">&#39;__cached__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpathname</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c"># Not important enough to report.</span>
        <span class="k">pass</span>


<span class="c"># Loaders #####################################################################</span>

<span class="k">class</span> <span class="nc">BuiltinImporter</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Meta path import for built-in modules.</span>

<span class="sd">    All methods are either class or static methods to avoid the need to</span>
<span class="sd">    instantiate the class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return repr for the module.</span>

<span class="sd">        The method is deprecated.  The import machinery does the job itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;&lt;module {!r} (built-in)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_builtin</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s">&#39;built-in&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the built-in module.</span>

<span class="sd">        If &#39;path&#39; is ever specified then the search is considered a failure.</span>

<span class="sd">        This method is deprecated.  Use find_spec() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_builtin</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a built-in module.&quot;&quot;&quot;</span>
        <span class="c"># Once an exec_module() implementation is added we can also</span>
        <span class="c"># add a deprecation warning here.</span>
        <span class="k">with</span> <span class="n">_ManageReload</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="n">_imp</span><span class="o">.</span><span class="n">init_builtin</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
        <span class="n">module</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">return</span> <span class="n">module</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_builtin</span>
    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as built-in modules do not have code objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_builtin</span>
    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as built-in modules do not have source code.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_builtin</span>
    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return False as built-in modules are never packages.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="k">class</span> <span class="nc">FrozenImporter</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Meta path import for frozen modules.</span>

<span class="sd">    All methods are either class or static methods to avoid the need to</span>
<span class="sd">    instantiate the class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return repr for the module.</span>

<span class="sd">        The method is deprecated.  The import machinery does the job itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;&lt;module {!r} (frozen)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s">&#39;frozen&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a frozen module.</span>

<span class="sd">        This method is deprecated.  Use find_spec() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span> <span class="k">if</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;{!r} is not a frozen module&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="n">_imp</span><span class="o">.</span><span class="n">get_frozen_object</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">module</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a frozen module.</span>

<span class="sd">        This method is deprecated.  Use exec_module() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_load_module_shim</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_frozen</span>
    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the code object for the frozen module.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_imp</span><span class="o">.</span><span class="n">get_frozen_object</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_frozen</span>
    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as frozen modules do not have source code.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@_requires_frozen</span>
    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the frozen module is a package.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen_package</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WindowsRegistryFinder</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Meta path finder for modules declared in the Windows registry.&quot;&quot;&quot;</span>

    <span class="n">REGISTRY_KEY</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&#39;Software</span><span class="se">\\</span><span class="s">Python</span><span class="se">\\</span><span class="s">PythonCore</span><span class="se">\\</span><span class="s">{sys_version}&#39;</span>
        <span class="s">&#39;</span><span class="se">\\</span><span class="s">Modules</span><span class="se">\\</span><span class="s">{fullname}&#39;</span><span class="p">)</span>
    <span class="n">REGISTRY_KEY_DEBUG</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&#39;Software</span><span class="se">\\</span><span class="s">Python</span><span class="se">\\</span><span class="s">PythonCore</span><span class="se">\\</span><span class="s">{sys_version}&#39;</span>
        <span class="s">&#39;</span><span class="se">\\</span><span class="s">Modules</span><span class="se">\\</span><span class="s">{fullname}</span><span class="se">\\</span><span class="s">Debug&#39;</span><span class="p">)</span>
    <span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Changed in _setup()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_open_registry</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_winreg</span><span class="o">.</span><span class="n">OpenKey</span><span class="p">(</span><span class="n">_winreg</span><span class="o">.</span><span class="n">HKEY_CURRENT_USER</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_winreg</span><span class="o">.</span><span class="n">OpenKey</span><span class="p">(</span><span class="n">_winreg</span><span class="o">.</span><span class="n">HKEY_LOCAL_MACHINE</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_search_registry</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">DEBUG_BUILD</span><span class="p">:</span>
            <span class="n">registry_key</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">REGISTRY_KEY_DEBUG</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">registry_key</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">REGISTRY_KEY</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">registry_key</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="n">fullname</span><span class="p">,</span>
                                  <span class="n">sys_version</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">_open_registry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">as</span> <span class="n">hkey</span><span class="p">:</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">_winreg</span><span class="o">.</span><span class="n">QueryValue</span><span class="p">(</span><span class="n">hkey</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">filepath</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_search_registry</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_path_stat</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">loader</span><span class="p">,</span> <span class="n">suffixes</span> <span class="ow">in</span> <span class="n">_get_supported_file_loaders</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)):</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">filepath</span><span class="p">),</span>
                                        <span class="n">origin</span><span class="o">=</span><span class="n">filepath</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">spec</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find module named in the registry.</span>

<span class="sd">        This method is deprecated.  Use exec_module() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">_LoaderBasics</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Base class of common code needed by both SourceLoader and</span>
<span class="sd">    SourcelessFileLoader.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concrete implementation of InspectLoader.is_package by checking if</span>
<span class="sd">        the path returned by get_filename has a filename of &#39;__init__.py&#39;.&quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">filename_base</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tail_name</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">filename_base</span> <span class="o">==</span> <span class="s">&#39;__init__&#39;</span> <span class="ow">and</span> <span class="n">tail_name</span> <span class="o">!=</span> <span class="s">&#39;__init__&#39;</span>

    <span class="k">def</span> <span class="nf">exec_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the module.&quot;&quot;&quot;</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_code</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">code</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;cannot load module {!r} when get_code() &#39;</span>
                              <span class="s">&#39;returns None&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="k">exec</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">module</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="n">load_module</span> <span class="o">=</span> <span class="n">_load_module_shim</span>


<span class="k">class</span> <span class="nc">SourceLoader</span><span class="p">(</span><span class="n">_LoaderBasics</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">path_mtime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional method that returns the modification time (an int) for the</span>
<span class="sd">        specified path, where path is a str.</span>

<span class="sd">        Raises IOError when the path cannot be handled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">IOError</span>

    <span class="k">def</span> <span class="nf">path_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional method returning a metadata dict for the specified path</span>
<span class="sd">        to by the path (str).</span>
<span class="sd">        Possible keys:</span>
<span class="sd">        - &#39;mtime&#39; (mandatory) is the numeric timestamp of last source</span>
<span class="sd">          code modification;</span>
<span class="sd">        - &#39;size&#39; (optional) is the size in bytes of the source code.</span>

<span class="sd">        Implementing this method allows the loader to read bytecode files.</span>
<span class="sd">        Raises IOError when the path cannot be handled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;mtime&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_mtime</span><span class="p">(</span><span class="n">path</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_cache_bytecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">cache_path</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional method which writes data (bytes) to a file path (a str).</span>

<span class="sd">        Implementing this method allows for the writing of bytecode files.</span>

<span class="sd">        The source path is needed in order to correctly transfer permissions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># For backwards compatibility, we delegate to set_data()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">cache_path</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional method which writes data (bytes) to a file path (a str).</span>

<span class="sd">        Implementing this method allows for the writing of bytecode files.</span>
<span class="sd">        &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concrete implementation of InspectLoader.get_source.&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">source_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;source not available through get_data()&#39;</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
        <span class="k">return</span> <span class="n">decode_source</span><span class="p">(</span><span class="n">source_bytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">source_to_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_optimize</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the code object compiled from source.</span>

<span class="sd">        The &#39;data&#39; argument can be any object type that compile() supports.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="nb">compile</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="s">&#39;exec&#39;</span><span class="p">,</span>
                                        <span class="n">dont_inherit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">_optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concrete implementation of InspectLoader.get_code.</span>

<span class="sd">        Reading of bytecode requires path_stats to be implemented. To write</span>
<span class="sd">        bytecode, set_data must also be implemented.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">source_mtime</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bytecode_path</span> <span class="o">=</span> <span class="n">cache_from_source</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">bytecode_path</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_stats</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source_mtime</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="s">&#39;mtime&#39;</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">bytes_data</span> <span class="o">=</span> <span class="n">_validate_bytecode_header</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                <span class="n">source_stats</span><span class="o">=</span><span class="n">st</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">,</span>
                                <span class="n">path</span><span class="o">=</span><span class="n">bytecode_path</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;{} matches {}&#39;</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="p">,</span>
                                        <span class="n">source_path</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">_compile_bytecode</span><span class="p">(</span><span class="n">bytes_data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">,</span>
                                                 <span class="n">bytecode_path</span><span class="o">=</span><span class="n">bytecode_path</span><span class="p">,</span>
                                                 <span class="n">source_path</span><span class="o">=</span><span class="n">source_path</span><span class="p">)</span>
        <span class="n">source_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="n">code_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_to_code</span><span class="p">(</span><span class="n">source_bytes</span><span class="p">,</span> <span class="n">source_path</span><span class="p">)</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;code object from {}&#39;</span><span class="p">,</span> <span class="n">source_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">dont_write_bytecode</span> <span class="ow">and</span> <span class="n">bytecode_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                <span class="n">source_mtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_code_to_bytecode</span><span class="p">(</span><span class="n">code_object</span><span class="p">,</span> <span class="n">source_mtime</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">source_bytes</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_bytecode</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;wrote {!r}&#39;</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">code_object</span>


<span class="k">class</span> <span class="nc">FileLoader</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Base file loader class which implements the loader protocol methods that</span>
<span class="sd">    require file system usage.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache the module name and the path to the file found by the</span>
<span class="sd">        finder.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">fullname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="nd">@_check_name</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a module from a file.</span>

<span class="sd">        This method is deprecated.  Use exec_module() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The only reason for this method is for the name check.</span>
        <span class="c"># Issue #14857: Avoid the zero-argument form of super so the implementation</span>
        <span class="c"># of that form can be updated without breaking the frozen module</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FileLoader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

    <span class="nd">@_check_name</span>
    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the path to the source file as found by the finder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data from path as raw bytes.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">_io</span><span class="o">.</span><span class="n">FileIO</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">SourceFileLoader</span><span class="p">(</span><span class="n">FileLoader</span><span class="p">,</span> <span class="n">SourceLoader</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Concrete implementation of SourceLoader using the file system.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">path_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the metadata for the path.&quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">_path_stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;mtime&#39;</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">,</span> <span class="s">&#39;size&#39;</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">st_size</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_cache_bytecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># Adapt between the two APIs</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">_calc_mode</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">bytecode_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">_mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_mode</span><span class="o">=</span><span class="mi">0</span><span class="n">o666</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write bytes data to a file.&quot;&quot;&quot;</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">path_parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Figure out what directories are missing.</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_path_isdir</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="n">path_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="c"># Create needed directories.</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">path_parts</span><span class="p">):</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">_path_join</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">FileExistsError</span><span class="p">:</span>
                <span class="c"># Probably another Python process already created the dir.</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c"># Could be a permission error, read-only filesystem: just forget</span>
                <span class="c"># about writing the data.</span>
                <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;could not create {!r}: {!r}&#39;</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_write_atomic</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">_mode</span><span class="p">)</span>
            <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;created {!r}&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c"># Same as above: just don&#39;t write the bytecode.</span>
            <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;could not create {!r}: {!r}&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SourcelessFileLoader</span><span class="p">(</span><span class="n">FileLoader</span><span class="p">,</span> <span class="n">_LoaderBasics</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Loader which handles sourceless file imports.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">bytes_data</span> <span class="o">=</span> <span class="n">_validate_bytecode_header</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_compile_bytecode</span><span class="p">(</span><span class="n">bytes_data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">fullname</span><span class="p">,</span> <span class="n">bytecode_path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as there is no source code.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="c"># Filled in by _setup().</span>
<span class="n">EXTENSION_SUFFIXES</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">ExtensionFileLoader</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Loader for extension modules.</span>

<span class="sd">    The constructor is designed to work with FileFinder.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="nd">@_check_name</span>
    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load an extension module.&quot;&quot;&quot;</span>
        <span class="c"># Once an exec_module() implementation is added we can also</span>
        <span class="c"># add a deprecation warning here.</span>
        <span class="k">with</span> <span class="n">_ManageReload</span><span class="p">(</span><span class="n">fullname</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="n">_imp</span><span class="o">.</span><span class="n">load_dynamic</span><span class="p">,</span>
                                               <span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;extension module loaded from {!r}&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">is_package</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_package</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__path__&#39;</span><span class="p">):</span>
            <span class="n">module</span><span class="o">.</span><span class="n">__path__</span> <span class="o">=</span> <span class="p">[</span><span class="n">_path_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">module</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_package</span><span class="p">:</span>
            <span class="n">module</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__package__</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the extension module is a package.&quot;&quot;&quot;</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">_path_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">file_name</span> <span class="o">==</span> <span class="s">&#39;__init__&#39;</span> <span class="o">+</span> <span class="n">suffix</span>
                   <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">EXTENSION_SUFFIXES</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as an extension module cannot create a code object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None as extension modules have no source code.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@_check_name</span>
    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the path to the source file as found by the finder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>


<span class="k">class</span> <span class="nc">_NamespacePath</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a namespace package&#39;s path.  It uses the module name</span>
<span class="sd">    to find its parent module, and from there it looks up the parent&#39;s</span>
<span class="sd">    __path__.  When this changes, the module&#39;s own path is recomputed,</span>
<span class="sd">    using path_finder.  For top-level modules, the parent module&#39;s path</span>
<span class="sd">    is sys.path.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path_finder</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_parent_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_path</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path_finder</span> <span class="o">=</span> <span class="n">path_finder</span>

    <span class="k">def</span> <span class="nf">_find_parent_path_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of (parent-module-name, parent-path-attr-name)&quot;&quot;&quot;</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dot</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="c"># This is a top-level module. sys.path contains the parent path.</span>
            <span class="k">return</span> <span class="s">&#39;sys&#39;</span><span class="p">,</span> <span class="s">&#39;path&#39;</span>
        <span class="c"># Not a top-level module. parent-module.__path__ contains the</span>
        <span class="c">#  parent path.</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">,</span> <span class="s">&#39;__path__&#39;</span>

    <span class="k">def</span> <span class="nf">_get_parent_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parent_module_name</span><span class="p">,</span> <span class="n">path_attr_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_parent_path_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">parent_module_name</span><span class="p">],</span> <span class="n">path_attr_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_recalculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># If the parent&#39;s path has changed, recalculate _path</span>
        <span class="n">parent_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_path</span><span class="p">())</span> <span class="c"># Make a copy</span>
        <span class="k">if</span> <span class="n">parent_path</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_parent_path</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_finder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">parent_path</span><span class="p">)</span>
            <span class="c"># Note that no changes are made if a loader is returned, but we</span>
            <span class="c">#  do remember the new parent path</span>
            <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_parent_path</span> <span class="o">=</span> <span class="n">parent_path</span>     <span class="c"># Save the copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculate</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculate</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;_NamespacePath({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalculate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>


<span class="c"># We use this exclusively in init_module_attrs() for backward-compatibility.</span>
<span class="k">class</span> <span class="nc">_NamespaceLoader</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path_finder</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">_NamespacePath</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path_finder</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return repr for the module.</span>

<span class="sd">        The method is deprecated.  The import machinery does the job itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;&lt;module {!r} (namespace)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">get_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">compile</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;exec&#39;</span><span class="p">,</span> <span class="n">dont_inherit</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exec_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a namespace module.</span>

<span class="sd">        This method is deprecated.  Use exec_module() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The import system never calls this method.</span>
        <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;namespace module loaded with path {!r}&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_load_module_shim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>


<span class="c"># Finders #####################################################################</span>

<span class="k">class</span> <span class="nc">PathFinder</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Meta path finder for sys.path and package __path__ attributes.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">invalidate_caches</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call the invalidate_caches() method on all path entry finders</span>
<span class="sd">        stored in sys.path_importer_caches (where implemented).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">finder</span><span class="p">,</span> <span class="s">&#39;invalidate_caches&#39;</span><span class="p">):</span>
                <span class="n">finder</span><span class="o">.</span><span class="n">invalidate_caches</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_path_hooks</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search sequence of hooks for a finder for &#39;path&#39;.</span>

<span class="sd">        If &#39;hooks&#39; is false then use sys.path_hooks.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">:</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;sys.path_hooks is empty&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hook</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hook</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_path_importer_cache</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the finder for the path entry from sys.path_importer_cache.</span>

<span class="sd">        If the path entry is not in the cache, find the appropriate finder</span>
<span class="sd">        and cache it. If no finder is available, store None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_path_hooks</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">path_importer_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">finder</span>
        <span class="k">return</span> <span class="n">finder</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_legacy_get_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">finder</span><span class="p">):</span>
        <span class="c"># This would be a good place for a DeprecationWarning if</span>
        <span class="c"># we ended up going that route.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">finder</span><span class="p">,</span> <span class="s">&#39;find_loader&#39;</span><span class="p">):</span>
            <span class="n">loader</span><span class="p">,</span> <span class="n">portions</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
            <span class="n">portions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="n">portions</span>
        <span class="k">return</span> <span class="n">spec</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the loader or namespace_path for this module/package name.&quot;&quot;&quot;</span>
        <span class="c"># If this ends up being a namespace package, namespace_path is</span>
        <span class="c">#  the list of paths that will become its __path__</span>
        <span class="n">namespace_path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_path_importer_cache</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">finder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">finder</span><span class="p">,</span> <span class="s">&#39;find_spec&#39;</span><span class="p">):</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_legacy_get_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">finder</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">spec</span>
                <span class="n">portions</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span>
                <span class="k">if</span> <span class="n">portions</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;spec missing loader&#39;</span><span class="p">)</span>
                <span class="c"># This is possibly part of a namespace package.</span>
                <span class="c">#  Remember these path entries (if any) for when we</span>
                <span class="c">#  create a namespace package, and continue iterating</span>
                <span class="c">#  on path.</span>
                <span class="n">namespace_path</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">portions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="n">namespace_path</span>
            <span class="k">return</span> <span class="n">spec</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;find the module on sys.path or &#39;path&#39; based on sys.path_hooks and</span>
<span class="sd">        sys.path_importer_cache.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">namespace_path</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span>
            <span class="k">if</span> <span class="n">namespace_path</span><span class="p">:</span>
                <span class="c"># We found at least one namespace path.  Return a</span>
                <span class="c">#  spec which can create the namespace package.</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="s">&#39;namespace&#39;</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="n">_NamespacePath</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">namespace_path</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_spec</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">spec</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;find the module on sys.path or &#39;path&#39; based on sys.path_hooks and</span>
<span class="sd">        sys.path_importer_cache.</span>

<span class="sd">        This method is deprecated.  Use find_spec() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span>


<span class="k">class</span> <span class="nc">FileFinder</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;File-based finder.</span>

<span class="sd">    Interactions with the file system are cached for performance, being</span>
<span class="sd">    refreshed when the directory the finder is handling has been modified.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">loader_details</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize with the path to search on and a variable number of</span>
<span class="sd">        2-tuples containing the loader and the file suffixes the loader</span>
<span class="sd">        recognizes.&quot;&quot;&quot;</span>
        <span class="n">loaders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loader</span><span class="p">,</span> <span class="n">suffixes</span> <span class="ow">in</span> <span class="n">loader_details</span><span class="p">:</span>
            <span class="n">loaders</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">suffix</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span> <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span> <span class="o">=</span> <span class="n">loaders</span>
        <span class="c"># Base (directory) path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="ow">or</span> <span class="s">&#39;.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path_mtime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relaxed_path_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">invalidate_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invalidate the directory mtime.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path_mtime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">find_module</span> <span class="o">=</span> <span class="n">_find_module_shim</span>

    <span class="k">def</span> <span class="nf">find_loader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to find a loader for the specified module, or the namespace</span>
<span class="sd">        package portions. Returns (loader, list-of-portions).</span>

<span class="sd">        This method is deprecated.  Use find_spec() instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_get_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader_class</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">smsl</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">loader_class</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="n">loader</span><span class="p">,</span>
                                       <span class="n">submodule_search_locations</span><span class="o">=</span><span class="n">smsl</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to find a loader for the specified module, or the namespace</span>
<span class="sd">        package portions. Returns (loader, list-of-portions).&quot;&quot;&quot;</span>
        <span class="n">is_namespace</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">tail_module</span> <span class="o">=</span> <span class="n">fullname</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mtime</span> <span class="o">=</span> <span class="n">_path_stat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">or</span> <span class="n">_os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span><span class="o">.</span><span class="n">st_mtime</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">mtime</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mtime</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_mtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path_mtime</span> <span class="o">=</span> <span class="n">mtime</span>
        <span class="c"># tail_module keeps the original casing, for __file__ and friends</span>
        <span class="k">if</span> <span class="n">_relax_case</span><span class="p">():</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relaxed_path_cache</span>
            <span class="n">cache_module</span> <span class="o">=</span> <span class="n">tail_module</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_cache</span>
            <span class="n">cache_module</span> <span class="o">=</span> <span class="n">tail_module</span>
        <span class="c"># Check if the module is the name of a directory (and thus a package).</span>
        <span class="k">if</span> <span class="n">cache_module</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="n">base_path</span> <span class="o">=</span> <span class="n">_path_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">tail_module</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">loader_class</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span><span class="p">:</span>
                <span class="n">init_filename</span> <span class="o">=</span> <span class="s">&#39;__init__&#39;</span> <span class="o">+</span> <span class="n">suffix</span>
                <span class="n">full_path</span> <span class="o">=</span> <span class="n">_path_join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="n">init_filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_path_isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spec</span><span class="p">(</span><span class="n">loader_class</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="p">[</span><span class="n">base_path</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If a namespace package, return the path if we don&#39;t</span>
                <span class="c">#  find a module in the next section.</span>
                <span class="n">is_namespace</span> <span class="o">=</span> <span class="n">_path_isdir</span><span class="p">(</span><span class="n">base_path</span><span class="p">)</span>
        <span class="c"># Check for a file w/ a proper suffix exists.</span>
        <span class="k">for</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">loader_class</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span><span class="p">:</span>
            <span class="n">full_path</span> <span class="o">=</span> <span class="n">_path_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">tail_module</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">)</span>
            <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;trying {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">full_path</span><span class="p">),</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cache_module</span> <span class="o">+</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_path_isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spec</span><span class="p">(</span><span class="n">loader_class</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_namespace</span><span class="p">:</span>
            <span class="n">_verbose_message</span><span class="p">(</span><span class="s">&#39;possible namespace for {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base_path</span><span class="p">))</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">ModuleSpec</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_path</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">spec</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill the cache of potential modules and packages for this directory.&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">contents</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span> <span class="ow">or</span> <span class="n">_os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">FileNotFoundError</span><span class="p">,</span> <span class="n">PermissionError</span><span class="p">,</span> <span class="n">NotADirectoryError</span><span class="p">):</span>
            <span class="c"># Directory has either been removed, turned into a file, or made</span>
            <span class="c"># unreadable.</span>
            <span class="n">contents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># We store two cached versions, to handle runtime changes of the</span>
        <span class="c"># PYTHONCASEOK environment variable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;win&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Windows users can import modules with case-insensitive file</span>
            <span class="c"># suffixes (for legacy reasons). Make the suffix lowercase here</span>
            <span class="c"># so it&#39;s done once instead of for every import. This is safe as</span>
            <span class="c"># the specified suffixes to check against are always specified in a</span>
            <span class="c"># case-sensitive manner.</span>
            <span class="n">lower_suffix_contents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dot</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="s">&#39;{}.{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="n">lower_suffix_contents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path_cache</span> <span class="o">=</span> <span class="n">lower_suffix_contents</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_CASE_INSENSITIVE_PLATFORMS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxed_path_cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">fn</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">path_hook</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">loader_details</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A class method which returns a closure to use on sys.path_hook</span>
<span class="sd">        which will return an instance using the specified loaders and the path</span>
<span class="sd">        called on the closure.</span>

<span class="sd">        If the path called on the closure is not a directory, ImportError is</span>
<span class="sd">        raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">path_hook_for_FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Path hook for importlib.machinery.FileFinder.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_path_isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;only directories are supported&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">loader_details</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">path_hook_for_FileFinder</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;FileFinder({!r})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


<span class="c"># Import itself ###############################################################</span>

<span class="k">class</span> <span class="nc">_ImportLockContext</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Context manager for the import lock.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire the import lock.&quot;&quot;&quot;</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">acquire_lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release the import lock regardless of any raised exceptions.&quot;&quot;&quot;</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">release_lock</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resolve a relative module name to an absolute one.&quot;&quot;&quot;</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">package</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;attempted relative import beyond top-level package&#39;</span><span class="p">)</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="s">&#39;{}.{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="n">base</span>


<span class="k">def</span> <span class="nf">_find_spec_legacy</span><span class="p">(</span><span class="n">finder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="c"># This would be a good place for a DeprecationWarning if</span>
    <span class="c"># we ended up going that route.</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">spec_from_loader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find a module&#39;s loader.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;sys.meta_path is empty&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
    <span class="c"># We check sys.modules here for the reload case.  While a passed-in</span>
    <span class="c"># target will usually indicate a reload there is no guarantee, whereas</span>
    <span class="c"># sys.modules provides one.</span>
    <span class="n">is_reload</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">_ImportLockContext</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">find_spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">_find_spec_legacy</span><span class="p">(</span><span class="n">finder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># The parent import may have already imported this module.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_reload</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">__spec__</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">__spec__</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c"># We use the found spec since that is the one that</span>
                    <span class="c"># we would have used if the parent module hadn&#39;t</span>
                    <span class="c"># beaten us to the punch.</span>
                    <span class="k">return</span> <span class="n">spec</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__spec__</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">spec</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">__spec__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">spec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_sanity_check</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verify arguments are &quot;sane&quot;.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;module name must be str, not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;level must be &gt;= 0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">package</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;__package__ not set to a string&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">package</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Parent module {!r} not loaded, cannot perform relative &#39;</span>
                   <span class="s">&#39;import&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SystemError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">package</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Empty module name&#39;</span><span class="p">)</span>


<span class="n">_ERR_MSG_PREFIX</span> <span class="o">=</span> <span class="s">&#39;No module named &#39;</span>
<span class="n">_ERR_MSG</span> <span class="o">=</span> <span class="n">_ERR_MSG_PREFIX</span> <span class="o">+</span> <span class="s">&#39;{!r}&#39;</span>

<span class="k">def</span> <span class="nf">_find_and_load_unlocked</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">import_</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="n">import_</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="c"># Crazy side-effects!</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__path__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ERR_MSG</span> <span class="o">+</span> <span class="s">&#39;; {!r} is not a package&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">_find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">_ERR_MSG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">_SpecMethods</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">_load_unlocked</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
        <span class="c"># Set the module as an attribute on its parent.</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>


<span class="k">def</span> <span class="nf">_find_and_load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">import_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find and load the module, and release the import lock.&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_ModuleLockManager</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_and_load_unlocked</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">import_</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_gcd_import</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import and return the module based on its name, the package the call is</span>
<span class="sd">    being made from, and the level adjustment.</span>

<span class="sd">    This function represents the greatest common denominator of functionality</span>
<span class="sd">    between import_module and __import__. This includes setting __package__ if</span>
<span class="sd">    the loader did not.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_sanity_check</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
    <span class="n">_imp</span><span class="o">.</span><span class="n">acquire_lock</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_find_and_load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_gcd_import</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_imp</span><span class="o">.</span><span class="n">release_lock</span><span class="p">()</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;import of {} halted; &#39;</span>
                   <span class="s">&#39;None in sys.modules&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">_lock_unlock_module</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>

<span class="k">def</span> <span class="nf">_handle_fromlist</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">,</span> <span class="n">import_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Figure out what __import__ should return.</span>

<span class="sd">    The import_ parameter is a callable which takes the name of module to</span>
<span class="sd">    import. It is required to decouple the function from assuming importlib&#39;s</span>
<span class="sd">    import implementation is desired.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The hell that is fromlist ...</span>
    <span class="c"># If a package was imported, try to import stuff from fromlist.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__path__&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">fromlist</span><span class="p">:</span>
            <span class="n">fromlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fromlist</span><span class="p">)</span>
            <span class="n">fromlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">&#39;__all__&#39;</span><span class="p">):</span>
                <span class="n">fromlist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__all__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fromlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">from_name</span> <span class="o">=</span> <span class="s">&#39;{}.{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_call_with_frames_removed</span><span class="p">(</span><span class="n">import_</span><span class="p">,</span> <span class="n">from_name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="c"># Backwards-compatibility dictates we ignore failed</span>
                    <span class="c"># imports triggered by fromlist for modules that don&#39;t</span>
                    <span class="c"># exist.</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_ERR_MSG_PREFIX</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">from_name</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="k">raise</span>
    <span class="k">return</span> <span class="n">module</span>


<span class="k">def</span> <span class="nf">_calc___package__</span><span class="p">(</span><span class="nb">globals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate what __package__ should be.</span>

<span class="sd">    __package__ is not guaranteed to be defined or could be set to None</span>
<span class="sd">    to represent that its proper value is unknown.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">package</span> <span class="o">=</span> <span class="nb">globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;__package__&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">package</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">package</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">[</span><span class="s">&#39;__name__&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;__path__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">:</span>
            <span class="n">package</span> <span class="o">=</span> <span class="n">package</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">package</span>


<span class="k">def</span> <span class="nf">_get_supported_file_loaders</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of file-based module loaders.</span>

<span class="sd">    Each item is a tuple (loader, suffixes).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extensions</span> <span class="o">=</span> <span class="n">ExtensionFileLoader</span><span class="p">,</span> <span class="n">_imp</span><span class="o">.</span><span class="n">extension_suffixes</span><span class="p">()</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">SourceFileLoader</span><span class="p">,</span> <span class="n">SOURCE_SUFFIXES</span>
    <span class="n">bytecode</span> <span class="o">=</span> <span class="n">SourcelessFileLoader</span><span class="p">,</span> <span class="n">BYTECODE_SUFFIXES</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">extensions</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">bytecode</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="p">(),</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import a module.</span>

<span class="sd">    The &#39;globals&#39; argument is used to infer where the import is occuring from</span>
<span class="sd">    to handle relative imports. The &#39;locals&#39; argument is ignored. The</span>
<span class="sd">    &#39;fromlist&#39; argument specifies what should exist as attributes on the module</span>
<span class="sd">    being imported (e.g. ``from module import &lt;fromlist&gt;``).  The &#39;level&#39;</span>
<span class="sd">    argument represents the package location to import from in a relative</span>
<span class="sd">    import (e.g. ``from ..pkg import mod`` would have a &#39;level&#39; of 2).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">_gcd_import</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">globals_</span> <span class="o">=</span> <span class="nb">globals</span> <span class="k">if</span> <span class="nb">globals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">package</span> <span class="o">=</span> <span class="n">_calc___package__</span><span class="p">(</span><span class="n">globals_</span><span class="p">)</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">_gcd_import</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fromlist</span><span class="p">:</span>
        <span class="c"># Return up to the first dot in &#39;name&#39;. This is complicated by the fact</span>
        <span class="c"># that &#39;name&#39; may be relative.</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_gcd_import</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">module</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Figure out where to slice the module&#39;s name up to the first dot</span>
            <span class="c"># in &#39;name&#39;.</span>
            <span class="n">cut_off</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c"># Slice end needs to be positive to alleviate need to special-case</span>
            <span class="c"># when ``&#39;.&#39; not in name``.</span>
            <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span><span class="o">-</span><span class="n">cut_off</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_handle_fromlist</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">,</span> <span class="n">_gcd_import</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_builtin_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">BuiltinImporter</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;no built-in module named &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="n">_SpecMethods</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">methods</span><span class="o">.</span><span class="n">_load_unlocked</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="n">sys_module</span><span class="p">,</span> <span class="n">_imp_module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Setup importlib by importing needed built-in modules and injecting them</span>
<span class="sd">    into the global namespace.</span>

<span class="sd">    As sys is needed for sys.modules access and _imp is needed to load built-in</span>
<span class="sd">    modules, those two modules must be explicitly passed in.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_imp</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">BYTECODE_SUFFIXES</span>
    <span class="n">_imp</span> <span class="o">=</span> <span class="n">_imp_module</span>
    <span class="n">sys</span> <span class="o">=</span> <span class="n">sys_module</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">optimize</span><span class="p">:</span>
        <span class="n">BYTECODE_SUFFIXES</span> <span class="o">=</span> <span class="n">OPTIMIZED_BYTECODE_SUFFIXES</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BYTECODE_SUFFIXES</span> <span class="o">=</span> <span class="n">DEBUG_BYTECODE_SUFFIXES</span>

    <span class="c"># Set up the spec for existing builtin/frozen modules.</span>
    <span class="n">module_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">:</span>
                <span class="n">loader</span> <span class="o">=</span> <span class="n">BuiltinImporter</span>
            <span class="k">elif</span> <span class="n">_imp</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">loader</span> <span class="o">=</span> <span class="n">FrozenImporter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">_spec_from_module</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">loader</span><span class="p">)</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="n">_SpecMethods</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">methods</span><span class="o">.</span><span class="n">init_module_attrs</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="c"># Directly load built-in modules needed during bootstrap.</span>
    <span class="n">self_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">builtin_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;_io&#39;</span><span class="p">,</span> <span class="s">&#39;_warnings&#39;</span><span class="p">,</span> <span class="s">&#39;builtins&#39;</span><span class="p">,</span> <span class="s">&#39;marshal&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">builtin_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">builtin_module</span> <span class="o">=</span> <span class="n">_builtin_from_name</span><span class="p">(</span><span class="n">builtin_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">builtin_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">builtin_name</span><span class="p">]</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="n">builtin_name</span><span class="p">,</span> <span class="n">builtin_module</span><span class="p">)</span>

    <span class="c"># Directly load the os module (needed during bootstrap).</span>
    <span class="n">os_details</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;posix&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;/&#39;</span><span class="p">]),</span> <span class="p">(</span><span class="s">&#39;nt&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">builtin_os</span><span class="p">,</span> <span class="n">path_separators</span> <span class="ow">in</span> <span class="n">os_details</span><span class="p">:</span>
        <span class="c"># Assumption made in _path_join()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">sep</span> <span class="ow">in</span> <span class="n">path_separators</span><span class="p">)</span>
        <span class="n">path_sep</span> <span class="o">=</span> <span class="n">path_separators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">builtin_os</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">os_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">builtin_os</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os_module</span> <span class="o">=</span> <span class="n">_builtin_from_name</span><span class="p">(</span><span class="n">builtin_os</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;importlib requires posix or nt&#39;</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;_os&#39;</span><span class="p">,</span> <span class="n">os_module</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;path_sep&#39;</span><span class="p">,</span> <span class="n">path_sep</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;path_separators&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_separators</span><span class="p">))</span>

    <span class="c"># Directly load the _thread module (needed during bootstrap).</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">thread_module</span> <span class="o">=</span> <span class="n">_builtin_from_name</span><span class="p">(</span><span class="s">&#39;_thread&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c"># Python was built without threads</span>
        <span class="n">thread_module</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;_thread&#39;</span><span class="p">,</span> <span class="n">thread_module</span><span class="p">)</span>

    <span class="c"># Directly load the _weakref module (needed during bootstrap).</span>
    <span class="n">weakref_module</span> <span class="o">=</span> <span class="n">_builtin_from_name</span><span class="p">(</span><span class="s">&#39;_weakref&#39;</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;_weakref&#39;</span><span class="p">,</span> <span class="n">weakref_module</span><span class="p">)</span>

    <span class="c"># Directly load the winreg module (needed during bootstrap).</span>
    <span class="k">if</span> <span class="n">builtin_os</span> <span class="o">==</span> <span class="s">&#39;nt&#39;</span><span class="p">:</span>
        <span class="n">winreg_module</span> <span class="o">=</span> <span class="n">_builtin_from_name</span><span class="p">(</span><span class="s">&#39;winreg&#39;</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;_winreg&#39;</span><span class="p">,</span> <span class="n">winreg_module</span><span class="p">)</span>

    <span class="c"># Constants</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">self_module</span><span class="p">,</span> <span class="s">&#39;_relax_case&#39;</span><span class="p">,</span> <span class="n">_make_relax_case</span><span class="p">())</span>
    <span class="n">EXTENSION_SUFFIXES</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_imp</span><span class="o">.</span><span class="n">extension_suffixes</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">builtin_os</span> <span class="o">==</span> <span class="s">&#39;nt&#39;</span><span class="p">:</span>
        <span class="n">SOURCE_SUFFIXES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;.pyw&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;_d.pyd&#39;</span> <span class="ow">in</span> <span class="n">EXTENSION_SUFFIXES</span><span class="p">:</span>
            <span class="n">WindowsRegistryFinder</span><span class="o">.</span><span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">_install</span><span class="p">(</span><span class="n">sys_module</span><span class="p">,</span> <span class="n">_imp_module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Install importlib as the implementation of import.&quot;&quot;&quot;</span>
    <span class="n">_setup</span><span class="p">(</span><span class="n">sys_module</span><span class="p">,</span> <span class="n">_imp_module</span><span class="p">)</span>
    <span class="n">supported_loaders</span> <span class="o">=</span> <span class="n">_get_supported_file_loaders</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">FileFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="o">*</span><span class="n">supported_loaders</span><span class="p">)])</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BuiltinImporter</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FrozenImporter</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;nt&#39;</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WindowsRegistryFinder</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PathFinder</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Weldon Henson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.0.',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>