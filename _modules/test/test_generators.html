

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>test.test_generators &mdash; ArcherBashPYDocs 1.0.0. documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ArcherBashPYDocs 1.0.0. documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> ArcherBashPYDocs</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">ArcherBashPYDocs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>test.test_generators</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for test.test_generators</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">test</span> <span class="kn">import</span> <span class="n">support</span>


<div class="viewcode-block" id="FinalizationTest"><a class="viewcode-back" href="../../test.html#test.test_generators.FinalizationTest">[docs]</a><span class="k">class</span> <span class="nc">FinalizationTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

<div class="viewcode-block" id="FinalizationTest.test_frame_resurrect"><a class="viewcode-back" href="../../test.html#test.test_generators.FinalizationTest.test_frame_resurrect">[docs]</a>    <span class="k">def</span> <span class="nf">test_frame_resurrect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># A generator frame can be resurrected by a generator&#39;s finalization.</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
            <span class="n">nonlocal</span> <span class="n">frame</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">gen</span><span class="p">()</span>
        <span class="n">wr</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">g</span>
        <span class="n">support</span><span class="o">.</span><span class="n">gc_collect</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">wr</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">frame</span>
        <span class="n">support</span><span class="o">.</span><span class="n">gc_collect</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="FinalizationTest.test_refcycle"><a class="viewcode-back" href="../../test.html#test.test_generators.FinalizationTest.test_refcycle">[docs]</a>    <span class="k">def</span> <span class="nf">test_refcycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># A generator caught in a refcycle gets finalized anyway.</span>
        <span class="n">old_garbage</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">garbage</span><span class="p">[:]</span>
        <span class="n">finalized</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
            <span class="n">nonlocal</span> <span class="n">finalized</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="k">yield</span>
                <span class="k">yield</span> <span class="mi">1</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">finalized</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">gen</span><span class="p">()</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertGreater</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">finalized</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">g</span>
        <span class="n">support</span><span class="o">.</span><span class="n">gc_collect</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">finalized</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">garbage</span><span class="p">,</span> <span class="n">old_garbage</span><span class="p">)</span>

</div></div>
<span class="n">tutorial_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Let&#39;s try a simple generator:</span>

<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...    yield 1</span>
<span class="s">    ...    yield 2</span>

<span class="s">    &gt;&gt;&gt; for i in f():</span>
<span class="s">    ...     print(i)</span>
<span class="s">    1</span>
<span class="s">    2</span>
<span class="s">    &gt;&gt;&gt; g = f()</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    1</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    2</span>

<span class="s">&quot;Falling off the end&quot; stops the generator:</span>

<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 2, in g</span>
<span class="s">    StopIteration</span>

<span class="s">&quot;return&quot; also stops the generator:</span>

<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...     yield 1</span>
<span class="s">    ...     return</span>
<span class="s">    ...     yield 2 # never reached</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; g = f()</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    1</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 3, in f</span>
<span class="s">    StopIteration</span>
<span class="s">    &gt;&gt;&gt; next(g) # once stopped, can&#39;t be resumed</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">    StopIteration</span>

<span class="s">&quot;raise StopIteration&quot; stops the generator too:</span>

<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...     yield 1</span>
<span class="s">    ...     raise StopIteration</span>
<span class="s">    ...     yield 2 # never reached</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; g = f()</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    1</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">    StopIteration</span>
<span class="s">    &gt;&gt;&gt; next(g)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">    StopIteration</span>

<span class="s">However, they are not exactly equivalent:</span>

<span class="s">    &gt;&gt;&gt; def g1():</span>
<span class="s">    ...     try:</span>
<span class="s">    ...         return</span>
<span class="s">    ...     except:</span>
<span class="s">    ...         yield 1</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; list(g1())</span>
<span class="s">    []</span>

<span class="s">    &gt;&gt;&gt; def g2():</span>
<span class="s">    ...     try:</span>
<span class="s">    ...         raise StopIteration</span>
<span class="s">    ...     except:</span>
<span class="s">    ...         yield 42</span>
<span class="s">    &gt;&gt;&gt; print(list(g2()))</span>
<span class="s">    [42]</span>

<span class="s">This may be surprising at first:</span>

<span class="s">    &gt;&gt;&gt; def g3():</span>
<span class="s">    ...     try:</span>
<span class="s">    ...         return</span>
<span class="s">    ...     finally:</span>
<span class="s">    ...         yield 1</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; list(g3())</span>
<span class="s">    [1]</span>

<span class="s">Let&#39;s create an alternate range() function implemented as a generator:</span>

<span class="s">    &gt;&gt;&gt; def yrange(n):</span>
<span class="s">    ...     for i in range(n):</span>
<span class="s">    ...         yield i</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; list(yrange(5))</span>
<span class="s">    [0, 1, 2, 3, 4]</span>

<span class="s">Generators always return to the most recent caller:</span>

<span class="s">    &gt;&gt;&gt; def creator():</span>
<span class="s">    ...     r = yrange(5)</span>
<span class="s">    ...     print(&quot;creator&quot;, next(r))</span>
<span class="s">    ...     return r</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; def caller():</span>
<span class="s">    ...     r = creator()</span>
<span class="s">    ...     for i in r:</span>
<span class="s">    ...             print(&quot;caller&quot;, i)</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; caller()</span>
<span class="s">    creator 0</span>
<span class="s">    caller 1</span>
<span class="s">    caller 2</span>
<span class="s">    caller 3</span>
<span class="s">    caller 4</span>

<span class="s">Generators can call other generators:</span>

<span class="s">    &gt;&gt;&gt; def zrange(n):</span>
<span class="s">    ...     for i in yrange(n):</span>
<span class="s">    ...         yield i</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; list(zrange(5))</span>
<span class="s">    [0, 1, 2, 3, 4]</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="c"># The examples from PEP 255.</span>

<span class="n">pep_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">Specification:  Yield</span>

<span class="s">    Restriction:  A generator cannot be resumed while it is actively</span>
<span class="s">    running:</span>

<span class="s">    &gt;&gt;&gt; def g():</span>
<span class="s">    ...     i = next(me)</span>
<span class="s">    ...     yield i</span>
<span class="s">    &gt;&gt;&gt; me = g()</span>
<span class="s">    &gt;&gt;&gt; next(me)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">     ...</span>
<span class="s">      File &quot;&lt;string&gt;&quot;, line 2, in g</span>
<span class="s">    ValueError: generator already executing</span>

<span class="s">Specification: Return</span>

<span class="s">    Note that return isn&#39;t always equivalent to raising StopIteration:  the</span>
<span class="s">    difference lies in how enclosing try/except constructs are treated.</span>
<span class="s">    For example,</span>

<span class="s">        &gt;&gt;&gt; def f1():</span>
<span class="s">        ...     try:</span>
<span class="s">        ...         return</span>
<span class="s">        ...     except:</span>
<span class="s">        ...        yield 1</span>
<span class="s">        &gt;&gt;&gt; print(list(f1()))</span>
<span class="s">        []</span>

<span class="s">    because, as in any function, return simply exits, but</span>

<span class="s">        &gt;&gt;&gt; def f2():</span>
<span class="s">        ...     try:</span>
<span class="s">        ...         raise StopIteration</span>
<span class="s">        ...     except:</span>
<span class="s">        ...         yield 42</span>
<span class="s">        &gt;&gt;&gt; print(list(f2()))</span>
<span class="s">        [42]</span>

<span class="s">    because StopIteration is captured by a bare &quot;except&quot;, as is any</span>
<span class="s">    exception.</span>

<span class="s">Specification: Generators and Exception Propagation</span>

<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...     return 1//0</span>
<span class="s">    &gt;&gt;&gt; def g():</span>
<span class="s">    ...     yield f()  # the zero division exception propagates</span>
<span class="s">    ...     yield 42   # and we&#39;ll never get here</span>
<span class="s">    &gt;&gt;&gt; k = g()</span>
<span class="s">    &gt;&gt;&gt; next(k)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 2, in g</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 2, in f</span>
<span class="s">    ZeroDivisionError: integer division or modulo by zero</span>
<span class="s">    &gt;&gt;&gt; next(k)  # and the generator cannot be resumed</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="s">    StopIteration</span>
<span class="s">    &gt;&gt;&gt;</span>

<span class="s">Specification: Try/Except/Finally</span>

<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...     try:</span>
<span class="s">    ...         yield 1</span>
<span class="s">    ...         try:</span>
<span class="s">    ...             yield 2</span>
<span class="s">    ...             1//0</span>
<span class="s">    ...             yield 3  # never get here</span>
<span class="s">    ...         except ZeroDivisionError:</span>
<span class="s">    ...             yield 4</span>
<span class="s">    ...             yield 5</span>
<span class="s">    ...             raise</span>
<span class="s">    ...         except:</span>
<span class="s">    ...             yield 6</span>
<span class="s">    ...         yield 7     # the &quot;raise&quot; above stops this</span>
<span class="s">    ...     except:</span>
<span class="s">    ...         yield 8</span>
<span class="s">    ...     yield 9</span>
<span class="s">    ...     try:</span>
<span class="s">    ...         x = 12</span>
<span class="s">    ...     finally:</span>
<span class="s">    ...         yield 10</span>
<span class="s">    ...     yield 11</span>
<span class="s">    &gt;&gt;&gt; print(list(f()))</span>
<span class="s">    [1, 2, 4, 5, 8, 9, 10, 11]</span>
<span class="s">    &gt;&gt;&gt;</span>

<span class="s">Guido&#39;s binary tree example.</span>

<span class="s">    &gt;&gt;&gt; # A binary tree class.</span>
<span class="s">    &gt;&gt;&gt; class Tree:</span>
<span class="s">    ...</span>
<span class="s">    ...     def __init__(self, label, left=None, right=None):</span>
<span class="s">    ...         self.label = label</span>
<span class="s">    ...         self.left = left</span>
<span class="s">    ...         self.right = right</span>
<span class="s">    ...</span>
<span class="s">    ...     def __repr__(self, level=0, indent=&quot;    &quot;):</span>
<span class="s">    ...         s = level*indent + repr(self.label)</span>
<span class="s">    ...         if self.left:</span>
<span class="s">    ...             s = s + &quot;</span><span class="se">\\</span><span class="s">n&quot; + self.left.__repr__(level+1, indent)</span>
<span class="s">    ...         if self.right:</span>
<span class="s">    ...             s = s + &quot;</span><span class="se">\\</span><span class="s">n&quot; + self.right.__repr__(level+1, indent)</span>
<span class="s">    ...         return s</span>
<span class="s">    ...</span>
<span class="s">    ...     def __iter__(self):</span>
<span class="s">    ...         return inorder(self)</span>

<span class="s">    &gt;&gt;&gt; # Create a Tree from a list.</span>
<span class="s">    &gt;&gt;&gt; def tree(list):</span>
<span class="s">    ...     n = len(list)</span>
<span class="s">    ...     if n == 0:</span>
<span class="s">    ...         return []</span>
<span class="s">    ...     i = n // 2</span>
<span class="s">    ...     return Tree(list[i], tree(list[:i]), tree(list[i+1:]))</span>

<span class="s">    &gt;&gt;&gt; # Show it off: create a tree.</span>
<span class="s">    &gt;&gt;&gt; t = tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)</span>

<span class="s">    &gt;&gt;&gt; # A recursive generator that generates Tree labels in in-order.</span>
<span class="s">    &gt;&gt;&gt; def inorder(t):</span>
<span class="s">    ...     if t:</span>
<span class="s">    ...         for x in inorder(t.left):</span>
<span class="s">    ...             yield x</span>
<span class="s">    ...         yield t.label</span>
<span class="s">    ...         for x in inorder(t.right):</span>
<span class="s">    ...             yield x</span>

<span class="s">    &gt;&gt;&gt; # Show it off: create a tree.</span>
<span class="s">    &gt;&gt;&gt; t = tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)</span>
<span class="s">    &gt;&gt;&gt; # Print the nodes of the tree in in-order.</span>
<span class="s">    &gt;&gt;&gt; for x in t:</span>
<span class="s">    ...     print(&#39; &#39;+x, end=&#39;&#39;)</span>
<span class="s">     A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span>

<span class="s">    &gt;&gt;&gt; # A non-recursive generator.</span>
<span class="s">    &gt;&gt;&gt; def inorder(node):</span>
<span class="s">    ...     stack = []</span>
<span class="s">    ...     while node:</span>
<span class="s">    ...         while node.left:</span>
<span class="s">    ...             stack.append(node)</span>
<span class="s">    ...             node = node.left</span>
<span class="s">    ...         yield node.label</span>
<span class="s">    ...         while not node.right:</span>
<span class="s">    ...             try:</span>
<span class="s">    ...                 node = stack.pop()</span>
<span class="s">    ...             except IndexError:</span>
<span class="s">    ...                 return</span>
<span class="s">    ...             yield node.label</span>
<span class="s">    ...         node = node.right</span>

<span class="s">    &gt;&gt;&gt; # Exercise the non-recursive generator.</span>
<span class="s">    &gt;&gt;&gt; for x in t:</span>
<span class="s">    ...     print(&#39; &#39;+x, end=&#39;&#39;)</span>
<span class="s">     A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="c"># Examples from Iterator-List and Python-Dev and c.l.py.</span>

<span class="n">email_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">The difference between yielding None and returning it.</span>

<span class="s">&gt;&gt;&gt; def g():</span>
<span class="s">...     for i in range(3):</span>
<span class="s">...         yield None</span>
<span class="s">...     yield None</span>
<span class="s">...     return</span>
<span class="s">&gt;&gt;&gt; list(g())</span>
<span class="s">[None, None, None, None]</span>

<span class="s">Ensure that explicitly raising StopIteration acts like any other exception</span>
<span class="s">in try/except, not like a return.</span>

<span class="s">&gt;&gt;&gt; def g():</span>
<span class="s">...     yield 1</span>
<span class="s">...     try:</span>
<span class="s">...         raise StopIteration</span>
<span class="s">...     except:</span>
<span class="s">...         yield 2</span>
<span class="s">...     yield 3</span>
<span class="s">&gt;&gt;&gt; list(g())</span>
<span class="s">[1, 2, 3]</span>

<span class="s">Next one was posted to c.l.py.</span>

<span class="s">&gt;&gt;&gt; def gcomb(x, k):</span>
<span class="s">...     &quot;Generate all combinations of k elements from list x.&quot;</span>
<span class="s">...</span>
<span class="s">...     if k &gt; len(x):</span>
<span class="s">...         return</span>
<span class="s">...     if k == 0:</span>
<span class="s">...         yield []</span>
<span class="s">...     else:</span>
<span class="s">...         first, rest = x[0], x[1:]</span>
<span class="s">...         # A combination does or doesn&#39;t contain first.</span>
<span class="s">...         # If it does, the remainder is a k-1 comb of rest.</span>
<span class="s">...         for c in gcomb(rest, k-1):</span>
<span class="s">...             c.insert(0, first)</span>
<span class="s">...             yield c</span>
<span class="s">...         # If it doesn&#39;t contain first, it&#39;s a k comb of rest.</span>
<span class="s">...         for c in gcomb(rest, k):</span>
<span class="s">...             yield c</span>

<span class="s">&gt;&gt;&gt; seq = list(range(1, 5))</span>
<span class="s">&gt;&gt;&gt; for k in range(len(seq) + 2):</span>
<span class="s">...     print(&quot;</span><span class="si">%d</span><span class="s">-combs of </span><span class="si">%s</span><span class="s">:&quot; % (k, seq))</span>
<span class="s">...     for c in gcomb(seq, k):</span>
<span class="s">...         print(&quot;   &quot;, c)</span>
<span class="s">0-combs of [1, 2, 3, 4]:</span>
<span class="s">    []</span>
<span class="s">1-combs of [1, 2, 3, 4]:</span>
<span class="s">    [1]</span>
<span class="s">    [2]</span>
<span class="s">    [3]</span>
<span class="s">    [4]</span>
<span class="s">2-combs of [1, 2, 3, 4]:</span>
<span class="s">    [1, 2]</span>
<span class="s">    [1, 3]</span>
<span class="s">    [1, 4]</span>
<span class="s">    [2, 3]</span>
<span class="s">    [2, 4]</span>
<span class="s">    [3, 4]</span>
<span class="s">3-combs of [1, 2, 3, 4]:</span>
<span class="s">    [1, 2, 3]</span>
<span class="s">    [1, 2, 4]</span>
<span class="s">    [1, 3, 4]</span>
<span class="s">    [2, 3, 4]</span>
<span class="s">4-combs of [1, 2, 3, 4]:</span>
<span class="s">    [1, 2, 3, 4]</span>
<span class="s">5-combs of [1, 2, 3, 4]:</span>

<span class="s">From the Iterators list, about the types of these things.</span>

<span class="s">&gt;&gt;&gt; def g():</span>
<span class="s">...     yield 1</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; type(g)</span>
<span class="s">&lt;class &#39;function&#39;&gt;</span>
<span class="s">&gt;&gt;&gt; i = g()</span>
<span class="s">&gt;&gt;&gt; type(i)</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>
<span class="s">&gt;&gt;&gt; [s for s in dir(i) if not s.startswith(&#39;_&#39;)]</span>
<span class="s">[&#39;close&#39;, &#39;gi_code&#39;, &#39;gi_frame&#39;, &#39;gi_running&#39;, &#39;send&#39;, &#39;throw&#39;]</span>
<span class="s">&gt;&gt;&gt; from test.support import HAVE_DOCSTRINGS</span>
<span class="s">&gt;&gt;&gt; print(i.__next__.__doc__ if HAVE_DOCSTRINGS else &#39;Implement next(self).&#39;)</span>
<span class="s">Implement next(self).</span>
<span class="s">&gt;&gt;&gt; iter(i) is i</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; import types</span>
<span class="s">&gt;&gt;&gt; isinstance(i, types.GeneratorType)</span>
<span class="s">True</span>

<span class="s">And more, added later.</span>

<span class="s">&gt;&gt;&gt; i.gi_running</span>
<span class="s">0</span>
<span class="s">&gt;&gt;&gt; type(i.gi_frame)</span>
<span class="s">&lt;class &#39;frame&#39;&gt;</span>
<span class="s">&gt;&gt;&gt; i.gi_running = 42</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">AttributeError: readonly attribute</span>
<span class="s">&gt;&gt;&gt; def g():</span>
<span class="s">...     yield me.gi_running</span>
<span class="s">&gt;&gt;&gt; me = g()</span>
<span class="s">&gt;&gt;&gt; me.gi_running</span>
<span class="s">0</span>
<span class="s">&gt;&gt;&gt; next(me)</span>
<span class="s">1</span>
<span class="s">&gt;&gt;&gt; me.gi_running</span>
<span class="s">0</span>

<span class="s">A clever union-find implementation from c.l.py, due to David Eppstein.</span>
<span class="s">Sent: Friday, June 29, 2001 12:16 PM</span>
<span class="s">To: python-list@python.org</span>
<span class="s">Subject: Re: PEP 255: Simple Generators</span>

<span class="s">&gt;&gt;&gt; class disjointSet:</span>
<span class="s">...     def __init__(self, name):</span>
<span class="s">...         self.name = name</span>
<span class="s">...         self.parent = None</span>
<span class="s">...         self.generator = self.generate()</span>
<span class="s">...</span>
<span class="s">...     def generate(self):</span>
<span class="s">...         while not self.parent:</span>
<span class="s">...             yield self</span>
<span class="s">...         for x in self.parent.generator:</span>
<span class="s">...             yield x</span>
<span class="s">...</span>
<span class="s">...     def find(self):</span>
<span class="s">...         return next(self.generator)</span>
<span class="s">...</span>
<span class="s">...     def union(self, parent):</span>
<span class="s">...         if self.parent:</span>
<span class="s">...             raise ValueError(&quot;Sorry, I&#39;m not a root!&quot;)</span>
<span class="s">...         self.parent = parent</span>
<span class="s">...</span>
<span class="s">...     def __str__(self):</span>
<span class="s">...         return self.name</span>

<span class="s">&gt;&gt;&gt; names = &quot;ABCDEFGHIJKLM&quot;</span>
<span class="s">&gt;&gt;&gt; sets = [disjointSet(name) for name in names]</span>
<span class="s">&gt;&gt;&gt; roots = sets[:]</span>

<span class="s">&gt;&gt;&gt; import random</span>
<span class="s">&gt;&gt;&gt; gen = random.Random(42)</span>
<span class="s">&gt;&gt;&gt; while 1:</span>
<span class="s">...     for s in sets:</span>
<span class="s">...         print(&quot; </span><span class="si">%s</span><span class="s">-&gt;</span><span class="si">%s</span><span class="s">&quot; % (s, s.find()), end=&#39;&#39;)</span>
<span class="s">...     print()</span>
<span class="s">...     if len(roots) &gt; 1:</span>
<span class="s">...         s1 = gen.choice(roots)</span>
<span class="s">...         roots.remove(s1)</span>
<span class="s">...         s2 = gen.choice(roots)</span>
<span class="s">...         s1.union(s2)</span>
<span class="s">...         print(&quot;merged&quot;, s1, &quot;into&quot;, s2)</span>
<span class="s">...     else:</span>
<span class="s">...         break</span>
<span class="s"> A-&gt;A B-&gt;B C-&gt;C D-&gt;D E-&gt;E F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;K L-&gt;L M-&gt;M</span>
<span class="s">merged K into B</span>
<span class="s"> A-&gt;A B-&gt;B C-&gt;C D-&gt;D E-&gt;E F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;B L-&gt;L M-&gt;M</span>
<span class="s">merged A into F</span>
<span class="s"> A-&gt;F B-&gt;B C-&gt;C D-&gt;D E-&gt;E F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;B L-&gt;L M-&gt;M</span>
<span class="s">merged E into F</span>
<span class="s"> A-&gt;F B-&gt;B C-&gt;C D-&gt;D E-&gt;F F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;B L-&gt;L M-&gt;M</span>
<span class="s">merged D into C</span>
<span class="s"> A-&gt;F B-&gt;B C-&gt;C D-&gt;C E-&gt;F F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;B L-&gt;L M-&gt;M</span>
<span class="s">merged M into C</span>
<span class="s"> A-&gt;F B-&gt;B C-&gt;C D-&gt;C E-&gt;F F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;J K-&gt;B L-&gt;L M-&gt;C</span>
<span class="s">merged J into B</span>
<span class="s"> A-&gt;F B-&gt;B C-&gt;C D-&gt;C E-&gt;F F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;B K-&gt;B L-&gt;L M-&gt;C</span>
<span class="s">merged B into C</span>
<span class="s"> A-&gt;F B-&gt;C C-&gt;C D-&gt;C E-&gt;F F-&gt;F G-&gt;G H-&gt;H I-&gt;I J-&gt;C K-&gt;C L-&gt;L M-&gt;C</span>
<span class="s">merged F into G</span>
<span class="s"> A-&gt;G B-&gt;C C-&gt;C D-&gt;C E-&gt;G F-&gt;G G-&gt;G H-&gt;H I-&gt;I J-&gt;C K-&gt;C L-&gt;L M-&gt;C</span>
<span class="s">merged L into C</span>
<span class="s"> A-&gt;G B-&gt;C C-&gt;C D-&gt;C E-&gt;G F-&gt;G G-&gt;G H-&gt;H I-&gt;I J-&gt;C K-&gt;C L-&gt;C M-&gt;C</span>
<span class="s">merged G into I</span>
<span class="s"> A-&gt;I B-&gt;C C-&gt;C D-&gt;C E-&gt;I F-&gt;I G-&gt;I H-&gt;H I-&gt;I J-&gt;C K-&gt;C L-&gt;C M-&gt;C</span>
<span class="s">merged I into H</span>
<span class="s"> A-&gt;H B-&gt;C C-&gt;C D-&gt;C E-&gt;H F-&gt;H G-&gt;H H-&gt;H I-&gt;H J-&gt;C K-&gt;C L-&gt;C M-&gt;C</span>
<span class="s">merged C into H</span>
<span class="s"> A-&gt;H B-&gt;H C-&gt;H D-&gt;H E-&gt;H F-&gt;H G-&gt;H H-&gt;H I-&gt;H J-&gt;H K-&gt;H L-&gt;H M-&gt;H</span>

<span class="s">&quot;&quot;&quot;</span>
<span class="c"># Emacs turd &#39;</span>

<span class="c"># Fun tests (for sufficiently warped notions of &quot;fun&quot;).</span>

<span class="n">fun_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">Build up to a recursive Sieve of Eratosthenes generator.</span>

<span class="s">&gt;&gt;&gt; def firstn(g, n):</span>
<span class="s">...     return [next(g) for i in range(n)]</span>

<span class="s">&gt;&gt;&gt; def intsfrom(i):</span>
<span class="s">...     while 1:</span>
<span class="s">...         yield i</span>
<span class="s">...         i += 1</span>

<span class="s">&gt;&gt;&gt; firstn(intsfrom(5), 7)</span>
<span class="s">[5, 6, 7, 8, 9, 10, 11]</span>

<span class="s">&gt;&gt;&gt; def exclude_multiples(n, ints):</span>
<span class="s">...     for i in ints:</span>
<span class="s">...         if i % n:</span>
<span class="s">...             yield i</span>

<span class="s">&gt;&gt;&gt; firstn(exclude_multiples(3, intsfrom(1)), 6)</span>
<span class="s">[1, 2, 4, 5, 7, 8]</span>

<span class="s">&gt;&gt;&gt; def sieve(ints):</span>
<span class="s">...     prime = next(ints)</span>
<span class="s">...     yield prime</span>
<span class="s">...     not_divisible_by_prime = exclude_multiples(prime, ints)</span>
<span class="s">...     for p in sieve(not_divisible_by_prime):</span>
<span class="s">...         yield p</span>

<span class="s">&gt;&gt;&gt; primes = sieve(intsfrom(2))</span>
<span class="s">&gt;&gt;&gt; firstn(primes, 20)</span>
<span class="s">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]</span>


<span class="s">Another famous problem:  generate all integers of the form</span>
<span class="s">    2**i * 3**j  * 5**k</span>
<span class="s">in increasing order, where i,j,k &gt;= 0.  Trickier than it may look at first!</span>
<span class="s">Try writing it without generators, and correctly, and without generating</span>
<span class="s">3 internal results for each result output.</span>

<span class="s">&gt;&gt;&gt; def times(n, g):</span>
<span class="s">...     for i in g:</span>
<span class="s">...         yield n * i</span>
<span class="s">&gt;&gt;&gt; firstn(times(10, intsfrom(1)), 10)</span>
<span class="s">[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span>

<span class="s">&gt;&gt;&gt; def merge(g, h):</span>
<span class="s">...     ng = next(g)</span>
<span class="s">...     nh = next(h)</span>
<span class="s">...     while 1:</span>
<span class="s">...         if ng &lt; nh:</span>
<span class="s">...             yield ng</span>
<span class="s">...             ng = next(g)</span>
<span class="s">...         elif ng &gt; nh:</span>
<span class="s">...             yield nh</span>
<span class="s">...             nh = next(h)</span>
<span class="s">...         else:</span>
<span class="s">...             yield ng</span>
<span class="s">...             ng = next(g)</span>
<span class="s">...             nh = next(h)</span>

<span class="s">The following works, but is doing a whale of a lot of redundant work --</span>
<span class="s">it&#39;s not clear how to get the internal uses of m235 to share a single</span>
<span class="s">generator.  Note that me_times2 (etc) each need to see every element in the</span>
<span class="s">result sequence.  So this is an example where lazy lists are more natural</span>
<span class="s">(you can look at the head of a lazy list any number of times).</span>

<span class="s">&gt;&gt;&gt; def m235():</span>
<span class="s">...     yield 1</span>
<span class="s">...     me_times2 = times(2, m235())</span>
<span class="s">...     me_times3 = times(3, m235())</span>
<span class="s">...     me_times5 = times(5, m235())</span>
<span class="s">...     for i in merge(merge(me_times2,</span>
<span class="s">...                          me_times3),</span>
<span class="s">...                    me_times5):</span>
<span class="s">...         yield i</span>

<span class="s">Don&#39;t print &quot;too many&quot; of these -- the implementation above is extremely</span>
<span class="s">inefficient:  each call of m235() leads to 3 recursive calls, and in</span>
<span class="s">turn each of those 3 more, and so on, and so on, until we&#39;ve descended</span>
<span class="s">enough levels to satisfy the print stmts.  Very odd:  when I printed 5</span>
<span class="s">lines of results below, this managed to screw up Win98&#39;s malloc in &quot;the</span>
<span class="s">usual&quot; way, i.e. the heap grew over 4Mb so Win98 started fragmenting</span>
<span class="s">address space, and it *looked* like a very slow leak.</span>

<span class="s">&gt;&gt;&gt; result = m235()</span>
<span class="s">&gt;&gt;&gt; for i in range(3):</span>
<span class="s">...     print(firstn(result, 15))</span>
<span class="s">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]</span>
<span class="s">[25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80]</span>
<span class="s">[81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192]</span>

<span class="s">Heh.  Here&#39;s one way to get a shared list, complete with an excruciating</span>
<span class="s">namespace renaming trick.  The *pretty* part is that the times() and merge()</span>
<span class="s">functions can be reused as-is, because they only assume their stream</span>
<span class="s">arguments are iterable -- a LazyList is the same as a generator to times().</span>

<span class="s">&gt;&gt;&gt; class LazyList:</span>
<span class="s">...     def __init__(self, g):</span>
<span class="s">...         self.sofar = []</span>
<span class="s">...         self.fetch = g.__next__</span>
<span class="s">...</span>
<span class="s">...     def __getitem__(self, i):</span>
<span class="s">...         sofar, fetch = self.sofar, self.fetch</span>
<span class="s">...         while i &gt;= len(sofar):</span>
<span class="s">...             sofar.append(fetch())</span>
<span class="s">...         return sofar[i]</span>

<span class="s">&gt;&gt;&gt; def m235():</span>
<span class="s">...     yield 1</span>
<span class="s">...     # Gack:  m235 below actually refers to a LazyList.</span>
<span class="s">...     me_times2 = times(2, m235)</span>
<span class="s">...     me_times3 = times(3, m235)</span>
<span class="s">...     me_times5 = times(5, m235)</span>
<span class="s">...     for i in merge(merge(me_times2,</span>
<span class="s">...                          me_times3),</span>
<span class="s">...                    me_times5):</span>
<span class="s">...         yield i</span>

<span class="s">Print as many of these as you like -- *this* implementation is memory-</span>
<span class="s">efficient.</span>

<span class="s">&gt;&gt;&gt; m235 = LazyList(m235())</span>
<span class="s">&gt;&gt;&gt; for i in range(5):</span>
<span class="s">...     print([m235[j] for j in range(15*i, 15*(i+1))])</span>
<span class="s">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]</span>
<span class="s">[25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80]</span>
<span class="s">[81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192]</span>
<span class="s">[200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384]</span>
<span class="s">[400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675]</span>

<span class="s">Ye olde Fibonacci generator, LazyList style.</span>

<span class="s">&gt;&gt;&gt; def fibgen(a, b):</span>
<span class="s">...</span>
<span class="s">...     def sum(g, h):</span>
<span class="s">...         while 1:</span>
<span class="s">...             yield next(g) + next(h)</span>
<span class="s">...</span>
<span class="s">...     def tail(g):</span>
<span class="s">...         next(g)    # throw first away</span>
<span class="s">...         for x in g:</span>
<span class="s">...             yield x</span>
<span class="s">...</span>
<span class="s">...     yield a</span>
<span class="s">...     yield b</span>
<span class="s">...     for s in sum(iter(fib),</span>
<span class="s">...                  tail(iter(fib))):</span>
<span class="s">...         yield s</span>

<span class="s">&gt;&gt;&gt; fib = LazyList(fibgen(1, 2))</span>
<span class="s">&gt;&gt;&gt; firstn(iter(fib), 17)</span>
<span class="s">[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584]</span>


<span class="s">Running after your tail with itertools.tee (new in version 2.4)</span>

<span class="s">The algorithms &quot;m235&quot; (Hamming) and Fibonacci presented above are both</span>
<span class="s">examples of a whole family of FP (functional programming) algorithms</span>
<span class="s">where a function produces and returns a list while the production algorithm</span>
<span class="s">suppose the list as already produced by recursively calling itself.</span>
<span class="s">For these algorithms to work, they must:</span>

<span class="s">- produce at least a first element without presupposing the existence of</span>
<span class="s">  the rest of the list</span>
<span class="s">- produce their elements in a lazy manner</span>

<span class="s">To work efficiently, the beginning of the list must not be recomputed over</span>
<span class="s">and over again. This is ensured in most FP languages as a built-in feature.</span>
<span class="s">In python, we have to explicitly maintain a list of already computed results</span>
<span class="s">and abandon genuine recursivity.</span>

<span class="s">This is what had been attempted above with the LazyList class. One problem</span>
<span class="s">with that class is that it keeps a list of all of the generated results and</span>
<span class="s">therefore continually grows. This partially defeats the goal of the generator</span>
<span class="s">concept, viz. produce the results only as needed instead of producing them</span>
<span class="s">all and thereby wasting memory.</span>

<span class="s">Thanks to itertools.tee, it is now clear &quot;how to get the internal uses of</span>
<span class="s">m235 to share a single generator&quot;.</span>

<span class="s">&gt;&gt;&gt; from itertools import tee</span>
<span class="s">&gt;&gt;&gt; def m235():</span>
<span class="s">...     def _m235():</span>
<span class="s">...         yield 1</span>
<span class="s">...         for n in merge(times(2, m2),</span>
<span class="s">...                        merge(times(3, m3),</span>
<span class="s">...                              times(5, m5))):</span>
<span class="s">...             yield n</span>
<span class="s">...     m1 = _m235()</span>
<span class="s">...     m2, m3, m5, mRes = tee(m1, 4)</span>
<span class="s">...     return mRes</span>

<span class="s">&gt;&gt;&gt; it = m235()</span>
<span class="s">&gt;&gt;&gt; for i in range(5):</span>
<span class="s">...     print(firstn(it, 15))</span>
<span class="s">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]</span>
<span class="s">[25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80]</span>
<span class="s">[81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192]</span>
<span class="s">[200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384]</span>
<span class="s">[400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675]</span>

<span class="s">The &quot;tee&quot; function does just what we want. It internally keeps a generated</span>
<span class="s">result for as long as it has not been &quot;consumed&quot; from all of the duplicated</span>
<span class="s">iterators, whereupon it is deleted. You can therefore print the hamming</span>
<span class="s">sequence during hours without increasing memory usage, or very little.</span>

<span class="s">The beauty of it is that recursive running-after-their-tail FP algorithms</span>
<span class="s">are quite straightforwardly expressed with this Python idiom.</span>

<span class="s">Ye olde Fibonacci generator, tee style.</span>

<span class="s">&gt;&gt;&gt; def fib():</span>
<span class="s">...</span>
<span class="s">...     def _isum(g, h):</span>
<span class="s">...         while 1:</span>
<span class="s">...             yield next(g) + next(h)</span>
<span class="s">...</span>
<span class="s">...     def _fib():</span>
<span class="s">...         yield 1</span>
<span class="s">...         yield 2</span>
<span class="s">...         next(fibTail) # throw first away</span>
<span class="s">...         for res in _isum(fibHead, fibTail):</span>
<span class="s">...             yield res</span>
<span class="s">...</span>
<span class="s">...     realfib = _fib()</span>
<span class="s">...     fibHead, fibTail, fibRes = tee(realfib, 3)</span>
<span class="s">...     return fibRes</span>

<span class="s">&gt;&gt;&gt; firstn(fib(), 17)</span>
<span class="s">[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584]</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="c"># syntax_tests mostly provokes SyntaxErrors.  Also fiddling with #if 0</span>
<span class="c"># hackery.</span>

<span class="n">syntax_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">These are fine:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     yield 1</span>
<span class="s">...     return</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try:</span>
<span class="s">...         yield 1</span>
<span class="s">...     finally:</span>
<span class="s">...         pass</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try:</span>
<span class="s">...         try:</span>
<span class="s">...             1//0</span>
<span class="s">...         except ZeroDivisionError:</span>
<span class="s">...             yield 666</span>
<span class="s">...         except:</span>
<span class="s">...             pass</span>
<span class="s">...     finally:</span>
<span class="s">...         pass</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try:</span>
<span class="s">...         try:</span>
<span class="s">...             yield 12</span>
<span class="s">...             1//0</span>
<span class="s">...         except ZeroDivisionError:</span>
<span class="s">...             yield 666</span>
<span class="s">...         except:</span>
<span class="s">...             try:</span>
<span class="s">...                 x = 12</span>
<span class="s">...             finally:</span>
<span class="s">...                 yield 12</span>
<span class="s">...     except:</span>
<span class="s">...         return</span>
<span class="s">&gt;&gt;&gt; list(f())</span>
<span class="s">[12, 666]</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...    yield</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>


<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...    if 0:</span>
<span class="s">...        yield</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>


<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     if 0:</span>
<span class="s">...         yield 1</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...    if &quot;&quot;:</span>
<span class="s">...        yield None</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     return</span>
<span class="s">...     try:</span>
<span class="s">...         if x==4:</span>
<span class="s">...             pass</span>
<span class="s">...         elif 0:</span>
<span class="s">...             try:</span>
<span class="s">...                 1//0</span>
<span class="s">...             except SyntaxError:</span>
<span class="s">...                 pass</span>
<span class="s">...             else:</span>
<span class="s">...                 if 0:</span>
<span class="s">...                     while 12:</span>
<span class="s">...                         x += 1</span>
<span class="s">...                         yield 2 # don&#39;t blink</span>
<span class="s">...                         f(a, b, c, d, e)</span>
<span class="s">...         else:</span>
<span class="s">...             pass</span>
<span class="s">...     except:</span>
<span class="s">...         x = 1</span>
<span class="s">...     return</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     if 0:</span>
<span class="s">...         def g():</span>
<span class="s">...             yield 1</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;NoneType&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     if 0:</span>
<span class="s">...         class C:</span>
<span class="s">...             def __init__(self):</span>
<span class="s">...                 yield 1</span>
<span class="s">...             def f(self):</span>
<span class="s">...                 yield 2</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;NoneType&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     if 0:</span>
<span class="s">...         return</span>
<span class="s">...     if 0:</span>
<span class="s">...         yield 2</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">This one caused a crash (see SF bug 567538):</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     for i in range(3):</span>
<span class="s">...         try:</span>
<span class="s">...             continue</span>
<span class="s">...         finally:</span>
<span class="s">...             yield i</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; print(next(g))</span>
<span class="s">0</span>
<span class="s">&gt;&gt;&gt; print(next(g))</span>
<span class="s">1</span>
<span class="s">&gt;&gt;&gt; print(next(g))</span>
<span class="s">2</span>
<span class="s">&gt;&gt;&gt; print(next(g))</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">StopIteration</span>


<span class="s">Test the gi_code attribute</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     yield 5</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; g.gi_code is f.__code__</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">5</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">StopIteration</span>
<span class="s">&gt;&gt;&gt; g.gi_code is f.__code__</span>
<span class="s">True</span>


<span class="s">Test the __name__ attribute and the repr()</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...    yield 5</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; g.__name__</span>
<span class="s">&#39;f&#39;</span>
<span class="s">&gt;&gt;&gt; repr(g)  # doctest: +ELLIPSIS</span>
<span class="s">&#39;&lt;generator object f at ...&gt;&#39;</span>

<span class="s">Lambdas shouldn&#39;t have their usual return behavior.</span>

<span class="s">&gt;&gt;&gt; x = lambda: (yield 1)</span>
<span class="s">&gt;&gt;&gt; list(x())</span>
<span class="s">[1]</span>

<span class="s">&gt;&gt;&gt; x = lambda: ((yield 1), (yield 2))</span>
<span class="s">&gt;&gt;&gt; list(x())</span>
<span class="s">[1, 2]</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="c"># conjoin is a simple backtracking generator, named in honor of Icon&#39;s</span>
<span class="c"># &quot;conjunction&quot; control structure.  Pass a list of no-argument functions</span>
<span class="c"># that return iterable objects.  Easiest to explain by example:  assume the</span>
<span class="c"># function list [x, y, z] is passed.  Then conjoin acts like:</span>
<span class="c">#</span>
<span class="c"># def g():</span>
<span class="c">#     values = [None] * 3</span>
<span class="c">#     for values[0] in x():</span>
<span class="c">#         for values[1] in y():</span>
<span class="c">#             for values[2] in z():</span>
<span class="c">#                 yield values</span>
<span class="c">#</span>
<span class="c"># So some 3-lists of values *may* be generated, each time we successfully</span>
<span class="c"># get into the innermost loop.  If an iterator fails (is exhausted) before</span>
<span class="c"># then, it &quot;backtracks&quot; to get the next value from the nearest enclosing</span>
<span class="c"># iterator (the one &quot;to the left&quot;), and starts all over again at the next</span>
<span class="c"># slot (pumps a fresh iterator).  Of course this is most useful when the</span>
<span class="c"># iterators have side-effects, so that which values *can* be generated at</span>
<span class="c"># each slot depend on the values iterated at previous slots.</span>

<div class="viewcode-block" id="simple_conjoin"><a class="viewcode-back" href="../../test.html#test.test_generators.simple_conjoin">[docs]</a><span class="k">def</span> <span class="nf">simple_conjoin</span><span class="p">(</span><span class="n">gs</span><span class="p">):</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">]():</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">x</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="c"># That works fine, but recursing a level and checking i against len(gs) for</span>
<span class="c"># each item produced is inefficient.  By doing manual loop unrolling across</span>
<span class="c"># generator boundaries, it&#39;s possible to eliminate most of that overhead.</span>
<span class="c"># This isn&#39;t worth the bother *in general* for generators, but conjoin() is</span>
<span class="c"># a core building block for some CPU-intensive generator applications.</span>
</div>
<div class="viewcode-block" id="conjoin"><a class="viewcode-back" href="../../test.html#test.test_generators.conjoin">[docs]</a><span class="k">def</span> <span class="nf">conjoin</span><span class="p">(</span><span class="n">gs</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c"># Do one loop nest at time recursively, until the # of loop nests</span>
    <span class="c"># remaining is divisible by 3.</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">values</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">]():</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">(</span><span class="n">ip1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">x</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_gen3</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">x</span>

    <span class="c"># Do three loop nests at a time, recursing only if at least three more</span>
    <span class="c"># remain.  Don&#39;t call directly:  this is an internal optimization for</span>
    <span class="c"># gen&#39;s use.</span>

    <span class="k">def</span> <span class="nf">_gen3</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">ip1</span><span class="p">,</span> <span class="n">ip2</span><span class="p">,</span> <span class="n">ip3</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">3</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">ip3</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ip3</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="c"># These are the last three, so we can yield values directly.</span>
            <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">ip1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g1</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">ip2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g2</span><span class="p">():</span>
                        <span class="k">yield</span> <span class="n">values</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># At least 6 loop nests remain; peel off 3 and recurse for the</span>
            <span class="c"># rest.</span>
            <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">ip1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g1</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">values</span><span class="p">[</span><span class="n">ip2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">g2</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_gen3</span><span class="p">(</span><span class="n">ip3</span><span class="p">):</span>
                            <span class="k">yield</span> <span class="n">x</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="c"># And one more approach:  For backtracking apps like the Knight&#39;s Tour</span>
<span class="c"># solver below, the number of backtracking levels can be enormous (one</span>
<span class="c"># level per square, for the Knight&#39;s Tour, so that e.g. a 100x100 board</span>
<span class="c"># needs 10,000 levels).  In such cases Python is likely to run out of</span>
<span class="c"># stack space due to recursion.  So here&#39;s a recursion-free version of</span>
<span class="c"># conjoin too.</span>
<span class="c"># NOTE WELL:  This allows large problems to be solved with only trivial</span>
<span class="c"># demands on stack space.  Without explicitly resumable generators, this is</span>
<span class="c"># much harder to achieve.  OTOH, this is much slower (up to a factor of 2)</span>
<span class="c"># than the fancy unrolled recursive conjoin.</span>
</div>
<div class="viewcode-block" id="flat_conjoin"><a class="viewcode-back" href="../../test.html#test.test_generators.flat_conjoin">[docs]</a><span class="k">def</span> <span class="nf">flat_conjoin</span><span class="p">(</span><span class="n">gs</span><span class="p">):</span>  <span class="c"># rename to conjoin to run tests with this instead</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">iters</span>  <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">_StopIteration</span> <span class="o">=</span> <span class="ne">StopIteration</span>  <span class="c"># make local because caught a *lot*</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># Descend.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">iters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">]()</span><span class="o">.</span><span class="n">__next__</span>
                <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">it</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="n">_StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span>
            <span class="k">yield</span> <span class="n">values</span>

        <span class="c"># Backtrack until an older iterator can be resumed.</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iters</span><span class="p">[</span><span class="n">i</span><span class="p">]()</span>
                <span class="c"># Success!  Start fresh at next level.</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">_StopIteration</span><span class="p">:</span>
                <span class="c"># Continue backtracking.</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="k">break</span>

<span class="c"># A conjoin-based N-Queens solver.</span>
</div>
<div class="viewcode-block" id="Queens"><a class="viewcode-back" href="../../test.html#test.test_generators.Queens">[docs]</a><span class="k">class</span> <span class="nc">Queens</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">rangen</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c"># Assign a unique int to each column and diagonal.</span>
        <span class="c"># columns:  n of those, range(n).</span>
        <span class="c"># NW-SE diagonals: 2n-1 of these, i-j unique and invariant along</span>
        <span class="c"># each, smallest i-j is 0-(n-1) = 1-n, so add n-1 to shift to 0-</span>
        <span class="c"># based.</span>
        <span class="c"># NE-SW diagonals: 2n-1 of these, i+j unique and invariant along</span>
        <span class="c"># each, smallest i+j is 0, largest is 2n-2.</span>

        <span class="c"># For each square, compute a bit vector of the columns and</span>
        <span class="c"># diagonals it covers, and for each row compute a function that</span>
        <span class="c"># generates the possiblities for the columns in that row.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowgenerators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rangen</span><span class="p">:</span>
            <span class="n">rowuses</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">|</span>                  <span class="c"># column ordinal</span>
                       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span>    <span class="c"># NW-SE ordinal</span>
                       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">))</span>    <span class="c"># NE-SW ordinal</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rangen</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">rowgen</span><span class="p">(</span><span class="n">rowuses</span><span class="o">=</span><span class="n">rowuses</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rangen</span><span class="p">:</span>
                    <span class="n">uses</span> <span class="o">=</span> <span class="n">rowuses</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">uses</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">|=</span> <span class="n">uses</span>
                        <span class="k">yield</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">uses</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">rowgenerators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowgen</span><span class="p">)</span>

    <span class="c"># Generate solutions.</span>
<div class="viewcode-block" id="Queens.solve"><a class="viewcode-back" href="../../test.html#test.test_generators.Queens.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row2col</span> <span class="ow">in</span> <span class="n">conjoin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowgenerators</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">row2col</span>
</div>
<div class="viewcode-block" id="Queens.printsolution"><a class="viewcode-back" href="../../test.html#test.test_generators.Queens.printsolution">[docs]</a>    <span class="k">def</span> <span class="nf">printsolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row2col</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">row2col</span><span class="p">)</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span> <span class="o">+</span> <span class="s">&quot;-+&quot;</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">print</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot; &quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="n">squares</span><span class="p">[</span><span class="n">row2col</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&quot;Q&quot;</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;|&quot;</span> <span class="o">+</span> <span class="s">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;|&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

<span class="c"># A conjoin-based Knight&#39;s Tour solver.  This is pretty sophisticated</span>
<span class="c"># (e.g., when used with flat_conjoin above, and passing hard=1 to the</span>
<span class="c"># constructor, a 200x200 Knight&#39;s Tour was found quickly -- note that we&#39;re</span>
<span class="c"># creating 10s of thousands of generators then!), and is lengthy.</span>
</div></div>
<div class="viewcode-block" id="Knights"><a class="viewcode-back" href="../../test.html#test.test_generators.Knights">[docs]</a><span class="k">class</span> <span class="nc">Knights</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hard</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span>

        <span class="c"># solve() will set up succs[i] to be a list of square #i&#39;s</span>
        <span class="c"># successors.</span>
        <span class="n">succs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">succs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Remove i0 from each of its successor&#39;s successor lists, i.e.</span>
        <span class="c"># successors can&#39;t go back to i0 again.  Return 0 if we can</span>
        <span class="c"># detect this makes a solution impossible, else return 1.</span>

        <span class="k">def</span> <span class="nf">remove_from_successors</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
            <span class="c"># If we remove all exits from a free square, we&#39;re dead:</span>
            <span class="c"># even if we move to it next, we can&#39;t leave it again.</span>
            <span class="c"># If we create a square with one exit, we must visit it next;</span>
            <span class="c"># else somebody else will have to visit it, and since there&#39;s</span>
            <span class="c"># only one adjacent, there won&#39;t be a way to leave it again.</span>
            <span class="c"># Finelly, if we create more than one free square with a</span>
            <span class="c"># single exit, we can only move to one of them next, leaving</span>
            <span class="c"># the other one a dead end.</span>
            <span class="n">ne0</span> <span class="o">=</span> <span class="n">ne1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="n">i0</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">succs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ne0</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ne1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">ne0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ne1</span> <span class="o">&lt;</span> <span class="mi">2</span>

        <span class="c"># Put i0 back in each of its successor&#39;s successor lists.</span>

        <span class="k">def</span> <span class="nf">add_to_successors</span><span class="p">(</span><span class="n">i0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="n">i0</span><span class="p">]:</span>
                <span class="n">succs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>

        <span class="c"># Generate the first move.</span>
        <span class="k">def</span> <span class="nf">first</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c"># Since we&#39;re looking for a cycle, it doesn&#39;t matter where we</span>
            <span class="c"># start.  Starting in a corner makes the 2nd move easy.</span>
            <span class="n">corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">remove_from_successors</span><span class="p">(</span><span class="n">corner</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastij</span> <span class="o">=</span> <span class="n">corner</span>
            <span class="k">yield</span> <span class="n">corner</span>
            <span class="n">add_to_successors</span><span class="p">(</span><span class="n">corner</span><span class="p">)</span>

        <span class="c"># Generate the second moves.</span>
        <span class="k">def</span> <span class="nf">second</span><span class="p">():</span>
            <span class="n">corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">lastij</span> <span class="o">==</span> <span class="n">corner</span>  <span class="c"># i.e., we started in the corner</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">succs</span><span class="p">[</span><span class="n">corner</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="n">corner</span><span class="p">]</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="n">corner</span><span class="p">]</span>
            <span class="c"># Only two choices.  Whichever we pick, the other must be the</span>
            <span class="c"># square picked on move m*n, as it&#39;s the only way to get back</span>
            <span class="c"># to (0, 0).  Save its index in self.final so that moves before</span>
            <span class="c"># the last know it must be kept free.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">this</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="n">j</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">final</span>

                <span class="n">remove_from_successors</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
                <span class="n">succs</span><span class="p">[</span><span class="n">final</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corner</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lastij</span> <span class="o">=</span> <span class="n">this</span>
                <span class="k">yield</span> <span class="n">this</span>
                <span class="n">succs</span><span class="p">[</span><span class="n">final</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">corner</span><span class="p">)</span>
                <span class="n">add_to_successors</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>

        <span class="c"># Generate moves 3 thru m*n-1.</span>
        <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
            <span class="c"># If some successor has only one exit, must take it.</span>
            <span class="c"># Else favor successors with fewer exits.</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lastij</span><span class="p">]:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">succs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;else remove_from_successors() pruning flawed&quot;</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">break</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">remove_from_successors</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lastij</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">yield</span> <span class="n">i</span>
                    <span class="n">add_to_successors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c"># Generate moves 3 thru m*n-1.  Alternative version using a</span>
        <span class="c"># stronger (but more expensive) heuristic to order successors.</span>
        <span class="c"># Since the # of backtracking levels is m*n, a poor move early on</span>
        <span class="c"># can take eons to undo.  Smallest square board for which this</span>
        <span class="c"># matters a lot is 52x52.</span>
        <span class="k">def</span> <span class="nf">advance_hard</span><span class="p">(</span><span class="n">vmid</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">hmid</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
            <span class="c"># If some successor has only one exit, must take it.</span>
            <span class="c"># Else favor successors with fewer exits.</span>
            <span class="c"># Break ties via max distance from board centerpoint (favor</span>
            <span class="c"># corners and edges whenever possible).</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lastij</span><span class="p">]:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">succs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;else remove_from_successors() pruning flawed&quot;</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">break</span>
                <span class="n">i1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2coords</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span> <span class="o">-</span> <span class="n">vmid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="n">hmid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">remove_from_successors</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lastij</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">yield</span> <span class="n">i</span>
                    <span class="n">add_to_successors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c"># Generate the last move.</span>
        <span class="k">def</span> <span class="nf">last</span><span class="p">():</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lastij</span><span class="p">]</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span>

        <span class="k">if</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">squaregenerators</span> <span class="o">=</span> <span class="p">[</span><span class="n">first</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">squaregenerators</span> <span class="o">=</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">[</span><span class="n">hard</span> <span class="ow">and</span> <span class="n">advance_hard</span> <span class="ow">or</span> <span class="n">advance</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> \
                <span class="p">[</span><span class="n">last</span><span class="p">]</span>

<div class="viewcode-block" id="Knights.coords2index"><a class="viewcode-back" href="../../test.html#test.test_generators.Knights.coords2index">[docs]</a>    <span class="k">def</span> <span class="nf">coords2index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span>
</div>
<div class="viewcode-block" id="Knights.index2coords"><a class="viewcode-back" href="../../test.html#test.test_generators.Knights.index2coords">[docs]</a>    <span class="k">def</span> <span class="nf">index2coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_init_board</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">succs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">succs</span>
        <span class="k">del</span> <span class="n">succs</span><span class="p">[:]</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">c2i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords2index</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">),</span> <span class="p">(</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                   <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">)]</span>
        <span class="n">rangen</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rangen</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">c2i</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">io</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">jo</span><span class="p">)</span> <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">jo</span> <span class="ow">in</span> <span class="n">offsets</span>
                                     <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">+</span><span class="n">io</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span>
                                        <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">+</span><span class="n">jo</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">]</span>
                <span class="n">succs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c"># Generate solutions.</span>
<div class="viewcode-block" id="Knights.solve"><a class="viewcode-back" href="../../test.html#test.test_generators.Knights.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_board</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">conjoin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">squaregenerators</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="Knights.printsolution"><a class="viewcode-back" href="../../test.html#test.test_generators.Knights.printsolution">[docs]</a>    <span class="k">def</span> <span class="nf">printsolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
        <span class="n">format</span> <span class="o">=</span> <span class="s">&quot;%&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;d&quot;</span>

        <span class="n">squares</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2coords</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">squares</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="n">format</span> <span class="o">%</span> <span class="n">k</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s">&quot;-&quot;</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="s">&quot;+&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">print</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">squares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;|&quot;</span> <span class="o">+</span> <span class="s">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;|&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
</div></div>
<span class="n">conjoin_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">Generate the 3-bit binary numbers in order.  This illustrates dumbest-</span>
<span class="s">possible use of conjoin, just to generate the full cross-product.</span>

<span class="s">&gt;&gt;&gt; for c in conjoin([lambda: iter((0, 1))] * 3):</span>
<span class="s">...     print(c)</span>
<span class="s">[0, 0, 0]</span>
<span class="s">[0, 0, 1]</span>
<span class="s">[0, 1, 0]</span>
<span class="s">[0, 1, 1]</span>
<span class="s">[1, 0, 0]</span>
<span class="s">[1, 0, 1]</span>
<span class="s">[1, 1, 0]</span>
<span class="s">[1, 1, 1]</span>

<span class="s">For efficiency in typical backtracking apps, conjoin() yields the same list</span>
<span class="s">object each time.  So if you want to save away a full account of its</span>
<span class="s">generated sequence, you need to copy its results.</span>

<span class="s">&gt;&gt;&gt; def gencopy(iterator):</span>
<span class="s">...     for x in iterator:</span>
<span class="s">...         yield x[:]</span>

<span class="s">&gt;&gt;&gt; for n in range(10):</span>
<span class="s">...     all = list(gencopy(conjoin([lambda: iter((0, 1))] * n)))</span>
<span class="s">...     print(n, len(all), all[0] == [0] * n, all[-1] == [1] * n)</span>
<span class="s">0 1 True True</span>
<span class="s">1 2 True True</span>
<span class="s">2 4 True True</span>
<span class="s">3 8 True True</span>
<span class="s">4 16 True True</span>
<span class="s">5 32 True True</span>
<span class="s">6 64 True True</span>
<span class="s">7 128 True True</span>
<span class="s">8 256 True True</span>
<span class="s">9 512 True True</span>

<span class="s">And run an 8-queens solver.</span>

<span class="s">&gt;&gt;&gt; q = Queens(8)</span>
<span class="s">&gt;&gt;&gt; LIMIT = 2</span>
<span class="s">&gt;&gt;&gt; count = 0</span>
<span class="s">&gt;&gt;&gt; for row2col in q.solve():</span>
<span class="s">...     count += 1</span>
<span class="s">...     if count &lt;= LIMIT:</span>
<span class="s">...         print(&quot;Solution&quot;, count)</span>
<span class="s">...         q.printsolution(row2col)</span>
<span class="s">Solution 1</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">|Q| | | | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | |Q| | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | | | |Q|</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | |Q| | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | |Q| | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | | |Q| |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| |Q| | | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | |Q| | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">Solution 2</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">|Q| | | | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | |Q| | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | | | |Q|</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | |Q| | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | | | |Q| |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | |Q| | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| |Q| | | | | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>
<span class="s">| | | | |Q| | | |</span>
<span class="s">+-+-+-+-+-+-+-+-+</span>

<span class="s">&gt;&gt;&gt; print(count, &quot;solutions in all.&quot;)</span>
<span class="s">92 solutions in all.</span>

<span class="s">And run a Knight&#39;s Tour on a 10x10 board.  Note that there are about</span>
<span class="s">20,000 solutions even on a 6x6 board, so don&#39;t dare run this to exhaustion.</span>

<span class="s">&gt;&gt;&gt; k = Knights(10, 10)</span>
<span class="s">&gt;&gt;&gt; LIMIT = 2</span>
<span class="s">&gt;&gt;&gt; count = 0</span>
<span class="s">&gt;&gt;&gt; for x in k.solve():</span>
<span class="s">...     count += 1</span>
<span class="s">...     if count &lt;= LIMIT:</span>
<span class="s">...         print(&quot;Solution&quot;, count)</span>
<span class="s">...         k.printsolution(x)</span>
<span class="s">...     else:</span>
<span class="s">...         break</span>
<span class="s">Solution 1</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">|  1| 58| 27| 34|  3| 40| 29| 10|  5|  8|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 26| 35|  2| 57| 28| 33|  4|  7| 30| 11|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 59|100| 73| 36| 41| 56| 39| 32|  9|  6|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 74| 25| 60| 55| 72| 37| 42| 49| 12| 31|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 61| 86| 99| 76| 63| 52| 47| 38| 43| 50|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 24| 75| 62| 85| 54| 71| 64| 51| 48| 13|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 87| 98| 91| 80| 77| 84| 53| 46| 65| 44|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 90| 23| 88| 95| 70| 79| 68| 83| 14| 17|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 97| 92| 21| 78| 81| 94| 19| 16| 45| 66|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 22| 89| 96| 93| 20| 69| 82| 67| 18| 15|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">Solution 2</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">|  1| 58| 27| 34|  3| 40| 29| 10|  5|  8|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 26| 35|  2| 57| 28| 33|  4|  7| 30| 11|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 59|100| 73| 36| 41| 56| 39| 32|  9|  6|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 74| 25| 60| 55| 72| 37| 42| 49| 12| 31|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 61| 86| 99| 76| 63| 52| 47| 38| 43| 50|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 24| 75| 62| 85| 54| 71| 64| 51| 48| 13|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 87| 98| 89| 80| 77| 84| 53| 46| 65| 44|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 90| 23| 92| 95| 70| 79| 68| 83| 14| 17|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 97| 88| 21| 78| 81| 94| 19| 16| 45| 66|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">| 22| 91| 96| 93| 20| 69| 82| 67| 18| 15|</span>
<span class="s">+---+---+---+---+---+---+---+---+---+---+</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">weakref_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Generators are weakly referencable:</span>

<span class="s">&gt;&gt;&gt; import weakref</span>
<span class="s">&gt;&gt;&gt; def gen():</span>
<span class="s">...     yield &#39;foo!&#39;</span>
<span class="s">...</span>
<span class="s">&gt;&gt;&gt; wr = weakref.ref(gen)</span>
<span class="s">&gt;&gt;&gt; wr() is gen</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; p = weakref.proxy(gen)</span>

<span class="s">Generator-iterators are weakly referencable as well:</span>

<span class="s">&gt;&gt;&gt; gi = gen()</span>
<span class="s">&gt;&gt;&gt; wr = weakref.ref(gi)</span>
<span class="s">&gt;&gt;&gt; wr() is gi</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; p = weakref.proxy(gi)</span>
<span class="s">&gt;&gt;&gt; list(p)</span>
<span class="s">[&#39;foo!&#39;]</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="n">coroutine_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Sending a value into a started generator:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     print((yield 1))</span>
<span class="s">...     yield 2</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">1</span>
<span class="s">&gt;&gt;&gt; g.send(42)</span>
<span class="s">42</span>
<span class="s">2</span>

<span class="s">Sending a value into a new generator produces a TypeError:</span>

<span class="s">&gt;&gt;&gt; f().send(&quot;foo&quot;)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">...</span>
<span class="s">TypeError: can&#39;t send non-None value to a just-started generator</span>


<span class="s">Yield by itself yields None:</span>

<span class="s">&gt;&gt;&gt; def f(): yield</span>
<span class="s">&gt;&gt;&gt; list(f())</span>
<span class="s">[None]</span>



<span class="s">An obscene abuse of a yield expression within a generator expression:</span>

<span class="s">&gt;&gt;&gt; list((yield 21) for i in range(4))</span>
<span class="s">[21, None, 21, None, 21, None, 21, None]</span>

<span class="s">And a more sane, but still weird usage:</span>

<span class="s">&gt;&gt;&gt; def f(): list(i for i in [(yield 26)])</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>


<span class="s">A yield expression with augmented assignment.</span>

<span class="s">&gt;&gt;&gt; def coroutine(seq):</span>
<span class="s">...     count = 0</span>
<span class="s">...     while count &lt; 200:</span>
<span class="s">...         count += yield</span>
<span class="s">...         seq.append(count)</span>
<span class="s">&gt;&gt;&gt; seq = []</span>
<span class="s">&gt;&gt;&gt; c = coroutine(seq)</span>
<span class="s">&gt;&gt;&gt; next(c)</span>
<span class="s">&gt;&gt;&gt; print(seq)</span>
<span class="s">[]</span>
<span class="s">&gt;&gt;&gt; c.send(10)</span>
<span class="s">&gt;&gt;&gt; print(seq)</span>
<span class="s">[10]</span>
<span class="s">&gt;&gt;&gt; c.send(10)</span>
<span class="s">&gt;&gt;&gt; print(seq)</span>
<span class="s">[10, 20]</span>
<span class="s">&gt;&gt;&gt; c.send(10)</span>
<span class="s">&gt;&gt;&gt; print(seq)</span>
<span class="s">[10, 20, 30]</span>


<span class="s">Check some syntax errors for yield expressions:</span>

<span class="s">&gt;&gt;&gt; f=lambda: (yield 1),(yield 2)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">SyntaxError: &#39;yield&#39; outside function</span>

<span class="s">&gt;&gt;&gt; def f(): x = yield = y</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">SyntaxError: assignment to yield expression not possible</span>

<span class="s">&gt;&gt;&gt; def f(): (yield bar) = y</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">SyntaxError: can&#39;t assign to yield expression</span>

<span class="s">&gt;&gt;&gt; def f(): (yield bar) += y</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">SyntaxError: can&#39;t assign to yield expression</span>


<span class="s">Now check some throw() conditions:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     while True:</span>
<span class="s">...         try:</span>
<span class="s">...             print((yield))</span>
<span class="s">...         except ValueError as v:</span>
<span class="s">...             print(&quot;caught ValueError (</span><span class="si">%s</span><span class="s">)&quot; % (v))</span>
<span class="s">&gt;&gt;&gt; import sys</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError) # type only</span>
<span class="s">caught ValueError ()</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError(&quot;xyz&quot;))  # value only</span>
<span class="s">caught ValueError (xyz)</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError, ValueError(1))   # value+matching type</span>
<span class="s">caught ValueError (1)</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError, TypeError(1))  # mismatched type, rewrapped</span>
<span class="s">caught ValueError (1)</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError, ValueError(1), None)   # explicit None traceback</span>
<span class="s">caught ValueError (1)</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError(1), &quot;foo&quot;)       # bad args</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: instance exception may not have a separate value</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError, &quot;foo&quot;, 23)      # bad args</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: throw() third argument must be a traceback object</span>

<span class="s">&gt;&gt;&gt; g.throw(&quot;abc&quot;)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: exceptions must be classes or instances deriving from BaseException, not str</span>

<span class="s">&gt;&gt;&gt; g.throw(0)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: exceptions must be classes or instances deriving from BaseException, not int</span>

<span class="s">&gt;&gt;&gt; g.throw(list)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: exceptions must be classes or instances deriving from BaseException, not type</span>

<span class="s">&gt;&gt;&gt; def throw(g,exc):</span>
<span class="s">...     try:</span>
<span class="s">...         raise exc</span>
<span class="s">...     except:</span>
<span class="s">...         g.throw(*sys.exc_info())</span>
<span class="s">&gt;&gt;&gt; throw(g,ValueError) # do it with traceback included</span>
<span class="s">caught ValueError ()</span>

<span class="s">&gt;&gt;&gt; g.send(1)</span>
<span class="s">1</span>

<span class="s">&gt;&gt;&gt; throw(g,TypeError)  # terminate the generator</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError</span>

<span class="s">&gt;&gt;&gt; print(g.gi_frame)</span>
<span class="s">None</span>

<span class="s">&gt;&gt;&gt; g.send(2)</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">StopIteration</span>

<span class="s">&gt;&gt;&gt; g.throw(ValueError,6)       # throw on closed generator</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">ValueError: 6</span>

<span class="s">&gt;&gt;&gt; f().throw(ValueError,7)     # throw on just-opened generator</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">ValueError: 7</span>

<span class="s">Plain &quot;raise&quot; inside a generator should preserve the traceback (#13188).</span>
<span class="s">The traceback should have 3 levels:</span>
<span class="s">- g.throw()</span>
<span class="s">- f()</span>
<span class="s">- 1/0</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try:</span>
<span class="s">...         yield</span>
<span class="s">...     except:</span>
<span class="s">...         raise</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; try:</span>
<span class="s">...     1/0</span>
<span class="s">... except ZeroDivisionError as v:</span>
<span class="s">...     try:</span>
<span class="s">...         g.throw(v)</span>
<span class="s">...     except Exception as w:</span>
<span class="s">...         tb = w.__traceback__</span>
<span class="s">&gt;&gt;&gt; levels = 0</span>
<span class="s">&gt;&gt;&gt; while tb:</span>
<span class="s">...     levels += 1</span>
<span class="s">...     tb = tb.tb_next</span>
<span class="s">&gt;&gt;&gt; levels</span>
<span class="s">3</span>

<span class="s">Now let&#39;s try closing a generator:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try: yield</span>
<span class="s">...     except GeneratorExit:</span>
<span class="s">...         print(&quot;exiting&quot;)</span>

<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; g.close()</span>
<span class="s">exiting</span>
<span class="s">&gt;&gt;&gt; g.close()  # should be no-op now</span>

<span class="s">&gt;&gt;&gt; f().close()  # close on just-opened generator should be fine</span>

<span class="s">&gt;&gt;&gt; def f(): yield      # an even simpler generator</span>
<span class="s">&gt;&gt;&gt; f().close()         # close before opening</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; g.close()           # close normally</span>

<span class="s">And finalization:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try: yield</span>
<span class="s">...     finally:</span>
<span class="s">...         print(&quot;exiting&quot;)</span>

<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; del g</span>
<span class="s">exiting</span>


<span class="s">GeneratorExit is not caught by except Exception:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try: yield</span>
<span class="s">...     except Exception:</span>
<span class="s">...         print(&#39;except&#39;)</span>
<span class="s">...     finally:</span>
<span class="s">...         print(&#39;finally&#39;)</span>

<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; del g</span>
<span class="s">finally</span>


<span class="s">Now let&#39;s try some ill-behaved generators:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try: yield</span>
<span class="s">...     except GeneratorExit:</span>
<span class="s">...         yield &quot;foo!&quot;</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; g.close()</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">RuntimeError: generator ignored GeneratorExit</span>
<span class="s">&gt;&gt;&gt; g.close()</span>


<span class="s">Our ill-behaved code should be invoked during GC:</span>

<span class="s">&gt;&gt;&gt; import sys, io</span>
<span class="s">&gt;&gt;&gt; old, sys.stderr = sys.stderr, io.StringIO()</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; del g</span>
<span class="s">&gt;&gt;&gt; &quot;RuntimeError: generator ignored GeneratorExit&quot; in sys.stderr.getvalue()</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; sys.stderr = old</span>


<span class="s">And errors thrown during closing should propagate:</span>

<span class="s">&gt;&gt;&gt; def f():</span>
<span class="s">...     try: yield</span>
<span class="s">...     except GeneratorExit:</span>
<span class="s">...         raise TypeError(&quot;fie!&quot;)</span>
<span class="s">&gt;&gt;&gt; g = f()</span>
<span class="s">&gt;&gt;&gt; next(g)</span>
<span class="s">&gt;&gt;&gt; g.close()</span>
<span class="s">Traceback (most recent call last):</span>
<span class="s">  ...</span>
<span class="s">TypeError: fie!</span>


<span class="s">Ensure that various yield expression constructs make their</span>
<span class="s">enclosing function a generator:</span>

<span class="s">&gt;&gt;&gt; def f(): x += yield</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f(): x = yield</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f(): lambda x=(yield): 1</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f(): x=(i for i in (yield) if (yield))</span>
<span class="s">&gt;&gt;&gt; type(f())</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>

<span class="s">&gt;&gt;&gt; def f(d): d[(yield &quot;a&quot;)] = d[(yield &quot;b&quot;)] = 27</span>
<span class="s">&gt;&gt;&gt; data = [1,2]</span>
<span class="s">&gt;&gt;&gt; g = f(data)</span>
<span class="s">&gt;&gt;&gt; type(g)</span>
<span class="s">&lt;class &#39;generator&#39;&gt;</span>
<span class="s">&gt;&gt;&gt; g.send(None)</span>
<span class="s">&#39;a&#39;</span>
<span class="s">&gt;&gt;&gt; data</span>
<span class="s">[1, 2]</span>
<span class="s">&gt;&gt;&gt; g.send(0)</span>
<span class="s">&#39;b&#39;</span>
<span class="s">&gt;&gt;&gt; data</span>
<span class="s">[27, 2]</span>
<span class="s">&gt;&gt;&gt; try: g.send(1)</span>
<span class="s">... except StopIteration: pass</span>
<span class="s">&gt;&gt;&gt; data</span>
<span class="s">[27, 27]</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="n">refleaks_tests</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Prior to adding cycle-GC support to itertools.tee, this code would leak</span>
<span class="s">references. We add it to the standard suite so the routine refleak-tests</span>
<span class="s">would trigger if it starts being uncleanable again.</span>

<span class="s">&gt;&gt;&gt; import itertools</span>
<span class="s">&gt;&gt;&gt; def leak():</span>
<span class="s">...     class gen:</span>
<span class="s">...         def __iter__(self):</span>
<span class="s">...             return self</span>
<span class="s">...         def __next__(self):</span>
<span class="s">...             return self.item</span>
<span class="s">...     g = gen()</span>
<span class="s">...     head, tail = itertools.tee(g)</span>
<span class="s">...     g.item = head</span>
<span class="s">...     return head</span>
<span class="s">&gt;&gt;&gt; it = leak()</span>

<span class="s">Make sure to also test the involvement of the tee-internal teedataobject,</span>
<span class="s">which stores returned items.</span>

<span class="s">&gt;&gt;&gt; item = next(it)</span>



<span class="s">This test leaked at one point due to generator finalization/destruction.</span>
<span class="s">It was copied from Lib/test/leakers/test_generator_cycle.py before the file</span>
<span class="s">was removed.</span>

<span class="s">&gt;&gt;&gt; def leak():</span>
<span class="s">...    def gen():</span>
<span class="s">...        while True:</span>
<span class="s">...            yield g</span>
<span class="s">...    g = gen()</span>

<span class="s">&gt;&gt;&gt; leak()</span>



<span class="s">This test isn&#39;t really generator related, but rather exception-in-cleanup</span>
<span class="s">related. The coroutine tests (above) just happen to cause an exception in</span>
<span class="s">the generator&#39;s __del__ (tp_del) method. We can also test for this</span>
<span class="s">explicitly, without generators. We do have to redirect stderr to avoid</span>
<span class="s">printing warnings and to doublecheck that we actually tested what we wanted</span>
<span class="s">to test.</span>

<span class="s">&gt;&gt;&gt; import sys, io</span>
<span class="s">&gt;&gt;&gt; old = sys.stderr</span>
<span class="s">&gt;&gt;&gt; try:</span>
<span class="s">...     sys.stderr = io.StringIO()</span>
<span class="s">...     class Leaker:</span>
<span class="s">...         def __del__(self):</span>
<span class="s">...             def invoke(message):</span>
<span class="s">...                 raise RuntimeError(message)</span>
<span class="s">...             invoke(&quot;test&quot;)</span>
<span class="s">...</span>
<span class="s">...     l = Leaker()</span>
<span class="s">...     del l</span>
<span class="s">...     err = sys.stderr.getvalue().strip()</span>
<span class="s">...     &quot;Exception ignored in&quot; in err</span>
<span class="s">...     &quot;RuntimeError: test&quot; in err</span>
<span class="s">...     &quot;Traceback&quot; in err</span>
<span class="s">...     &quot;in invoke&quot; in err</span>
<span class="s">... finally:</span>
<span class="s">...     sys.stderr = old</span>
<span class="s">True</span>
<span class="s">True</span>
<span class="s">True</span>
<span class="s">True</span>


<span class="s">These refleak tests should perhaps be in a testfile of their own,</span>
<span class="s">test_generators just happened to be the test that drew these out.</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="n">__test__</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;tut&quot;</span><span class="p">:</span>      <span class="n">tutorial_tests</span><span class="p">,</span>
            <span class="s">&quot;pep&quot;</span><span class="p">:</span>      <span class="n">pep_tests</span><span class="p">,</span>
            <span class="s">&quot;email&quot;</span><span class="p">:</span>    <span class="n">email_tests</span><span class="p">,</span>
            <span class="s">&quot;fun&quot;</span><span class="p">:</span>      <span class="n">fun_tests</span><span class="p">,</span>
            <span class="s">&quot;syntax&quot;</span><span class="p">:</span>   <span class="n">syntax_tests</span><span class="p">,</span>
            <span class="s">&quot;conjoin&quot;</span><span class="p">:</span>  <span class="n">conjoin_tests</span><span class="p">,</span>
            <span class="s">&quot;weakref&quot;</span><span class="p">:</span>  <span class="n">weakref_tests</span><span class="p">,</span>
            <span class="s">&quot;coroutine&quot;</span><span class="p">:</span>  <span class="n">coroutine_tests</span><span class="p">,</span>
            <span class="s">&quot;refleaks&quot;</span><span class="p">:</span> <span class="n">refleaks_tests</span><span class="p">,</span>
            <span class="p">}</span>

<span class="c"># Magic test name that regrtest.py invokes *after* importing this module.</span>
<span class="c"># This worms around a bootstrap problem.</span>
<span class="c"># Note that doctest and regrtest both look in sys.argv for a &quot;-v&quot; argument,</span>
<span class="c"># so this works as expected in both ways of running regrtest.</span>
<div class="viewcode-block" id="test_main"><a class="viewcode-back" href="../../test.html#test.test_generators.test_main">[docs]</a><span class="k">def</span> <span class="nf">test_main</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">test</span> <span class="kn">import</span> <span class="n">support</span><span class="p">,</span> <span class="n">test_generators</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_unittest</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_doctest</span><span class="p">(</span><span class="n">test_generators</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

<span class="c"># This part isn&#39;t needed for regrtest, but for running the test directly.</span></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">test_main</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Weldon Henson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.0.',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>