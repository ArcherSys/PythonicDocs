

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>test.test_doctest &mdash; ArcherBashPYDocs 1.0.0. documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ArcherBashPYDocs 1.0.0. documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> ArcherBashPYDocs</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">ArcherBashPYDocs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>test.test_doctest</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for test.test_doctest</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Test script for doctest.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">test</span> <span class="kn">import</span> <span class="n">support</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="c"># NOTE: There are some additional tests relating to interaction with</span>
<span class="c">#       zipimport in the test_zipimport_support test module.</span>

<span class="c">######################################################################</span>
<span class="c">## Sample Objects (used by test cases)</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="sample_func"><a class="viewcode-back" href="../../test.html#test.test_doctest.sample_func">[docs]</a><span class="k">def</span> <span class="nf">sample_func</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blah blah</span>

<span class="sd">    &gt;&gt;&gt; print(sample_func(22))</span>
<span class="sd">    44</span>

<span class="sd">    Yee ha!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">+</span><span class="n">v</span>
</div>
<div class="viewcode-block" id="SampleClass"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass">[docs]</a><span class="k">class</span> <span class="nc">SampleClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; print(1)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; # comments get ignored.  so are empty PS1 and PS2 prompts:</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    ...</span>

<span class="sd">    Multiline example:</span>
<span class="sd">    &gt;&gt;&gt; sc = SampleClass(3)</span>
<span class="sd">    &gt;&gt;&gt; for i in range(10):</span>
<span class="sd">    ...     sc = sc.double()</span>
<span class="sd">    ...     print(&#39; &#39;, sc.get(), sep=&#39;&#39;, end=&#39;&#39;)</span>
<span class="sd">     6 12 24 48 96 192 384 768 1536 3072</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass(12).get())</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="SampleClass.double"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.double">[docs]</a>    <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass(12).double().get())</span>
<span class="sd">        24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SampleClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SampleClass.get"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass(-5).get())</span>
<span class="sd">        -5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</div>
<div class="viewcode-block" id="SampleClass.a_staticmethod"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.a_staticmethod">[docs]</a>    <span class="k">def</span> <span class="nf">a_staticmethod</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass.a_staticmethod(10))</span>
<span class="sd">        11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">+</span><span class="mi">1</span></div>
    <span class="n">a_staticmethod</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">a_staticmethod</span><span class="p">)</span>

<div class="viewcode-block" id="SampleClass.a_classmethod"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.a_classmethod">[docs]</a>    <span class="k">def</span> <span class="nf">a_classmethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass.a_classmethod(10))</span>
<span class="sd">        12</span>
<span class="sd">        &gt;&gt;&gt; print(SampleClass(0).a_classmethod(10))</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">+</span><span class="mi">2</span></div>
    <span class="n">a_classmethod</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">a_classmethod</span><span class="p">)</span>

    <span class="n">a_property</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        &gt;&gt;&gt; print(SampleClass(22).a_property)</span>
<span class="s">        22</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SampleClass.NestedClass"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.NestedClass">[docs]</a>    <span class="k">class</span> <span class="nc">NestedClass</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; x = SampleClass.NestedClass(5)</span>
<span class="sd">        &gt;&gt;&gt; y = x.square()</span>
<span class="sd">        &gt;&gt;&gt; print(y.get())</span>
<span class="sd">        25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            &gt;&gt;&gt; print(SampleClass.NestedClass().get())</span>
<span class="sd">            0</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
<div class="viewcode-block" id="SampleClass.NestedClass.square"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.NestedClass.square">[docs]</a>        <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SampleClass</span><span class="o">.</span><span class="n">NestedClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span></div>
<div class="viewcode-block" id="SampleClass.NestedClass.get"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleClass.NestedClass.get">[docs]</a>        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</div></div></div>
<div class="viewcode-block" id="SampleNewStyleClass"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleNewStyleClass">[docs]</a><span class="k">class</span> <span class="nc">SampleNewStyleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;1\n2\n3&#39;)</span>
<span class="sd">    1</span>
<span class="sd">    2</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleNewStyleClass(12).get())</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="SampleNewStyleClass.double"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleNewStyleClass.double">[docs]</a>    <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleNewStyleClass(12).double().get())</span>
<span class="sd">        24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SampleNewStyleClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SampleNewStyleClass.get"><a class="viewcode-back" href="../../test.html#test.test_doctest.SampleNewStyleClass.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(SampleNewStyleClass(-5).get())</span>
<span class="sd">        -5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

<span class="c">######################################################################</span>
<span class="c">## Fake stdin (for testing interactive debugging)</span>
<span class="c">######################################################################</span>
</div></div>
<span class="k">class</span> <span class="nc">_FakeInput</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fake input stream for pdb&#39;s interactive debugger.  Whenever a</span>
<span class="sd">    line is read, print it (to simulate the user typing it), and then</span>
<span class="sd">    return it.  The set of lines to return is specified in the</span>
<span class="sd">    constructor; they should not have trailing newlines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

<span class="c">######################################################################</span>
<span class="c">## Test Cases</span>
<span class="c">######################################################################</span>

<div class="viewcode-block" id="test_Example"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_Example">[docs]</a><span class="k">def</span> <span class="nf">test_Example</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for the `Example` class.</span>

<span class="s">Example is a simple container class that holds:</span>
<span class="s">  - `source`: A source string.</span>
<span class="s">  - `want`: An expected output string.</span>
<span class="s">  - `exc_msg`: An expected exception message string (or None if no</span>
<span class="s">    exception is expected).</span>
<span class="s">  - `lineno`: A line number (within the docstring).</span>
<span class="s">  - `indent`: The example&#39;s indentation in the input string.</span>
<span class="s">  - `options`: An option dictionary, mapping option flags to True or</span>
<span class="s">    False.</span>

<span class="s">These attributes are set by the constructor.  `source` and `want` are</span>
<span class="s">required; the other attributes all have default values:</span>

<span class="s">    &gt;&gt;&gt; example = doctest.Example(&#39;print(1)&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; (example.source, example.want, example.exc_msg,</span>
<span class="s">    ...  example.lineno, example.indent, example.options)</span>
<span class="s">    (&#39;print(1)\n&#39;, &#39;1\n&#39;, None, 0, 0, {})</span>

<span class="s">The first three attributes (`source`, `want`, and `exc_msg`) may be</span>
<span class="s">specified positionally; the remaining arguments should be specified as</span>
<span class="s">keyword arguments:</span>

<span class="s">    &gt;&gt;&gt; exc_msg = &#39;IndexError: pop from an empty list&#39;</span>
<span class="s">    &gt;&gt;&gt; example = doctest.Example(&#39;[].pop()&#39;, &#39;&#39;, exc_msg,</span>
<span class="s">    ...                           lineno=5, indent=4,</span>
<span class="s">    ...                           options={doctest.ELLIPSIS: True})</span>
<span class="s">    &gt;&gt;&gt; (example.source, example.want, example.exc_msg,</span>
<span class="s">    ...  example.lineno, example.indent, example.options)</span>
<span class="s">    (&#39;[].pop()\n&#39;, &#39;&#39;, &#39;IndexError: pop from an empty list\n&#39;, 5, 4, {8: True})</span>

<span class="s">The constructor normalizes the `source` string to end in a newline:</span>

<span class="s">    Source spans a single line: no terminating newline.</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1)&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1)\n&#39;, &#39;1\n&#39;)</span>

<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1)\n&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1)\n&#39;, &#39;1\n&#39;)</span>

<span class="s">    Source spans multiple lines: require terminating newline.</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1);\nprint(2)\n&#39;, &#39;1\n2\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1);\nprint(2)\n&#39;, &#39;1\n2\n&#39;)</span>

<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1);\nprint(2)&#39;, &#39;1\n2\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1);\nprint(2)\n&#39;, &#39;1\n2\n&#39;)</span>

<span class="s">    Empty source string (which should never appear in real examples)</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;&#39;, &#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;\n&#39;, &#39;&#39;)</span>

<span class="s">The constructor normalizes the `want` string to end in a newline,</span>
<span class="s">unless it&#39;s the empty string:</span>

<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1)&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1)\n&#39;, &#39;1\n&#39;)</span>

<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print(1)&#39;, &#39;1&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print(1)\n&#39;, &#39;1\n&#39;)</span>

<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;print&#39;, &#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; e.source, e.want</span>
<span class="s">    (&#39;print\n&#39;, &#39;&#39;)</span>

<span class="s">The constructor normalizes the `exc_msg` string to end in a newline,</span>
<span class="s">unless it&#39;s `None`:</span>

<span class="s">    Message spans one line</span>
<span class="s">    &gt;&gt;&gt; exc_msg = &#39;IndexError: pop from an empty list&#39;</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;[].pop()&#39;, &#39;&#39;, exc_msg)</span>
<span class="s">    &gt;&gt;&gt; e.exc_msg</span>
<span class="s">    &#39;IndexError: pop from an empty list\n&#39;</span>

<span class="s">    &gt;&gt;&gt; exc_msg = &#39;IndexError: pop from an empty list\n&#39;</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;[].pop()&#39;, &#39;&#39;, exc_msg)</span>
<span class="s">    &gt;&gt;&gt; e.exc_msg</span>
<span class="s">    &#39;IndexError: pop from an empty list\n&#39;</span>

<span class="s">    Message spans multiple lines</span>
<span class="s">    &gt;&gt;&gt; exc_msg = &#39;ValueError: 1\n  2&#39;</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;raise ValueError(&quot;1\n  2&quot;)&#39;, &#39;&#39;, exc_msg)</span>
<span class="s">    &gt;&gt;&gt; e.exc_msg</span>
<span class="s">    &#39;ValueError: 1\n  2\n&#39;</span>

<span class="s">    &gt;&gt;&gt; exc_msg = &#39;ValueError: 1\n  2\n&#39;</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;raise ValueError(&quot;1\n  2&quot;)&#39;, &#39;&#39;, exc_msg)</span>
<span class="s">    &gt;&gt;&gt; e.exc_msg</span>
<span class="s">    &#39;ValueError: 1\n  2\n&#39;</span>

<span class="s">    Empty (but non-None) exception message (which should never appear</span>
<span class="s">    in real examples)</span>
<span class="s">    &gt;&gt;&gt; exc_msg = &#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; e = doctest.Example(&#39;raise X()&#39;, &#39;&#39;, exc_msg)</span>
<span class="s">    &gt;&gt;&gt; e.exc_msg</span>
<span class="s">    &#39;\n&#39;</span>

<span class="s">Compare `Example`:</span>
<span class="s">    &gt;&gt;&gt; example = doctest.Example(&#39;print 1&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; same_example = doctest.Example(&#39;print 1&#39;, &#39;1\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; other_example = doctest.Example(&#39;print 42&#39;, &#39;42\n&#39;)</span>
<span class="s">    &gt;&gt;&gt; example == same_example</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; example != same_example</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; hash(example) == hash(same_example)</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; example == other_example</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; example != other_example</span>
<span class="s">    True</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocTest"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTest">[docs]</a><span class="k">def</span> <span class="nf">test_DocTest</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for the `DocTest` class.</span>

<span class="s">DocTest is a collection of examples, extracted from a docstring, along</span>
<span class="s">with information about where the docstring comes from (a name,</span>
<span class="s">filename, and line number).  The docstring is parsed by the `DocTest`</span>
<span class="s">constructor:</span>

<span class="s">    &gt;&gt;&gt; docstring = &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(12)</span>
<span class="s">    ...     12</span>
<span class="s">    ...</span>
<span class="s">    ... Non-example text.</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; print(&#39;another\example&#39;)</span>
<span class="s">    ...     another</span>
<span class="s">    ...     example</span>
<span class="s">    ... &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; globs = {} # globals to run the test in.</span>
<span class="s">    &gt;&gt;&gt; parser = doctest.DocTestParser()</span>
<span class="s">    &gt;&gt;&gt; test = parser.get_doctest(docstring, globs, &#39;some_test&#39;,</span>
<span class="s">    ...                           &#39;some_file&#39;, 20)</span>
<span class="s">    &gt;&gt;&gt; print(test)</span>
<span class="s">    &lt;DocTest some_test from some_file:20 (2 examples)&gt;</span>
<span class="s">    &gt;&gt;&gt; len(test.examples)</span>
<span class="s">    2</span>
<span class="s">    &gt;&gt;&gt; e1, e2 = test.examples</span>
<span class="s">    &gt;&gt;&gt; (e1.source, e1.want, e1.lineno)</span>
<span class="s">    (&#39;print(12)\n&#39;, &#39;12\n&#39;, 1)</span>
<span class="s">    &gt;&gt;&gt; (e2.source, e2.want, e2.lineno)</span>
<span class="s">    (&quot;print(&#39;another\\example&#39;)\n&quot;, &#39;another\nexample\n&#39;, 6)</span>

<span class="s">Source information (name, filename, and line number) is available as</span>
<span class="s">attributes on the doctest object:</span>

<span class="s">    &gt;&gt;&gt; (test.name, test.filename, test.lineno)</span>
<span class="s">    (&#39;some_test&#39;, &#39;some_file&#39;, 20)</span>

<span class="s">The line number of an example within its containing file is found by</span>
<span class="s">adding the line number of the example and the line number of its</span>
<span class="s">containing test:</span>

<span class="s">    &gt;&gt;&gt; test.lineno + e1.lineno</span>
<span class="s">    21</span>
<span class="s">    &gt;&gt;&gt; test.lineno + e2.lineno</span>
<span class="s">    26</span>

<span class="s">If the docstring contains inconsistant leading whitespace in the</span>
<span class="s">expected output of an example, then `DocTest` will raise a ValueError:</span>

<span class="s">    &gt;&gt;&gt; docstring = r&#39;&#39;&#39;</span>
<span class="s">    ...       &gt;&gt;&gt; print(&#39;bad\nindentation&#39;)</span>
<span class="s">    ...       bad</span>
<span class="s">    ...     indentation</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; parser.get_doctest(docstring, globs, &#39;some_test&#39;, &#39;filename&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 4 of the docstring for some_test has inconsistent leading whitespace: &#39;indentation&#39;</span>

<span class="s">If the docstring contains inconsistent leading whitespace on</span>
<span class="s">continuation lines, then `DocTest` will raise a ValueError:</span>

<span class="s">    &gt;&gt;&gt; docstring = r&#39;&#39;&#39;</span>
<span class="s">    ...       &gt;&gt;&gt; print((&#39;bad indentation&#39;,</span>
<span class="s">    ...     ...          2))</span>
<span class="s">    ...       (&#39;bad&#39;, &#39;indentation&#39;)</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; parser.get_doctest(docstring, globs, &#39;some_test&#39;, &#39;filename&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 2 of the docstring for some_test has inconsistent leading whitespace: &#39;...          2))&#39;</span>

<span class="s">If there&#39;s no blank space after a PS1 prompt (&#39;&gt;&gt;&gt;&#39;), then `DocTest`</span>
<span class="s">will raise a ValueError:</span>

<span class="s">    &gt;&gt;&gt; docstring = &#39;&gt;&gt;&gt;print(1)\n1&#39;</span>
<span class="s">    &gt;&gt;&gt; parser.get_doctest(docstring, globs, &#39;some_test&#39;, &#39;filename&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 1 of the docstring for some_test lacks blank after &gt;&gt;&gt;: &#39;&gt;&gt;&gt;print(1)&#39;</span>

<span class="s">If there&#39;s no blank space after a PS2 prompt (&#39;...&#39;), then `DocTest`</span>
<span class="s">will raise a ValueError:</span>

<span class="s">    &gt;&gt;&gt; docstring = &#39;&gt;&gt;&gt; if 1:\n...print(1)\n1&#39;</span>
<span class="s">    &gt;&gt;&gt; parser.get_doctest(docstring, globs, &#39;some_test&#39;, &#39;filename&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 2 of the docstring for some_test lacks blank after ...: &#39;...print(1)&#39;</span>

<span class="s">Compare `DocTest`:</span>

<span class="s">    &gt;&gt;&gt; docstring = &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print 12</span>
<span class="s">    ...     12</span>
<span class="s">    ... &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = parser.get_doctest(docstring, globs, &#39;some_test&#39;,</span>
<span class="s">    ...                           &#39;some_test&#39;, 20)</span>
<span class="s">    &gt;&gt;&gt; same_test = parser.get_doctest(docstring, globs, &#39;some_test&#39;,</span>
<span class="s">    ...                                &#39;some_test&#39;, 20)</span>
<span class="s">    &gt;&gt;&gt; test == same_test</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; test != same_test</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; hash(test) == hash(same_test)</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; docstring = &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print 42</span>
<span class="s">    ...     42</span>
<span class="s">    ... &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; other_test = parser.get_doctest(docstring, globs, &#39;other_test&#39;,</span>
<span class="s">    ...                                 &#39;other_file&#39;, 10)</span>
<span class="s">    &gt;&gt;&gt; test == other_test</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; test != other_test</span>
<span class="s">    True</span>

<span class="s">Compare `DocTestCase`:</span>

<span class="s">    &gt;&gt;&gt; DocTestCase = doctest.DocTestCase</span>
<span class="s">    &gt;&gt;&gt; test_case = DocTestCase(test)</span>
<span class="s">    &gt;&gt;&gt; same_test_case = DocTestCase(same_test)</span>
<span class="s">    &gt;&gt;&gt; other_test_case = DocTestCase(other_test)</span>
<span class="s">    &gt;&gt;&gt; test_case == same_test_case</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; test_case != same_test_case</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; hash(test_case) == hash(same_test_case)</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; test == other_test_case</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; test != other_test_case</span>
<span class="s">    True</span>

<span class="s">&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocTestFinder"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestFinder">[docs]</a><span class="k">class</span> <span class="nc">test_DocTestFinder</span><span class="p">:</span>
<div class="viewcode-block" id="test_DocTestFinder.basics"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestFinder.basics">[docs]</a>    <span class="k">def</span> <span class="nf">basics</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for the `DocTestFinder` class.</span>

<span class="s">DocTestFinder is used to extract DocTests from an object&#39;s docstring</span>
<span class="s">and the docstrings of its contained objects.  It can be used with</span>
<span class="s">modules, functions, classes, methods, staticmethods, classmethods, and</span>
<span class="s">properties.</span>

<span class="s">Finding Tests in Functions</span>
<span class="s">~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="s">For a function whose docstring contains examples, DocTestFinder.find()</span>
<span class="s">will return a single test (for that function&#39;s docstring):</span>

<span class="s">    &gt;&gt;&gt; finder = doctest.DocTestFinder()</span>

<span class="s">We&#39;ll simulate a __file__ attr that ends in pyc:</span>

<span class="s">    &gt;&gt;&gt; import test.test_doctest</span>
<span class="s">    &gt;&gt;&gt; old = test.test_doctest.__file__</span>
<span class="s">    &gt;&gt;&gt; test.test_doctest.__file__ = &#39;test_doctest.pyc&#39;</span>

<span class="s">    &gt;&gt;&gt; tests = finder.find(sample_func)</span>

<span class="s">    &gt;&gt;&gt; print(tests)  # doctest: +ELLIPSIS</span>
<span class="s">    [&lt;DocTest sample_func from ...:18 (1 example)&gt;]</span>

<span class="s">The exact name depends on how test_doctest was invoked, so allow for</span>
<span class="s">leading path components.</span>

<span class="s">    &gt;&gt;&gt; tests[0].filename # doctest: +ELLIPSIS</span>
<span class="s">    &#39;...test_doctest.py&#39;</span>

<span class="s">    &gt;&gt;&gt; test.test_doctest.__file__ = old</span>


<span class="s">    &gt;&gt;&gt; e = tests[0].examples[0]</span>
<span class="s">    &gt;&gt;&gt; (e.source, e.want, e.lineno)</span>
<span class="s">    (&#39;print(sample_func(22))\n&#39;, &#39;44\n&#39;, 3)</span>

<span class="s">By default, tests are created for objects with no docstring:</span>

<span class="s">    &gt;&gt;&gt; def no_docstring(v):</span>
<span class="s">    ...     pass</span>
<span class="s">    &gt;&gt;&gt; finder.find(no_docstring)</span>
<span class="s">    []</span>

<span class="s">However, the optional argument `exclude_empty` to the DocTestFinder</span>
<span class="s">constructor can be used to exclude tests for objects with empty</span>
<span class="s">docstrings:</span>

<span class="s">    &gt;&gt;&gt; def no_docstring(v):</span>
<span class="s">    ...     pass</span>
<span class="s">    &gt;&gt;&gt; excl_empty_finder = doctest.DocTestFinder(exclude_empty=True)</span>
<span class="s">    &gt;&gt;&gt; excl_empty_finder.find(no_docstring)</span>
<span class="s">    []</span>

<span class="s">If the function has a docstring with no examples, then a test with no</span>
<span class="s">examples is returned.  (This lets `DocTestRunner` collect statistics</span>
<span class="s">about which functions have no tests -- but is that useful?  And should</span>
<span class="s">an empty test also be created when there&#39;s no docstring?)</span>

<span class="s">    &gt;&gt;&gt; def no_examples(v):</span>
<span class="s">    ...     &#39;&#39;&#39; no doctest examples &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; finder.find(no_examples) # doctest: +ELLIPSIS</span>
<span class="s">    [&lt;DocTest no_examples from ...:1 (no examples)&gt;]</span>

<span class="s">Finding Tests in Classes</span>
<span class="s">~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="s">For a class, DocTestFinder will create a test for the class&#39;s</span>
<span class="s">docstring, and will recursively explore its contents, including</span>
<span class="s">methods, classmethods, staticmethods, properties, and nested classes.</span>

<span class="s">    &gt;&gt;&gt; finder = doctest.DocTestFinder()</span>
<span class="s">    &gt;&gt;&gt; tests = finder.find(SampleClass)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     3  SampleClass</span>
<span class="s">     3  SampleClass.NestedClass</span>
<span class="s">     1  SampleClass.NestedClass.__init__</span>
<span class="s">     1  SampleClass.__init__</span>
<span class="s">     2  SampleClass.a_classmethod</span>
<span class="s">     1  SampleClass.a_property</span>
<span class="s">     1  SampleClass.a_staticmethod</span>
<span class="s">     1  SampleClass.double</span>
<span class="s">     1  SampleClass.get</span>

<span class="s">New-style classes are also supported:</span>

<span class="s">    &gt;&gt;&gt; tests = finder.find(SampleNewStyleClass)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     1  SampleNewStyleClass</span>
<span class="s">     1  SampleNewStyleClass.__init__</span>
<span class="s">     1  SampleNewStyleClass.double</span>
<span class="s">     1  SampleNewStyleClass.get</span>

<span class="s">Finding Tests in Modules</span>
<span class="s">~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="s">For a module, DocTestFinder will create a test for the class&#39;s</span>
<span class="s">docstring, and will recursively explore its contents, including</span>
<span class="s">functions, classes, and the `__test__` dictionary, if it exists:</span>

<span class="s">    &gt;&gt;&gt; # A module</span>
<span class="s">    &gt;&gt;&gt; import types</span>
<span class="s">    &gt;&gt;&gt; m = types.ModuleType(&#39;some_module&#39;)</span>
<span class="s">    &gt;&gt;&gt; def triple(val):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(triple(11))</span>
<span class="s">    ...     33</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     return val*3</span>
<span class="s">    &gt;&gt;&gt; m.__dict__.update({</span>
<span class="s">    ...     &#39;sample_func&#39;: sample_func,</span>
<span class="s">    ...     &#39;SampleClass&#39;: SampleClass,</span>
<span class="s">    ...     &#39;__doc__&#39;: &#39;&#39;&#39;</span>
<span class="s">    ...         Module docstring.</span>
<span class="s">    ...             &gt;&gt;&gt; print(&#39;module&#39;)</span>
<span class="s">    ...             module</span>
<span class="s">    ...         &#39;&#39;&#39;,</span>
<span class="s">    ...     &#39;__test__&#39;: {</span>
<span class="s">    ...         &#39;d&#39;: &#39;&gt;&gt;&gt; print(6)\n6\n&gt;&gt;&gt; print(7)\n7\n&#39;,</span>
<span class="s">    ...         &#39;c&#39;: triple}})</span>

<span class="s">    &gt;&gt;&gt; finder = doctest.DocTestFinder()</span>
<span class="s">    &gt;&gt;&gt; # Use module=test.test_doctest, to prevent doctest from</span>
<span class="s">    &gt;&gt;&gt; # ignoring the objects since they weren&#39;t defined in m.</span>
<span class="s">    &gt;&gt;&gt; import test.test_doctest</span>
<span class="s">    &gt;&gt;&gt; tests = finder.find(m, module=test.test_doctest)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     1  some_module</span>
<span class="s">     3  some_module.SampleClass</span>
<span class="s">     3  some_module.SampleClass.NestedClass</span>
<span class="s">     1  some_module.SampleClass.NestedClass.__init__</span>
<span class="s">     1  some_module.SampleClass.__init__</span>
<span class="s">     2  some_module.SampleClass.a_classmethod</span>
<span class="s">     1  some_module.SampleClass.a_property</span>
<span class="s">     1  some_module.SampleClass.a_staticmethod</span>
<span class="s">     1  some_module.SampleClass.double</span>
<span class="s">     1  some_module.SampleClass.get</span>
<span class="s">     1  some_module.__test__.c</span>
<span class="s">     2  some_module.__test__.d</span>
<span class="s">     1  some_module.sample_func</span>

<span class="s">Duplicate Removal</span>
<span class="s">~~~~~~~~~~~~~~~~~</span>
<span class="s">If a single object is listed twice (under different names), then tests</span>
<span class="s">will only be generated for it once:</span>

<span class="s">    &gt;&gt;&gt; from test import doctest_aliases</span>
<span class="s">    &gt;&gt;&gt; assert doctest_aliases.TwoNames.f</span>
<span class="s">    &gt;&gt;&gt; assert doctest_aliases.TwoNames.g</span>
<span class="s">    &gt;&gt;&gt; tests = excl_empty_finder.find(doctest_aliases)</span>
<span class="s">    &gt;&gt;&gt; print(len(tests))</span>
<span class="s">    2</span>
<span class="s">    &gt;&gt;&gt; print(tests[0].name)</span>
<span class="s">    test.doctest_aliases.TwoNames</span>

<span class="s">    TwoNames.f and TwoNames.g are bound to the same object.</span>
<span class="s">    We can&#39;t guess which will be found in doctest&#39;s traversal of</span>
<span class="s">    TwoNames.__dict__ first, so we have to allow for either.</span>

<span class="s">    &gt;&gt;&gt; tests[1].name.split(&#39;.&#39;)[-1] in [&#39;f&#39;, &#39;g&#39;]</span>
<span class="s">    True</span>

<span class="s">Empty Tests</span>
<span class="s">~~~~~~~~~~~</span>
<span class="s">By default, an object with no doctests doesn&#39;t create any tests:</span>

<span class="s">    &gt;&gt;&gt; tests = doctest.DocTestFinder().find(SampleClass)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     3  SampleClass</span>
<span class="s">     3  SampleClass.NestedClass</span>
<span class="s">     1  SampleClass.NestedClass.__init__</span>
<span class="s">     1  SampleClass.__init__</span>
<span class="s">     2  SampleClass.a_classmethod</span>
<span class="s">     1  SampleClass.a_property</span>
<span class="s">     1  SampleClass.a_staticmethod</span>
<span class="s">     1  SampleClass.double</span>
<span class="s">     1  SampleClass.get</span>

<span class="s">By default, that excluded objects with no doctests.  exclude_empty=False</span>
<span class="s">tells it to include (empty) tests for objects with no doctests.  This feature</span>
<span class="s">is really to support backward compatibility in what doctest.master.summarize()</span>
<span class="s">displays.</span>

<span class="s">    &gt;&gt;&gt; tests = doctest.DocTestFinder(exclude_empty=False).find(SampleClass)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     3  SampleClass</span>
<span class="s">     3  SampleClass.NestedClass</span>
<span class="s">     1  SampleClass.NestedClass.__init__</span>
<span class="s">     0  SampleClass.NestedClass.get</span>
<span class="s">     0  SampleClass.NestedClass.square</span>
<span class="s">     1  SampleClass.__init__</span>
<span class="s">     2  SampleClass.a_classmethod</span>
<span class="s">     1  SampleClass.a_property</span>
<span class="s">     1  SampleClass.a_staticmethod</span>
<span class="s">     1  SampleClass.double</span>
<span class="s">     1  SampleClass.get</span>

<span class="s">Turning off Recursion</span>
<span class="s">~~~~~~~~~~~~~~~~~~~~~</span>
<span class="s">DocTestFinder can be told not to look for tests in contained objects</span>
<span class="s">using the `recurse` flag:</span>

<span class="s">    &gt;&gt;&gt; tests = doctest.DocTestFinder(recurse=False).find(SampleClass)</span>
<span class="s">    &gt;&gt;&gt; for t in tests:</span>
<span class="s">    ...     print(&#39;</span><span class="si">%2s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39; % (len(t.examples), t.name))</span>
<span class="s">     3  SampleClass</span>

<span class="s">Line numbers</span>
<span class="s">~~~~~~~~~~~~</span>
<span class="s">DocTestFinder finds the line number of each example:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...</span>
<span class="s">    ...     some text</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; # examples are not created for comments &amp; bare prompts.</span>
<span class="s">    ...     &gt;&gt;&gt;</span>
<span class="s">    ...     ...</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; for x in range(10):</span>
<span class="s">    ...     ...     print(x, end=&#39; &#39;)</span>
<span class="s">    ...     0 1 2 3 4 5 6 7 8 9</span>
<span class="s">    ...     &gt;&gt;&gt; x//2</span>
<span class="s">    ...     6</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; [e.lineno for e in test.examples]</span>
<span class="s">    [1, 9, 12]</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
    <span class="k">if</span> <span class="nb">int</span><span class="o">.</span><span class="n">__doc__</span><span class="p">:</span> <span class="c"># simple check for --without-doc-strings, skip if lacking</span>
<div class="viewcode-block" id="test_DocTestFinder.non_Python_modules"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestFinder.non_Python_modules">[docs]</a>        <span class="k">def</span> <span class="nf">non_Python_modules</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>

<span class="s">Finding Doctests in Modules Not Written in Python</span>
<span class="s">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="s">DocTestFinder can also find doctests in most modules not written in Python.</span>
<span class="s">We&#39;ll use builtins as an example, since it almost certainly isn&#39;t written in</span>
<span class="s">plain ol&#39; Python and is guaranteed to be available.</span>

<span class="s">    &gt;&gt;&gt; import builtins</span>
<span class="s">    &gt;&gt;&gt; tests = doctest.DocTestFinder().find(builtins)</span>
<span class="s">    &gt;&gt;&gt; 790 &lt; len(tests) &lt; 800 # approximate number of objects with docstrings</span>
<span class="s">    True</span>
<span class="s">    &gt;&gt;&gt; real_tests = [t for t in tests if len(t.examples) &gt; 0]</span>
<span class="s">    &gt;&gt;&gt; len(real_tests) # objects that actually have doctests</span>
<span class="s">    8</span>
<span class="s">    &gt;&gt;&gt; for t in real_tests:</span>
<span class="s">    ...     print(&#39;{}  {}&#39;.format(len(t.examples), t.name))</span>
<span class="s">    ...</span>
<span class="s">    1  builtins.bin</span>
<span class="s">    3  builtins.float.as_integer_ratio</span>
<span class="s">    2  builtins.float.fromhex</span>
<span class="s">    2  builtins.float.hex</span>
<span class="s">    1  builtins.hex</span>
<span class="s">    1  builtins.int</span>
<span class="s">    2  builtins.int.bit_length</span>
<span class="s">    1  builtins.oct</span>

<span class="s">Note here that &#39;bin&#39;, &#39;oct&#39;, and &#39;hex&#39; are functions; &#39;float.as_integer_ratio&#39;,</span>
<span class="s">&#39;float.hex&#39;, and &#39;int.bit_length&#39; are methods; &#39;float.fromhex&#39; is a classmethod,</span>
<span class="s">and &#39;int&#39; is a type.</span>
<span class="s">&quot;&quot;&quot;</span>
</div></div>
<div class="viewcode-block" id="test_DocTestParser"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestParser">[docs]</a><span class="k">def</span> <span class="nf">test_DocTestParser</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for the `DocTestParser` class.</span>

<span class="s">DocTestParser is used to parse docstrings containing doctest examples.</span>

<span class="s">The `parse` method divides a docstring into examples and intervening</span>
<span class="s">text:</span>

<span class="s">    &gt;&gt;&gt; s = &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x, y = 2, 3  # no output expected</span>
<span class="s">    ...     &gt;&gt;&gt; if 1:</span>
<span class="s">    ...     ...     print(x)</span>
<span class="s">    ...     ...     print(y)</span>
<span class="s">    ...     2</span>
<span class="s">    ...     3</span>
<span class="s">    ...</span>
<span class="s">    ...     Some text.</span>
<span class="s">    ...     &gt;&gt;&gt; x+y</span>
<span class="s">    ...     5</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; parser = doctest.DocTestParser()</span>
<span class="s">    &gt;&gt;&gt; for piece in parser.parse(s):</span>
<span class="s">    ...     if isinstance(piece, doctest.Example):</span>
<span class="s">    ...         print(&#39;Example:&#39;, (piece.source, piece.want, piece.lineno))</span>
<span class="s">    ...     else:</span>
<span class="s">    ...         print(&#39;   Text:&#39;, repr(piece))</span>
<span class="s">       Text: &#39;\n&#39;</span>
<span class="s">    Example: (&#39;x, y = 2, 3  # no output expected\n&#39;, &#39;&#39;, 1)</span>
<span class="s">       Text: &#39;&#39;</span>
<span class="s">    Example: (&#39;if 1:\n    print(x)\n    print(y)\n&#39;, &#39;2\n3\n&#39;, 2)</span>
<span class="s">       Text: &#39;\nSome text.\n&#39;</span>
<span class="s">    Example: (&#39;x+y\n&#39;, &#39;5\n&#39;, 9)</span>
<span class="s">       Text: &#39;&#39;</span>

<span class="s">The `get_examples` method returns just the examples:</span>

<span class="s">    &gt;&gt;&gt; for piece in parser.get_examples(s):</span>
<span class="s">    ...     print((piece.source, piece.want, piece.lineno))</span>
<span class="s">    (&#39;x, y = 2, 3  # no output expected\n&#39;, &#39;&#39;, 1)</span>
<span class="s">    (&#39;if 1:\n    print(x)\n    print(y)\n&#39;, &#39;2\n3\n&#39;, 2)</span>
<span class="s">    (&#39;x+y\n&#39;, &#39;5\n&#39;, 9)</span>

<span class="s">The `get_doctest` method creates a Test from the examples, along with the</span>
<span class="s">given arguments:</span>

<span class="s">    &gt;&gt;&gt; test = parser.get_doctest(s, {}, &#39;name&#39;, &#39;filename&#39;, lineno=5)</span>
<span class="s">    &gt;&gt;&gt; (test.name, test.filename, test.lineno)</span>
<span class="s">    (&#39;name&#39;, &#39;filename&#39;, 5)</span>
<span class="s">    &gt;&gt;&gt; for piece in test.examples:</span>
<span class="s">    ...     print((piece.source, piece.want, piece.lineno))</span>
<span class="s">    (&#39;x, y = 2, 3  # no output expected\n&#39;, &#39;&#39;, 1)</span>
<span class="s">    (&#39;if 1:\n    print(x)\n    print(y)\n&#39;, &#39;2\n3\n&#39;, 2)</span>
<span class="s">    (&#39;x+y\n&#39;, &#39;5\n&#39;, 9)</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocTestRunner"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner">[docs]</a><span class="k">class</span> <span class="nc">test_DocTestRunner</span><span class="p">:</span>
<div class="viewcode-block" id="test_DocTestRunner.basics"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.basics">[docs]</a>    <span class="k">def</span> <span class="nf">basics</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for the `DocTestRunner` class.</span>

<span class="s">DocTestRunner is used to run DocTest test cases, and to accumulate</span>
<span class="s">statistics.  Here&#39;s a simple DocTest case we can use:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(x)</span>
<span class="s">    ...     12</span>
<span class="s">    ...     &gt;&gt;&gt; x//2</span>
<span class="s">    ...     6</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>

<span class="s">The main DocTestRunner interface is the `run` method, which runs a</span>
<span class="s">given DocTest case in a given namespace (globs).  It returns a tuple</span>
<span class="s">`(f,t)`, where `f` is the number of failed tests and `t` is the number</span>
<span class="s">of tried tests.</span>

<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=3)</span>

<span class="s">If any example produces incorrect output, then the test runner reports</span>
<span class="s">the failure and proceeds to the next example:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(x)</span>
<span class="s">    ...     14</span>
<span class="s">    ...     &gt;&gt;&gt; x//2</span>
<span class="s">    ...     6</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=True).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    Trying:</span>
<span class="s">        x = 12</span>
<span class="s">    Expecting nothing</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        print(x)</span>
<span class="s">    Expecting:</span>
<span class="s">        14</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 4, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(x)</span>
<span class="s">    Expected:</span>
<span class="s">        14</span>
<span class="s">    Got:</span>
<span class="s">        12</span>
<span class="s">    Trying:</span>
<span class="s">        x//2</span>
<span class="s">    Expecting:</span>
<span class="s">        6</span>
<span class="s">    ok</span>
<span class="s">    TestResults(failed=1, attempted=3)</span>
<span class="s">&quot;&quot;&quot;</span></div>
<div class="viewcode-block" id="test_DocTestRunner.verbose_flag"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.verbose_flag">[docs]</a>    <span class="k">def</span> <span class="nf">verbose_flag</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">The `verbose` flag makes the test runner generate more detailed</span>
<span class="s">output:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(x)</span>
<span class="s">    ...     12</span>
<span class="s">    ...     &gt;&gt;&gt; x//2</span>
<span class="s">    ...     6</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>

<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=True).run(test)</span>
<span class="s">    Trying:</span>
<span class="s">        x = 12</span>
<span class="s">    Expecting nothing</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        print(x)</span>
<span class="s">    Expecting:</span>
<span class="s">        12</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        x//2</span>
<span class="s">    Expecting:</span>
<span class="s">        6</span>
<span class="s">    ok</span>
<span class="s">    TestResults(failed=0, attempted=3)</span>

<span class="s">If the `verbose` flag is unspecified, then the output will be verbose</span>
<span class="s">iff `-v` appears in sys.argv:</span>

<span class="s">    &gt;&gt;&gt; # Save the real sys.argv list.</span>
<span class="s">    &gt;&gt;&gt; old_argv = sys.argv</span>

<span class="s">    &gt;&gt;&gt; # If -v does not appear in sys.argv, then output isn&#39;t verbose.</span>
<span class="s">    &gt;&gt;&gt; sys.argv = [&#39;test&#39;]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner().run(test)</span>
<span class="s">    TestResults(failed=0, attempted=3)</span>

<span class="s">    &gt;&gt;&gt; # If -v does appear in sys.argv, then output is verbose.</span>
<span class="s">    &gt;&gt;&gt; sys.argv = [&#39;test&#39;, &#39;-v&#39;]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner().run(test)</span>
<span class="s">    Trying:</span>
<span class="s">        x = 12</span>
<span class="s">    Expecting nothing</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        print(x)</span>
<span class="s">    Expecting:</span>
<span class="s">        12</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        x//2</span>
<span class="s">    Expecting:</span>
<span class="s">        6</span>
<span class="s">    ok</span>
<span class="s">    TestResults(failed=0, attempted=3)</span>

<span class="s">    &gt;&gt;&gt; # Restore sys.argv</span>
<span class="s">    &gt;&gt;&gt; sys.argv = old_argv</span>

<span class="s">In the remaining examples, the test runner&#39;s verbosity will be</span>
<span class="s">explicitly set, to ensure that the test behavior is consistent.</span>
<span class="s">    &quot;&quot;&quot;</span></div>
<div class="viewcode-block" id="test_DocTestRunner.exceptions"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.exceptions">[docs]</a>    <span class="k">def</span> <span class="nf">exceptions</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Tests of `DocTestRunner`&#39;s exception handling.</span>

<span class="s">An expected exception is specified with a traceback message.  The</span>
<span class="s">lines between the first line and the type/value may be omitted or</span>
<span class="s">replaced with any other string:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(x//0)</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     ZeroDivisionError: integer division or modulo by zero</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">An example may not generate output before it raises an exception; if</span>
<span class="s">it does, then the traceback message will not be recognized as</span>
<span class="s">signaling an expected exception, so the example will be reported as an</span>
<span class="s">unexpected exception:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(&#39;pre-exception output&#39;, x//0)</span>
<span class="s">    ...     pre-exception output</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     ZeroDivisionError: integer division or modulo by zero</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 4, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&#39;pre-exception output&#39;, x//0)</span>
<span class="s">    Exception raised:</span>
<span class="s">        ...</span>
<span class="s">        ZeroDivisionError: integer division or modulo by zero</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">Exception messages may contain newlines:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; raise ValueError(&#39;multi\nline\nmessage&#39;)</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     ValueError: multi</span>
<span class="s">    ...     line</span>
<span class="s">    ...     message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">If an exception is expected, but an exception with the wrong type or</span>
<span class="s">message is raised, then it is reported as a failure:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; raise ValueError(&#39;message&#39;)</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     ValueError: wrong message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        raise ValueError(&#39;message&#39;)</span>
<span class="s">    Expected:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        ValueError: wrong message</span>
<span class="s">    Got:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        ...</span>
<span class="s">        ValueError: message</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">However, IGNORE_EXCEPTION_DETAIL can be used to allow a mismatch in the</span>
<span class="s">detail:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; raise ValueError(&#39;message&#39;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     ValueError: wrong message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">IGNORE_EXCEPTION_DETAIL also ignores difference in exception formatting</span>
<span class="s">between Python versions. For example, in Python 2.x, the module path of</span>
<span class="s">the exception is not in the output, but this will fail under Python 3:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException(&#39;message&#39;)</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     HTTPException: message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 4, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        raise HTTPException(&#39;message&#39;)</span>
<span class="s">    Expected:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        HTTPException: message</span>
<span class="s">    Got:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        ...</span>
<span class="s">        http.client.HTTPException: message</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">But in Python 3 the module path is included, and therefore a test must look</span>
<span class="s">like the following test to succeed in Python 3. But that test will fail under</span>
<span class="s">Python 2.</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException(&#39;message&#39;)</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     http.client.HTTPException: message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">However, with IGNORE_EXCEPTION_DETAIL, the module name of the exception</span>
<span class="s">(or its unexpected absence) will be ignored:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException(&#39;message&#39;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     HTTPException: message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">The module path will be completely ignored, so two different module paths will</span>
<span class="s">still pass if IGNORE_EXCEPTION_DETAIL is given. This is intentional, so it can</span>
<span class="s">be used when exceptions have changed module.</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException(&#39;message&#39;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     foo.bar.HTTPException: message</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">But IGNORE_EXCEPTION_DETAIL does not allow a mismatch in the exception type:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; raise ValueError(&#39;message&#39;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     TypeError: wrong type</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        raise ValueError(&#39;message&#39;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    Expected:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        TypeError: wrong type</span>
<span class="s">    Got:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        ...</span>
<span class="s">        ValueError: message</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">If the exception does not have a message, you can still use</span>
<span class="s">IGNORE_EXCEPTION_DETAIL to normalize the modules between Python 2 and 3:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException() #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     foo.bar.HTTPException</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">Note that a trailing colon doesn&#39;t matter either:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; from http.client import HTTPException</span>
<span class="s">    ...     &gt;&gt;&gt; raise HTTPException() #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="s">    ...     Traceback (most recent call last):</span>
<span class="s">    ...     foo.bar.HTTPException:</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">If an exception is raised but not expected, then it is reported as an</span>
<span class="s">unexpected exception:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; 1//0</span>
<span class="s">    ...     0</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        1//0</span>
<span class="s">    Exception raised:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">        ...</span>
<span class="s">        ZeroDivisionError: integer division or modulo by zero</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>
<span class="s">&quot;&quot;&quot;</span></div>
<div class="viewcode-block" id="test_DocTestRunner.displayhook"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.displayhook">[docs]</a>    <span class="k">def</span> <span class="nf">displayhook</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Test that changing sys.displayhook doesn&#39;t matter for doctest.</span>

<span class="s">    &gt;&gt;&gt; import sys</span>
<span class="s">    &gt;&gt;&gt; orig_displayhook = sys.displayhook</span>
<span class="s">    &gt;&gt;&gt; def my_displayhook(x):</span>
<span class="s">    ...     print(&#39;hi!&#39;)</span>
<span class="s">    &gt;&gt;&gt; sys.displayhook = my_displayhook</span>
<span class="s">    &gt;&gt;&gt; def f():</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; 3</span>
<span class="s">    ...     3</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; r = doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    &gt;&gt;&gt; post_displayhook = sys.displayhook</span>

<span class="s">    We need to restore sys.displayhook now, so that we&#39;ll be able to test</span>
<span class="s">    results.</span>

<span class="s">    &gt;&gt;&gt; sys.displayhook = orig_displayhook</span>

<span class="s">    Ok, now we can check that everything is ok.</span>

<span class="s">    &gt;&gt;&gt; r</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>
<span class="s">    &gt;&gt;&gt; post_displayhook is my_displayhook</span>
<span class="s">    True</span>
<span class="s">&quot;&quot;&quot;</span></div>
<div class="viewcode-block" id="test_DocTestRunner.optionflags"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.optionflags">[docs]</a>    <span class="k">def</span> <span class="nf">optionflags</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Tests of `DocTestRunner`&#39;s option flag handling.</span>

<span class="s">Several option flags can be used to customize the behavior of the test</span>
<span class="s">runner.  These are defined as module constants in doctest, and passed</span>
<span class="s">to the DocTestRunner constructor (multiple constants should be ORed</span>
<span class="s">together).</span>

<span class="s">The DONT_ACCEPT_TRUE_FOR_1 flag disables matches between True/False</span>
<span class="s">and 1/0:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&gt;&gt;&gt; True\n1\n&#39;</span>

<span class="s">    &gt;&gt;&gt; # Without the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">    &gt;&gt;&gt; # With the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.DONT_ACCEPT_TRUE_FOR_1</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        True</span>
<span class="s">    Expected:</span>
<span class="s">        1</span>
<span class="s">    Got:</span>
<span class="s">        True</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">The DONT_ACCEPT_BLANKLINE flag disables the match between blank lines</span>
<span class="s">and the &#39;&lt;BLANKLINE&gt;&#39; marker:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&gt;&gt;&gt; print(&quot;a\\n\\nb&quot;)\na\n&lt;BLANKLINE&gt;\nb\n&#39;</span>

<span class="s">    &gt;&gt;&gt; # Without the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">    &gt;&gt;&gt; # With the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.DONT_ACCEPT_BLANKLINE</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&quot;a\n\nb&quot;)</span>
<span class="s">    Expected:</span>
<span class="s">        a</span>
<span class="s">        &lt;BLANKLINE&gt;</span>
<span class="s">        b</span>
<span class="s">    Got:</span>
<span class="s">        a</span>
<span class="s">    &lt;BLANKLINE&gt;</span>
<span class="s">        b</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">The NORMALIZE_WHITESPACE flag causes all sequences of whitespace to be</span>
<span class="s">treated as equal:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&gt;&gt;&gt; print(1, 2, 3)\n  1   2\n 3&#39;</span>

<span class="s">    &gt;&gt;&gt; # Without the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(1, 2, 3)</span>
<span class="s">    Expected:</span>
<span class="s">          1   2</span>
<span class="s">         3</span>
<span class="s">    Got:</span>
<span class="s">        1 2 3</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">    &gt;&gt;&gt; # With the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.NORMALIZE_WHITESPACE</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">    An example from the docs:</span>
<span class="s">    &gt;&gt;&gt; print(list(range(20))) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="s">    [0,   1,  2,  3,  4,  5,  6,  7,  8,  9,</span>
<span class="s">    10,  11, 12, 13, 14, 15, 16, 17, 18, 19]</span>

<span class="s">The ELLIPSIS flag causes ellipsis marker (&quot;...&quot;) in the expected</span>
<span class="s">output to match any substring in the actual output:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     &#39;&gt;&gt;&gt; print(list(range(15)))\n[0, 1, 2, ..., 14]\n&#39;</span>

<span class="s">    &gt;&gt;&gt; # Without the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(15)))</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1, 2, ..., 14]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">    &gt;&gt;&gt; # With the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.ELLIPSIS</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">    ... also matches nothing:</span>

<span class="s">    &gt;&gt;&gt; if 1:</span>
<span class="s">    ...     for i in range(100):</span>
<span class="s">    ...         print(i**2, end=&#39; &#39;) #doctest: +ELLIPSIS</span>
<span class="s">    ...     print(&#39;!&#39;)</span>
<span class="s">    0 1...4...9 16 ... 36 49 64 ... 9801 !</span>

<span class="s">    ... can be surprising; e.g., this test passes:</span>

<span class="s">    &gt;&gt;&gt; if 1:  #doctest: +ELLIPSIS</span>
<span class="s">    ...     for i in range(20):</span>
<span class="s">    ...         print(i, end=&#39; &#39;)</span>
<span class="s">    ...     print(20)</span>
<span class="s">    0 1 2 ...1...2...0</span>

<span class="s">    Examples from the docs:</span>

<span class="s">    &gt;&gt;&gt; print(list(range(20))) # doctest:+ELLIPSIS</span>
<span class="s">    [0, 1, ..., 18, 19]</span>

<span class="s">    &gt;&gt;&gt; print(list(range(20))) # doctest: +ELLIPSIS</span>
<span class="s">    ...                 # doctest: +NORMALIZE_WHITESPACE</span>
<span class="s">    [0,    1, ...,   18,    19]</span>

<span class="s">The SKIP flag causes an example to be skipped entirely.  I.e., the</span>
<span class="s">example is not run.  It can be useful in contexts where doctest</span>
<span class="s">examples serve as both documentation and test cases, and an example</span>
<span class="s">should be included for documentation purposes, but should not be</span>
<span class="s">checked (e.g., because its output is random, or depends on resources</span>
<span class="s">which would be unavailable.)  The SKIP flag can also be used for</span>
<span class="s">&#39;commenting out&#39; broken examples.</span>

<span class="s">    &gt;&gt;&gt; import unavailable_resource           # doctest: +SKIP</span>
<span class="s">    &gt;&gt;&gt; unavailable_resource.do_something()   # doctest: +SKIP</span>
<span class="s">    &gt;&gt;&gt; unavailable_resource.blow_up()        # doctest: +SKIP</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">        ...</span>
<span class="s">    UncheckedBlowUpError:  Nobody checks me.</span>

<span class="s">    &gt;&gt;&gt; import random</span>
<span class="s">    &gt;&gt;&gt; print(random.random()) # doctest: +SKIP</span>
<span class="s">    0.721216923889</span>

<span class="s">The REPORT_UDIFF flag causes failures that involve multi-line expected</span>
<span class="s">and actual outputs to be displayed using a unified diff:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(&#39;\n&#39;.join(&#39;abcdefg&#39;))</span>
<span class="s">    ...     a</span>
<span class="s">    ...     B</span>
<span class="s">    ...     c</span>
<span class="s">    ...     d</span>
<span class="s">    ...     f</span>
<span class="s">    ...     g</span>
<span class="s">    ...     h</span>
<span class="s">    ...     &#39;&#39;&#39;</span>

<span class="s">    &gt;&gt;&gt; # Without the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&#39;\n&#39;.join(&#39;abcdefg&#39;))</span>
<span class="s">    Expected:</span>
<span class="s">        a</span>
<span class="s">        B</span>
<span class="s">        c</span>
<span class="s">        d</span>
<span class="s">        f</span>
<span class="s">        g</span>
<span class="s">        h</span>
<span class="s">    Got:</span>
<span class="s">        a</span>
<span class="s">        b</span>
<span class="s">        c</span>
<span class="s">        d</span>
<span class="s">        e</span>
<span class="s">        f</span>
<span class="s">        g</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">    &gt;&gt;&gt; # With the flag:</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.REPORT_UDIFF</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&#39;\n&#39;.join(&#39;abcdefg&#39;))</span>
<span class="s">    Differences (unified diff with -expected +actual):</span>
<span class="s">        @@ -1,7 +1,7 @@</span>
<span class="s">         a</span>
<span class="s">        -B</span>
<span class="s">        +b</span>
<span class="s">         c</span>
<span class="s">         d</span>
<span class="s">        +e</span>
<span class="s">         f</span>
<span class="s">         g</span>
<span class="s">        -h</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">The REPORT_CDIFF flag causes failures that involve multi-line expected</span>
<span class="s">and actual outputs to be displayed using a context diff:</span>

<span class="s">    &gt;&gt;&gt; # Reuse f() from the REPORT_UDIFF example, above.</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.REPORT_CDIFF</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&#39;\n&#39;.join(&#39;abcdefg&#39;))</span>
<span class="s">    Differences (context diff with expected followed by actual):</span>
<span class="s">        ***************</span>
<span class="s">        *** 1,7 ****</span>
<span class="s">          a</span>
<span class="s">        ! B</span>
<span class="s">          c</span>
<span class="s">          d</span>
<span class="s">          f</span>
<span class="s">          g</span>
<span class="s">        - h</span>
<span class="s">        --- 1,7 ----</span>
<span class="s">          a</span>
<span class="s">        ! b</span>
<span class="s">          c</span>
<span class="s">          d</span>
<span class="s">        + e</span>
<span class="s">          f</span>
<span class="s">          g</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>


<span class="s">The REPORT_NDIFF flag causes failures to use the difflib.Differ algorithm</span>
<span class="s">used by the popular ndiff.py utility.  This does intraline difference</span>
<span class="s">marking, as well as interline differences.</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(&quot;a b  c d e f g h i   j k l m&quot;)</span>
<span class="s">    ...     a b c d e f g h i j k 1 m</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.REPORT_NDIFF</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 3, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(&quot;a b  c d e f g h i   j k l m&quot;)</span>
<span class="s">    Differences (ndiff with -expected +actual):</span>
<span class="s">        - a b c d e f g h i j k 1 m</span>
<span class="s">        ?                       ^</span>
<span class="s">        + a b  c d e f g h i   j k l m</span>
<span class="s">        ?     +              ++    ^</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>

<span class="s">The REPORT_ONLY_FIRST_FAILURE suppresses result output after the first</span>
<span class="s">failing example:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(1) # first success</span>
<span class="s">    ...     1</span>
<span class="s">    ...     &gt;&gt;&gt; print(2) # first failure</span>
<span class="s">    ...     200</span>
<span class="s">    ...     &gt;&gt;&gt; print(3) # second failure</span>
<span class="s">    ...     300</span>
<span class="s">    ...     &gt;&gt;&gt; print(4) # second success</span>
<span class="s">    ...     4</span>
<span class="s">    ...     &gt;&gt;&gt; print(5) # third failure</span>
<span class="s">    ...     500</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.REPORT_ONLY_FIRST_FAILURE</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(2) # first failure</span>
<span class="s">    Expected:</span>
<span class="s">        200</span>
<span class="s">    Got:</span>
<span class="s">        2</span>
<span class="s">    TestResults(failed=3, attempted=5)</span>

<span class="s">However, output from `report_start` is not suppressed:</span>

<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=True, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    Trying:</span>
<span class="s">        print(1) # first success</span>
<span class="s">    Expecting:</span>
<span class="s">        1</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        print(2) # first failure</span>
<span class="s">    Expecting:</span>
<span class="s">        200</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(2) # first failure</span>
<span class="s">    Expected:</span>
<span class="s">        200</span>
<span class="s">    Got:</span>
<span class="s">        2</span>
<span class="s">    TestResults(failed=3, attempted=5)</span>

<span class="s">The FAIL_FAST flag causes the runner to exit after the first failing example,</span>
<span class="s">so subsequent examples are not even attempted:</span>

<span class="s">    &gt;&gt;&gt; flags = doctest.FAIL_FAST</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(2) # first failure</span>
<span class="s">    Expected:</span>
<span class="s">        200</span>
<span class="s">    Got:</span>
<span class="s">        2</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">Specifying both FAIL_FAST and REPORT_ONLY_FIRST_FAILURE is equivalent to</span>
<span class="s">FAIL_FAST only:</span>

<span class="s">    &gt;&gt;&gt; flags = doctest.FAIL_FAST | doctest.REPORT_ONLY_FIRST_FAILURE</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(2) # first failure</span>
<span class="s">    Expected:</span>
<span class="s">        200</span>
<span class="s">    Got:</span>
<span class="s">        2</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">For the purposes of both REPORT_ONLY_FIRST_FAILURE and FAIL_FAST, unexpected</span>
<span class="s">exceptions count as failures:</span>

<span class="s">    &gt;&gt;&gt; def f(x):</span>
<span class="s">    ...     r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(1) # first success</span>
<span class="s">    ...     1</span>
<span class="s">    ...     &gt;&gt;&gt; raise ValueError(2) # first failure</span>
<span class="s">    ...     200</span>
<span class="s">    ...     &gt;&gt;&gt; print(3) # second failure</span>
<span class="s">    ...     300</span>
<span class="s">    ...     &gt;&gt;&gt; print(4) # second success</span>
<span class="s">    ...     4</span>
<span class="s">    ...     &gt;&gt;&gt; print(5) # third failure</span>
<span class="s">    ...     500</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.REPORT_ONLY_FIRST_FAILURE</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        raise ValueError(2) # first failure</span>
<span class="s">    Exception raised:</span>
<span class="s">        ...</span>
<span class="s">        ValueError: 2</span>
<span class="s">    TestResults(failed=3, attempted=5)</span>
<span class="s">    &gt;&gt;&gt; flags = doctest.FAIL_FAST</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 5, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        raise ValueError(2) # first failure</span>
<span class="s">    Exception raised:</span>
<span class="s">        ...</span>
<span class="s">        ValueError: 2</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">New option flags can also be registered, via register_optionflag().  Here</span>
<span class="s">we reach into doctest&#39;s internals a bit.</span>

<span class="s">    &gt;&gt;&gt; unlikely = &quot;UNLIKELY_OPTION_NAME&quot;</span>
<span class="s">    &gt;&gt;&gt; unlikely in doctest.OPTIONFLAGS_BY_NAME</span>
<span class="s">    False</span>
<span class="s">    &gt;&gt;&gt; new_flag_value = doctest.register_optionflag(unlikely)</span>
<span class="s">    &gt;&gt;&gt; unlikely in doctest.OPTIONFLAGS_BY_NAME</span>
<span class="s">    True</span>

<span class="s">Before 2.4.4/2.5, registering a name more than once erroneously created</span>
<span class="s">more than one flag value.  Here we verify that&#39;s fixed:</span>

<span class="s">    &gt;&gt;&gt; redundant_flag_value = doctest.register_optionflag(unlikely)</span>
<span class="s">    &gt;&gt;&gt; redundant_flag_value == new_flag_value</span>
<span class="s">    True</span>

<span class="s">Clean up.</span>
<span class="s">    &gt;&gt;&gt; del doctest.OPTIONFLAGS_BY_NAME[unlikely]</span>

<span class="s">    &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocTestRunner.option_directives"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestRunner.option_directives">[docs]</a>    <span class="k">def</span> <span class="nf">option_directives</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Tests of `DocTestRunner`&#39;s option directive mechanism.</span>

<span class="s">Option directives can be used to turn option flags on or off for a</span>
<span class="s">single example.  To turn an option on for an example, follow that</span>
<span class="s">example with a comment of the form ``# doctest: +OPTION``:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # should fail: no ellipsis</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # doctest: +ELLIPSIS</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # should fail: no ellipsis</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1, ..., 9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">To turn an option off for an example, follow that example with a</span>
<span class="s">comment of the form ``# doctest: -OPTION``:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; # should fail: no ellipsis</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # doctest: -ELLIPSIS</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False,</span>
<span class="s">    ...                       optionflags=doctest.ELLIPSIS).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 6, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # doctest: -ELLIPSIS</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1, ..., 9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">Option directives affect only the example that they appear with; they</span>
<span class="s">do not change the options for surrounding examples:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should fail: no ellipsis</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # doctest: +ELLIPSIS</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should fail: no ellipsis</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # Should fail: no ellipsis</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1, ..., 9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 8, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # Should fail: no ellipsis</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1, ..., 9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=2, attempted=3)</span>

<span class="s">Multiple options may be modified by a single option directive.  They</span>
<span class="s">may be separated by whitespace, commas, or both:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should fail</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should succeed</span>
<span class="s">    ...     ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # Should fail</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1,  ...,   9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should fail</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should succeed</span>
<span class="s">    ...     ... # doctest: +ELLIPSIS,+NORMALIZE_WHITESPACE</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # Should fail</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1,  ...,   9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should fail</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))      # Should succeed</span>
<span class="s">    ...     ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="s">    ...     [0, 1,  ...,   9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File ..., line 2, in f</span>
<span class="s">    Failed example:</span>
<span class="s">        print(list(range(10)))      # Should fail</span>
<span class="s">    Expected:</span>
<span class="s">        [0, 1,  ...,   9]</span>
<span class="s">    Got:</span>
<span class="s">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>

<span class="s">The option directive may be put on the line following the source, as</span>
<span class="s">long as a continuation prompt is used:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; print(list(range(10)))</span>
<span class="s">    ...     ... # doctest: +ELLIPSIS</span>
<span class="s">    ...     [0, 1, ..., 9]</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">For examples with multi-line source, the option directive may appear</span>
<span class="s">at the end of any line:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; for x in range(10): # doctest: +ELLIPSIS</span>
<span class="s">    ...     ...     print(&#39; &#39;, x, end=&#39;&#39;, sep=&#39;&#39;)</span>
<span class="s">    ...      0 1 2 ... 9</span>
<span class="s">    ...</span>
<span class="s">    ...     &gt;&gt;&gt; for x in range(10):</span>
<span class="s">    ...     ...     print(&#39; &#39;, x, end=&#39;&#39;, sep=&#39;&#39;) # doctest: +ELLIPSIS</span>
<span class="s">    ...      0 1 2 ... 9</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>

<span class="s">If more than one line of an example with multi-line source has an</span>
<span class="s">option directive, then they are combined:</span>

<span class="s">    &gt;&gt;&gt; def f(x): r&#39;&#39;&#39;</span>
<span class="s">    ...     Should fail (option directive not on the last line):</span>
<span class="s">    ...         &gt;&gt;&gt; for x in range(10): # doctest: +ELLIPSIS</span>
<span class="s">    ...         ...     print(x, end=&#39; &#39;) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="s">    ...         0  1    2...9</span>
<span class="s">    ...     &#39;&#39;&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]</span>
<span class="s">    &gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)</span>
<span class="s">    TestResults(failed=0, attempted=1)</span>

<span class="s">It is an error to have a comment of the form ``# doctest:`` that is</span>
<span class="s">*not* followed by words of the form ``+OPTION`` or ``-OPTION``, where</span>
<span class="s">``OPTION`` is an option that has been registered with</span>
<span class="s">`register_option`:</span>

<span class="s">    &gt;&gt;&gt; # Error: Option not registered</span>
<span class="s">    &gt;&gt;&gt; s = &#39;&gt;&gt;&gt; print(12)  #doctest: +BADOPTION&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestParser().get_doctest(s, {}, &#39;s&#39;, &#39;s.py&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 1 of the doctest for s has an invalid option: &#39;+BADOPTION&#39;</span>

<span class="s">    &gt;&gt;&gt; # Error: No + or - prefix</span>
<span class="s">    &gt;&gt;&gt; s = &#39;&gt;&gt;&gt; print(12)  #doctest: ELLIPSIS&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestParser().get_doctest(s, {}, &#39;s&#39;, &#39;s.py&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 1 of the doctest for s has an invalid option: &#39;ELLIPSIS&#39;</span>

<span class="s">It is an error to use an option directive on a line that contains no</span>
<span class="s">source:</span>

<span class="s">    &gt;&gt;&gt; s = &#39;&gt;&gt;&gt; # doctest: +ELLIPSIS&#39;</span>
<span class="s">    &gt;&gt;&gt; test = doctest.DocTestParser().get_doctest(s, {}, &#39;s&#39;, &#39;s.py&#39;, 0)</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    ValueError: line 0 of the doctest for s has an option directive on a line with no example: &#39;# doctest: +ELLIPSIS&#39;</span>
<span class="s">&quot;&quot;&quot;</span>
</div></div>
<div class="viewcode-block" id="test_testsource"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_testsource">[docs]</a><span class="k">def</span> <span class="nf">test_testsource</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Unit tests for `testsource()`.</span>

<span class="s">The testsource() function takes a module and a name, finds the (first)</span>
<span class="s">test with that name in that module, and converts it to a script. The</span>
<span class="s">example code is converted to regular Python code.  The surrounding</span>
<span class="s">words and expected output are converted to comments:</span>

<span class="s">    &gt;&gt;&gt; import test.test_doctest</span>
<span class="s">    &gt;&gt;&gt; name = &#39;test.test_doctest.sample_func&#39;</span>
<span class="s">    &gt;&gt;&gt; print(doctest.testsource(test.test_doctest, name))</span>
<span class="s">    # Blah blah</span>
<span class="s">    #</span>
<span class="s">    print(sample_func(22))</span>
<span class="s">    # Expected:</span>
<span class="s">    ## 44</span>
<span class="s">    #</span>
<span class="s">    # Yee ha!</span>
<span class="s">    &lt;BLANKLINE&gt;</span>

<span class="s">    &gt;&gt;&gt; name = &#39;test.test_doctest.SampleNewStyleClass&#39;</span>
<span class="s">    &gt;&gt;&gt; print(doctest.testsource(test.test_doctest, name))</span>
<span class="s">    print(&#39;1\n2\n3&#39;)</span>
<span class="s">    # Expected:</span>
<span class="s">    ## 1</span>
<span class="s">    ## 2</span>
<span class="s">    ## 3</span>
<span class="s">    &lt;BLANKLINE&gt;</span>

<span class="s">    &gt;&gt;&gt; name = &#39;test.test_doctest.SampleClass.a_classmethod&#39;</span>
<span class="s">    &gt;&gt;&gt; print(doctest.testsource(test.test_doctest, name))</span>
<span class="s">    print(SampleClass.a_classmethod(10))</span>
<span class="s">    # Expected:</span>
<span class="s">    ## 12</span>
<span class="s">    print(SampleClass(0).a_classmethod(10))</span>
<span class="s">    # Expected:</span>
<span class="s">    ## 12</span>
<span class="s">    &lt;BLANKLINE&gt;</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_debug"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_debug">[docs]</a><span class="k">def</span> <span class="nf">test_debug</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>

<span class="s">Create a docstring that we want to debug:</span>

<span class="s">    &gt;&gt;&gt; s = &#39;&#39;&#39;</span>
<span class="s">    ...     &gt;&gt;&gt; x = 12</span>
<span class="s">    ...     &gt;&gt;&gt; print(x)</span>
<span class="s">    ...     12</span>
<span class="s">    ...     &#39;&#39;&#39;</span>

<span class="s">Create some fake stdin input, to feed to the debugger:</span>

<span class="s">    &gt;&gt;&gt; real_stdin = sys.stdin</span>
<span class="s">    &gt;&gt;&gt; sys.stdin = _FakeInput([&#39;next&#39;, &#39;print(x)&#39;, &#39;continue&#39;])</span>

<span class="s">Run the debugger on the docstring, and then restore sys.stdin.</span>

<span class="s">    &gt;&gt;&gt; try: doctest.debug_src(s)</span>
<span class="s">    ... finally: sys.stdin = real_stdin</span>
<span class="s">    &gt; &lt;string&gt;(1)&lt;module&gt;()</span>
<span class="s">    (Pdb) next</span>
<span class="s">    12</span>
<span class="s">    --Return--</span>
<span class="s">    &gt; &lt;string&gt;(1)&lt;module&gt;()-&gt;None</span>
<span class="s">    (Pdb) print(x)</span>
<span class="s">    12</span>
<span class="s">    (Pdb) continue</span>

<span class="s">&quot;&quot;&quot;</span>
</div>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s">&#39;gettrace&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">gettrace</span><span class="p">():</span>
<div class="viewcode-block" id="test_pdb_set_trace"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_pdb_set_trace">[docs]</a>    <span class="k">def</span> <span class="nf">test_pdb_set_trace</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Using pdb.set_trace from a doctest.</span>

<span class="sd">        You can use pdb.set_trace from a doctest.  To do so, you must</span>
<span class="sd">        retrieve the set_trace function from the pdb module at the time</span>
<span class="sd">        you use it.  The doctest module changes sys.stdout so that it can</span>
<span class="sd">        capture program output.  It also temporarily replaces pdb.set_trace</span>
<span class="sd">        with a version that restores stdout.  This is necessary for you to</span>
<span class="sd">        see debugger output.</span>

<span class="sd">          &gt;&gt;&gt; doc = &#39;&#39;&#39;</span>
<span class="sd">          ... &gt;&gt;&gt; x = 42</span>
<span class="sd">          ... &gt;&gt;&gt; raise Exception(&#39;cl&#39;)</span>
<span class="sd">          ... Traceback (most recent call last):</span>
<span class="sd">          ... Exception: cl</span>
<span class="sd">          ... &gt;&gt;&gt; import pdb; pdb.set_trace()</span>
<span class="sd">          ... &#39;&#39;&#39;</span>
<span class="sd">          &gt;&gt;&gt; parser = doctest.DocTestParser()</span>
<span class="sd">          &gt;&gt;&gt; test = parser.get_doctest(doc, {}, &quot;foo-bar@baz&quot;, &quot;foo-bar@baz.py&quot;, 0)</span>
<span class="sd">          &gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)</span>

<span class="sd">        To demonstrate this, we&#39;ll create a fake standard input that</span>
<span class="sd">        captures our debugger input:</span>

<span class="sd">          &gt;&gt;&gt; import tempfile</span>
<span class="sd">          &gt;&gt;&gt; real_stdin = sys.stdin</span>
<span class="sd">          &gt;&gt;&gt; sys.stdin = _FakeInput([</span>
<span class="sd">          ...    &#39;print(x)&#39;,  # print data defined by the example</span>
<span class="sd">          ...    &#39;continue&#39;, # stop debugging</span>
<span class="sd">          ...    &#39;&#39;])</span>

<span class="sd">          &gt;&gt;&gt; try: runner.run(test)</span>
<span class="sd">          ... finally: sys.stdin = real_stdin</span>
<span class="sd">          --Return--</span>
<span class="sd">          &gt; &lt;doctest foo-bar@baz[2]&gt;(1)&lt;module&gt;()-&gt;None</span>
<span class="sd">          -&gt; import pdb; pdb.set_trace()</span>
<span class="sd">          (Pdb) print(x)</span>
<span class="sd">          42</span>
<span class="sd">          (Pdb) continue</span>
<span class="sd">          TestResults(failed=0, attempted=3)</span>

<span class="sd">          You can also put pdb.set_trace in a function called from a test:</span>

<span class="sd">          &gt;&gt;&gt; def calls_set_trace():</span>
<span class="sd">          ...    y=2</span>
<span class="sd">          ...    import pdb; pdb.set_trace()</span>

<span class="sd">          &gt;&gt;&gt; doc = &#39;&#39;&#39;</span>
<span class="sd">          ... &gt;&gt;&gt; x=1</span>
<span class="sd">          ... &gt;&gt;&gt; calls_set_trace()</span>
<span class="sd">          ... &#39;&#39;&#39;</span>
<span class="sd">          &gt;&gt;&gt; test = parser.get_doctest(doc, globals(), &quot;foo-bar@baz&quot;, &quot;foo-bar@baz.py&quot;, 0)</span>
<span class="sd">          &gt;&gt;&gt; real_stdin = sys.stdin</span>
<span class="sd">          &gt;&gt;&gt; sys.stdin = _FakeInput([</span>
<span class="sd">          ...    &#39;print(y)&#39;,  # print data defined in the function</span>
<span class="sd">          ...    &#39;up&#39;,       # out of function</span>
<span class="sd">          ...    &#39;print(x)&#39;,  # print data defined by the example</span>
<span class="sd">          ...    &#39;continue&#39;, # stop debugging</span>
<span class="sd">          ...    &#39;&#39;])</span>

<span class="sd">          &gt;&gt;&gt; try:</span>
<span class="sd">          ...     runner.run(test)</span>
<span class="sd">          ... finally:</span>
<span class="sd">          ...     sys.stdin = real_stdin</span>
<span class="sd">          --Return--</span>
<span class="sd">          &gt; &lt;doctest test.test_doctest.test_pdb_set_trace[8]&gt;(3)calls_set_trace()-&gt;None</span>
<span class="sd">          -&gt; import pdb; pdb.set_trace()</span>
<span class="sd">          (Pdb) print(y)</span>
<span class="sd">          2</span>
<span class="sd">          (Pdb) up</span>
<span class="sd">          &gt; &lt;doctest foo-bar@baz[1]&gt;(1)&lt;module&gt;()</span>
<span class="sd">          -&gt; calls_set_trace()</span>
<span class="sd">          (Pdb) print(x)</span>
<span class="sd">          1</span>
<span class="sd">          (Pdb) continue</span>
<span class="sd">          TestResults(failed=0, attempted=2)</span>

<span class="sd">        During interactive debugging, source code is shown, even for</span>
<span class="sd">        doctest examples:</span>

<span class="sd">          &gt;&gt;&gt; doc = &#39;&#39;&#39;</span>
<span class="sd">          ... &gt;&gt;&gt; def f(x):</span>
<span class="sd">          ... ...     g(x*2)</span>
<span class="sd">          ... &gt;&gt;&gt; def g(x):</span>
<span class="sd">          ... ...     print(x+3)</span>
<span class="sd">          ... ...     import pdb; pdb.set_trace()</span>
<span class="sd">          ... &gt;&gt;&gt; f(3)</span>
<span class="sd">          ... &#39;&#39;&#39;</span>
<span class="sd">          &gt;&gt;&gt; test = parser.get_doctest(doc, globals(), &quot;foo-bar@baz&quot;, &quot;foo-bar@baz.py&quot;, 0)</span>
<span class="sd">          &gt;&gt;&gt; real_stdin = sys.stdin</span>
<span class="sd">          &gt;&gt;&gt; sys.stdin = _FakeInput([</span>
<span class="sd">          ...    &#39;list&#39;,     # list source from example 2</span>
<span class="sd">          ...    &#39;next&#39;,     # return from g()</span>
<span class="sd">          ...    &#39;list&#39;,     # list source from example 1</span>
<span class="sd">          ...    &#39;next&#39;,     # return from f()</span>
<span class="sd">          ...    &#39;list&#39;,     # list source from example 3</span>
<span class="sd">          ...    &#39;continue&#39;, # stop debugging</span>
<span class="sd">          ...    &#39;&#39;])</span>
<span class="sd">          &gt;&gt;&gt; try: runner.run(test)</span>
<span class="sd">          ... finally: sys.stdin = real_stdin</span>
<span class="sd">          ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">          --Return--</span>
<span class="sd">          &gt; &lt;doctest foo-bar@baz[1]&gt;(3)g()-&gt;None</span>
<span class="sd">          -&gt; import pdb; pdb.set_trace()</span>
<span class="sd">          (Pdb) list</span>
<span class="sd">            1     def g(x):</span>
<span class="sd">            2         print(x+3)</span>
<span class="sd">            3  -&gt;     import pdb; pdb.set_trace()</span>
<span class="sd">          [EOF]</span>
<span class="sd">          (Pdb) next</span>
<span class="sd">          --Return--</span>
<span class="sd">          &gt; &lt;doctest foo-bar@baz[0]&gt;(2)f()-&gt;None</span>
<span class="sd">          -&gt; g(x*2)</span>
<span class="sd">          (Pdb) list</span>
<span class="sd">            1     def f(x):</span>
<span class="sd">            2  -&gt;     g(x*2)</span>
<span class="sd">          [EOF]</span>
<span class="sd">          (Pdb) next</span>
<span class="sd">          --Return--</span>
<span class="sd">          &gt; &lt;doctest foo-bar@baz[2]&gt;(1)&lt;module&gt;()-&gt;None</span>
<span class="sd">          -&gt; f(3)</span>
<span class="sd">          (Pdb) list</span>
<span class="sd">            1  -&gt; f(3)</span>
<span class="sd">          [EOF]</span>
<span class="sd">          (Pdb) continue</span>
<span class="sd">          **********************************************************************</span>
<span class="sd">          File &quot;foo-bar@baz.py&quot;, line 7, in foo-bar@baz</span>
<span class="sd">          Failed example:</span>
<span class="sd">              f(3)</span>
<span class="sd">          Expected nothing</span>
<span class="sd">          Got:</span>
<span class="sd">              9</span>
<span class="sd">          TestResults(failed=1, attempted=3)</span>
<span class="sd">          &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_pdb_set_trace_nested"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_pdb_set_trace_nested">[docs]</a>    <span class="k">def</span> <span class="nf">test_pdb_set_trace_nested</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;This illustrates more-demanding use of set_trace with nested functions.</span>

<span class="sd">        &gt;&gt;&gt; class C(object):</span>
<span class="sd">        ...     def calls_set_trace(self):</span>
<span class="sd">        ...         y = 1</span>
<span class="sd">        ...         import pdb; pdb.set_trace()</span>
<span class="sd">        ...         self.f1()</span>
<span class="sd">        ...         y = 2</span>
<span class="sd">        ...     def f1(self):</span>
<span class="sd">        ...         x = 1</span>
<span class="sd">        ...         self.f2()</span>
<span class="sd">        ...         x = 2</span>
<span class="sd">        ...     def f2(self):</span>
<span class="sd">        ...         z = 1</span>
<span class="sd">        ...         z = 2</span>

<span class="sd">        &gt;&gt;&gt; calls_set_trace = C().calls_set_trace</span>

<span class="sd">        &gt;&gt;&gt; doc = &#39;&#39;&#39;</span>
<span class="sd">        ... &gt;&gt;&gt; a = 1</span>
<span class="sd">        ... &gt;&gt;&gt; calls_set_trace()</span>
<span class="sd">        ... &#39;&#39;&#39;</span>
<span class="sd">        &gt;&gt;&gt; parser = doctest.DocTestParser()</span>
<span class="sd">        &gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)</span>
<span class="sd">        &gt;&gt;&gt; test = parser.get_doctest(doc, globals(), &quot;foo-bar@baz&quot;, &quot;foo-bar@baz.py&quot;, 0)</span>
<span class="sd">        &gt;&gt;&gt; real_stdin = sys.stdin</span>
<span class="sd">        &gt;&gt;&gt; sys.stdin = _FakeInput([</span>
<span class="sd">        ...    &#39;print(y)&#39;,  # print data defined in the function</span>
<span class="sd">        ...    &#39;step&#39;, &#39;step&#39;, &#39;step&#39;, &#39;step&#39;, &#39;step&#39;, &#39;step&#39;, &#39;print(z)&#39;,</span>
<span class="sd">        ...    &#39;up&#39;, &#39;print(x)&#39;,</span>
<span class="sd">        ...    &#39;up&#39;, &#39;print(y)&#39;,</span>
<span class="sd">        ...    &#39;up&#39;, &#39;print(foo)&#39;,</span>
<span class="sd">        ...    &#39;continue&#39;, # stop debugging</span>
<span class="sd">        ...    &#39;&#39;])</span>

<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     runner.run(test)</span>
<span class="sd">        ... finally:</span>
<span class="sd">        ...     sys.stdin = real_stdin</span>
<span class="sd">        ... # doctest: +REPORT_NDIFF</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(5)calls_set_trace()</span>
<span class="sd">        -&gt; self.f1()</span>
<span class="sd">        (Pdb) print(y)</span>
<span class="sd">        1</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        --Call--</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(7)f1()</span>
<span class="sd">        -&gt; def f1(self):</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(8)f1()</span>
<span class="sd">        -&gt; x = 1</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(9)f1()</span>
<span class="sd">        -&gt; self.f2()</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        --Call--</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(11)f2()</span>
<span class="sd">        -&gt; def f2(self):</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(12)f2()</span>
<span class="sd">        -&gt; z = 1</span>
<span class="sd">        (Pdb) step</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(13)f2()</span>
<span class="sd">        -&gt; z = 2</span>
<span class="sd">        (Pdb) print(z)</span>
<span class="sd">        1</span>
<span class="sd">        (Pdb) up</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(9)f1()</span>
<span class="sd">        -&gt; self.f2()</span>
<span class="sd">        (Pdb) print(x)</span>
<span class="sd">        1</span>
<span class="sd">        (Pdb) up</span>
<span class="sd">        &gt; &lt;doctest test.test_doctest.test_pdb_set_trace_nested[0]&gt;(5)calls_set_trace()</span>
<span class="sd">        -&gt; self.f1()</span>
<span class="sd">        (Pdb) print(y)</span>
<span class="sd">        1</span>
<span class="sd">        (Pdb) up</span>
<span class="sd">        &gt; &lt;doctest foo-bar@baz[1]&gt;(1)&lt;module&gt;()</span>
<span class="sd">        -&gt; calls_set_trace()</span>
<span class="sd">        (Pdb) print(foo)</span>
<span class="sd">        *** NameError: name &#39;foo&#39; is not defined</span>
<span class="sd">        (Pdb) continue</span>
<span class="sd">        TestResults(failed=0, attempted=2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocTestSuite"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocTestSuite">[docs]</a><span class="k">def</span> <span class="nf">test_DocTestSuite</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;DocTestSuite creates a unittest test suite from a doctest.</span>

<span class="sd">       We create a Suite by providing a module.  A module can be provided</span>
<span class="sd">       by passing a module object:</span>

<span class="sd">         &gt;&gt;&gt; import unittest</span>
<span class="sd">         &gt;&gt;&gt; import test.sample_doctest</span>
<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(test.sample_doctest)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;</span>

<span class="sd">       We can also supply the module by name:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;</span>

<span class="sd">       The module need not contain any doctest examples:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest_no_doctests&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=0 errors=0 failures=0&gt;</span>

<span class="sd">       However, if DocTestSuite finds no docstrings, it raises an error:</span>

<span class="sd">         &gt;&gt;&gt; try:</span>
<span class="sd">         ...     doctest.DocTestSuite(&#39;test.sample_doctest_no_docstrings&#39;)</span>
<span class="sd">         ... except ValueError as e:</span>
<span class="sd">         ...     error = e</span>

<span class="sd">         &gt;&gt;&gt; print(error.args[1])</span>
<span class="sd">         has no docstrings</span>

<span class="sd">       You can prevent this error by passing a DocTestFinder instance with</span>
<span class="sd">       the `exclude_empty` keyword argument set to False:</span>

<span class="sd">         &gt;&gt;&gt; finder = doctest.DocTestFinder(exclude_empty=False)</span>
<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest_no_docstrings&#39;,</span>
<span class="sd">         ...                              test_finder=finder)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=0 errors=0 failures=0&gt;</span>

<span class="sd">       We can use the current module:</span>

<span class="sd">         &gt;&gt;&gt; suite = test.sample_doctest.test_suite()</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;</span>

<span class="sd">       We can supply global variables.  If we pass globs, they will be</span>
<span class="sd">       used instead of the module globals.  Here we&#39;ll pass an empty</span>
<span class="sd">       globals, triggering an extra error:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;, globs={})</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=5&gt;</span>

<span class="sd">       Alternatively, we can provide extra globals.  Here we&#39;ll make an</span>
<span class="sd">       error go away by providing an extra global variable:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;,</span>
<span class="sd">         ...                              extraglobs={&#39;y&#39;: 1})</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;</span>

<span class="sd">       You can pass option flags.  Here we&#39;ll cause an extra error</span>
<span class="sd">       by disabling the blank-line feature:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;,</span>
<span class="sd">         ...                      optionflags=doctest.DONT_ACCEPT_BLANKLINE)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=5&gt;</span>

<span class="sd">       You can supply setUp and tearDown functions:</span>

<span class="sd">         &gt;&gt;&gt; def setUp(t):</span>
<span class="sd">         ...     import test.test_doctest</span>
<span class="sd">         ...     test.test_doctest.sillySetup = True</span>

<span class="sd">         &gt;&gt;&gt; def tearDown(t):</span>
<span class="sd">         ...     import test.test_doctest</span>
<span class="sd">         ...     del test.test_doctest.sillySetup</span>

<span class="sd">       Here, we installed a silly variable that the test expects:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;,</span>
<span class="sd">         ...      setUp=setUp, tearDown=tearDown)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;</span>

<span class="sd">       But the tearDown restores sanity:</span>

<span class="sd">         &gt;&gt;&gt; import test.test_doctest</span>
<span class="sd">         &gt;&gt;&gt; test.test_doctest.sillySetup</span>
<span class="sd">         Traceback (most recent call last):</span>
<span class="sd">         ...</span>
<span class="sd">         AttributeError: &#39;module&#39; object has no attribute &#39;sillySetup&#39;</span>

<span class="sd">       The setUp and tearDown funtions are passed test objects. Here</span>
<span class="sd">       we&#39;ll use the setUp function to supply the missing variable y:</span>

<span class="sd">         &gt;&gt;&gt; def setUp(test):</span>
<span class="sd">         ...     test.globs[&#39;y&#39;] = 1</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocTestSuite(&#39;test.sample_doctest&#39;, setUp=setUp)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;</span>

<span class="sd">       Here, we didn&#39;t need to use a tearDown function because we</span>
<span class="sd">       modified the test globals, which are a copy of the</span>
<span class="sd">       sample_doctest module dictionary.  The test globals are</span>
<span class="sd">       automatically cleared for us after a test.</span>
<span class="sd">       &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_DocFileSuite"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_DocFileSuite">[docs]</a><span class="k">def</span> <span class="nf">test_DocFileSuite</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;We can test tests found in text files using a DocFileSuite.</span>

<span class="sd">       We create a suite by providing the names of one or more text</span>
<span class="sd">       files that include examples:</span>

<span class="sd">         &gt;&gt;&gt; import unittest</span>
<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</span>

<span class="sd">       The test files are looked for in the directory containing the</span>
<span class="sd">       calling module.  A package keyword argument can be provided to</span>
<span class="sd">       specify a different relative location.</span>

<span class="sd">         &gt;&gt;&gt; import unittest</span>
<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                              package=&#39;test&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</span>

<span class="sd">       Support for using a package&#39;s __loader__.get_data() is also</span>
<span class="sd">       provided.</span>

<span class="sd">         &gt;&gt;&gt; import unittest, pkgutil, test</span>
<span class="sd">         &gt;&gt;&gt; added_loader = False</span>
<span class="sd">         &gt;&gt;&gt; if not hasattr(test, &#39;__loader__&#39;):</span>
<span class="sd">         ...     test.__loader__ = pkgutil.get_loader(test)</span>
<span class="sd">         ...     added_loader = True</span>
<span class="sd">         &gt;&gt;&gt; try:</span>
<span class="sd">         ...     suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                                  &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                                  &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                                  package=&#39;test&#39;)</span>
<span class="sd">         ...     suite.run(unittest.TestResult())</span>
<span class="sd">         ... finally:</span>
<span class="sd">         ...     if added_loader:</span>
<span class="sd">         ...         del test.__loader__</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</span>

<span class="sd">       &#39;/&#39; should be used as a path separator.  It will be converted</span>
<span class="sd">       to a native separator at run time:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;../test/test_doctest.txt&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=1 errors=0 failures=1&gt;</span>

<span class="sd">       If DocFileSuite is used from an interactive session, then files</span>
<span class="sd">       are resolved relative to the directory of sys.argv[0]:</span>

<span class="sd">         &gt;&gt;&gt; import types, os.path, test.test_doctest</span>
<span class="sd">         &gt;&gt;&gt; save_argv = sys.argv</span>
<span class="sd">         &gt;&gt;&gt; sys.argv = [test.test_doctest.__file__]</span>
<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              package=types.ModuleType(&#39;__main__&#39;))</span>
<span class="sd">         &gt;&gt;&gt; sys.argv = save_argv</span>

<span class="sd">       By setting `module_relative=False`, os-specific paths may be</span>
<span class="sd">       used (including absolute paths and paths relative to the</span>
<span class="sd">       working directory):</span>

<span class="sd">         &gt;&gt;&gt; # Get the absolute path of the test package.</span>
<span class="sd">         &gt;&gt;&gt; test_doctest_path = os.path.abspath(test.test_doctest.__file__)</span>
<span class="sd">         &gt;&gt;&gt; test_pkg_path = os.path.split(test_doctest_path)[0]</span>

<span class="sd">         &gt;&gt;&gt; # Use it to find the absolute path of test_doctest.txt.</span>
<span class="sd">         &gt;&gt;&gt; test_file = os.path.join(test_pkg_path, &#39;test_doctest.txt&#39;)</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(test_file, module_relative=False)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=1 errors=0 failures=1&gt;</span>

<span class="sd">       It is an error to specify `package` when `module_relative=False`:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(test_file, module_relative=False,</span>
<span class="sd">         ...                              package=&#39;test&#39;)</span>
<span class="sd">         Traceback (most recent call last):</span>
<span class="sd">         ValueError: Package may only be specified for module-relative paths.</span>

<span class="sd">       You can specify initial global variables:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                              globs={&#39;favorite_color&#39;: &#39;blue&#39;})</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=1&gt;</span>

<span class="sd">       In this case, we supplied a missing favorite color. You can</span>
<span class="sd">       provide doctest options:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                         optionflags=doctest.DONT_ACCEPT_BLANKLINE,</span>
<span class="sd">         ...                              globs={&#39;favorite_color&#39;: &#39;blue&#39;})</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</span>

<span class="sd">       And, you can provide setUp and tearDown functions:</span>

<span class="sd">         &gt;&gt;&gt; def setUp(t):</span>
<span class="sd">         ...     import test.test_doctest</span>
<span class="sd">         ...     test.test_doctest.sillySetup = True</span>

<span class="sd">         &gt;&gt;&gt; def tearDown(t):</span>
<span class="sd">         ...     import test.test_doctest</span>
<span class="sd">         ...     del test.test_doctest.sillySetup</span>

<span class="sd">       Here, we installed a silly variable that the test expects:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                              setUp=setUp, tearDown=tearDown)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=1&gt;</span>

<span class="sd">       But the tearDown restores sanity:</span>

<span class="sd">         &gt;&gt;&gt; import test.test_doctest</span>
<span class="sd">         &gt;&gt;&gt; test.test_doctest.sillySetup</span>
<span class="sd">         Traceback (most recent call last):</span>
<span class="sd">         ...</span>
<span class="sd">         AttributeError: &#39;module&#39; object has no attribute &#39;sillySetup&#39;</span>

<span class="sd">       The setUp and tearDown funtions are passed test objects.</span>
<span class="sd">       Here, we&#39;ll use a setUp function to set the favorite color in</span>
<span class="sd">       test_doctest.txt:</span>

<span class="sd">         &gt;&gt;&gt; def setUp(test):</span>
<span class="sd">         ...     test.globs[&#39;favorite_color&#39;] = &#39;blue&#39;</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;, setUp=setUp)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=1 errors=0 failures=0&gt;</span>

<span class="sd">       Here, we didn&#39;t need to use a tearDown function because we</span>
<span class="sd">       modified the test globals.  The test globals are</span>
<span class="sd">       automatically cleared for us after a test.</span>

<span class="sd">       Tests in a file run using `DocFileSuite` can also access the</span>
<span class="sd">       `__file__` global, which is set to the name of the file</span>
<span class="sd">       containing the tests:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest3.txt&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=1 errors=0 failures=0&gt;</span>

<span class="sd">       If the tests contain non-ASCII characters, we have to specify which</span>
<span class="sd">       encoding the file is encoded with. We do so by using the `encoding`</span>
<span class="sd">       parameter:</span>

<span class="sd">         &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest2.txt&#39;,</span>
<span class="sd">         ...                              &#39;test_doctest4.txt&#39;,</span>
<span class="sd">         ...                              encoding=&#39;utf-8&#39;)</span>
<span class="sd">         &gt;&gt;&gt; suite.run(unittest.TestResult())</span>
<span class="sd">         &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</span>

<span class="sd">       &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_trailing_space_in_test"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_trailing_space_in_test">[docs]</a><span class="k">def</span> <span class="nf">test_trailing_space_in_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trailing spaces in expected output are significant:</span>

<span class="sd">      &gt;&gt;&gt; x, y = &#39;foo&#39;, &#39;&#39;</span>
<span class="sd">      &gt;&gt;&gt; print(x, y)</span>
<span class="sd">      foo \n</span>
<span class="sd">    &quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="test_unittest_reportflags"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_unittest_reportflags">[docs]</a><span class="k">def</span> <span class="nf">test_unittest_reportflags</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Default unittest reporting flags can be set to control reporting</span>

<span class="sd">    Here, we&#39;ll set the REPORT_ONLY_FIRST_FAILURE option so we see</span>
<span class="sd">    only the first failure of each test.  First, we&#39;ll look at the</span>
<span class="sd">    output without the flag.  The file test_doctest.txt file has two</span>
<span class="sd">    tests. They both fail if blank lines are disabled:</span>

<span class="sd">      &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">      ...                          optionflags=doctest.DONT_ACCEPT_BLANKLINE)</span>
<span class="sd">      &gt;&gt;&gt; import unittest</span>
<span class="sd">      &gt;&gt;&gt; result = suite.run(unittest.TestResult())</span>
<span class="sd">      &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS</span>
<span class="sd">      Traceback ...</span>
<span class="sd">      Failed example:</span>
<span class="sd">          favorite_color</span>
<span class="sd">      ...</span>
<span class="sd">      Failed example:</span>
<span class="sd">          if 1:</span>
<span class="sd">      ...</span>

<span class="sd">    Note that we see both failures displayed.</span>

<span class="sd">      &gt;&gt;&gt; old = doctest.set_unittest_reportflags(</span>
<span class="sd">      ...    doctest.REPORT_ONLY_FIRST_FAILURE)</span>

<span class="sd">    Now, when we run the test:</span>

<span class="sd">      &gt;&gt;&gt; result = suite.run(unittest.TestResult())</span>
<span class="sd">      &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS</span>
<span class="sd">      Traceback ...</span>
<span class="sd">      Failed example:</span>
<span class="sd">          favorite_color</span>
<span class="sd">      Exception raised:</span>
<span class="sd">          ...</span>
<span class="sd">          NameError: name &#39;favorite_color&#39; is not defined</span>
<span class="sd">      &lt;BLANKLINE&gt;</span>
<span class="sd">      &lt;BLANKLINE&gt;</span>

<span class="sd">    We get only the first failure.</span>

<span class="sd">    If we give any reporting options when we set up the tests,</span>
<span class="sd">    however:</span>

<span class="sd">      &gt;&gt;&gt; suite = doctest.DocFileSuite(&#39;test_doctest.txt&#39;,</span>
<span class="sd">      ...     optionflags=doctest.DONT_ACCEPT_BLANKLINE | doctest.REPORT_NDIFF)</span>

<span class="sd">    Then the default eporting options are ignored:</span>

<span class="sd">      &gt;&gt;&gt; result = suite.run(unittest.TestResult())</span>
<span class="sd">      &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS</span>
<span class="sd">      Traceback ...</span>
<span class="sd">      Failed example:</span>
<span class="sd">          favorite_color</span>
<span class="sd">      ...</span>
<span class="sd">      Failed example:</span>
<span class="sd">          if 1:</span>
<span class="sd">             print(&#39;a&#39;)</span>
<span class="sd">             print()</span>
<span class="sd">             print(&#39;b&#39;)</span>
<span class="sd">      Differences (ndiff with -expected +actual):</span>
<span class="sd">            a</span>
<span class="sd">          - &lt;BLANKLINE&gt;</span>
<span class="sd">          +</span>
<span class="sd">            b</span>
<span class="sd">      &lt;BLANKLINE&gt;</span>
<span class="sd">      &lt;BLANKLINE&gt;</span>


<span class="sd">    Test runners can restore the formatting flags after they run:</span>

<span class="sd">      &gt;&gt;&gt; ignored = doctest.set_unittest_reportflags(old)</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_testfile"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_testfile">[docs]</a><span class="k">def</span> <span class="nf">test_testfile</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Tests for the `testfile()` function.  This function runs all the</span>
<span class="s">doctest examples in a given file.  In its simple invokation, it is</span>
<span class="s">called with the name of a file, which is taken to be relative to the</span>
<span class="s">calling module.  The return value is (#failures, #tests).</span>

<span class="s">We don&#39;t want `-v` in sys.argv for these tests.</span>

<span class="s">    &gt;&gt;&gt; save_argv = sys.argv</span>
<span class="s">    &gt;&gt;&gt; if &#39;-v&#39; in sys.argv:</span>
<span class="s">    ...     sys.argv = [arg for arg in save_argv if arg != &#39;-v&#39;]</span>


<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;) # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...&quot;, line 6, in test_doctest.txt</span>
<span class="s">    Failed example:</span>
<span class="s">        favorite_color</span>
<span class="s">    Exception raised:</span>
<span class="s">        ...</span>
<span class="s">        NameError: name &#39;favorite_color&#39; is not defined</span>
<span class="s">    **********************************************************************</span>
<span class="s">    1 items had failures:</span>
<span class="s">       1 of   2 in test_doctest.txt</span>
<span class="s">    ***Test Failed*** 1 failures.</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">(Note: we&#39;ll be clearing doctest.master after each call to</span>
<span class="s">`doctest.testfile`, to suppress warnings about multiple tests with the</span>
<span class="s">same name.)</span>

<span class="s">Globals may be specified with the `globs` and `extraglobs` parameters:</span>

<span class="s">    &gt;&gt;&gt; globs = {&#39;favorite_color&#39;: &#39;blue&#39;}</span>
<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, globs=globs)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">    &gt;&gt;&gt; extraglobs = {&#39;favorite_color&#39;: &#39;red&#39;}</span>
<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, globs=globs,</span>
<span class="s">    ...                  extraglobs=extraglobs) # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...&quot;, line 6, in test_doctest.txt</span>
<span class="s">    Failed example:</span>
<span class="s">        favorite_color</span>
<span class="s">    Expected:</span>
<span class="s">        &#39;blue&#39;</span>
<span class="s">    Got:</span>
<span class="s">        &#39;red&#39;</span>
<span class="s">    **********************************************************************</span>
<span class="s">    1 items had failures:</span>
<span class="s">       1 of   2 in test_doctest.txt</span>
<span class="s">    ***Test Failed*** 1 failures.</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">The file may be made relative to a given module or package, using the</span>
<span class="s">optional `module_relative` parameter:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, globs=globs,</span>
<span class="s">    ...                  module_relative=&#39;test&#39;)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">Verbosity can be increased with the optional `verbose` parameter:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, globs=globs, verbose=True)</span>
<span class="s">    Trying:</span>
<span class="s">        favorite_color</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;blue&#39;</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        if 1:</span>
<span class="s">           print(&#39;a&#39;)</span>
<span class="s">           print()</span>
<span class="s">           print(&#39;b&#39;)</span>
<span class="s">    Expecting:</span>
<span class="s">        a</span>
<span class="s">        &lt;BLANKLINE&gt;</span>
<span class="s">        b</span>
<span class="s">    ok</span>
<span class="s">    1 items passed all tests:</span>
<span class="s">       2 tests in test_doctest.txt</span>
<span class="s">    2 tests in 1 items.</span>
<span class="s">    2 passed and 0 failed.</span>
<span class="s">    Test passed.</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">The name of the test may be specified with the optional `name`</span>
<span class="s">parameter:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, name=&#39;newname&#39;)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...&quot;, line 6, in newname</span>
<span class="s">    ...</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">The summary report may be suppressed with the optional `report`</span>
<span class="s">parameter:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, report=False)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...&quot;, line 6, in test_doctest.txt</span>
<span class="s">    Failed example:</span>
<span class="s">        favorite_color</span>
<span class="s">    Exception raised:</span>
<span class="s">        ...</span>
<span class="s">        NameError: name &#39;favorite_color&#39; is not defined</span>
<span class="s">    TestResults(failed=1, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">The optional keyword argument `raise_on_error` can be used to raise an</span>
<span class="s">exception on the first error (which may be useful for postmortem</span>
<span class="s">debugging):</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest.txt&#39;, raise_on_error=True)</span>
<span class="s">    ... # doctest: +ELLIPSIS</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">    doctest.UnexpectedException: ...</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">If the tests contain non-ASCII characters, the tests might fail, since</span>
<span class="s">it&#39;s unknown which encoding is used. The encoding can be specified</span>
<span class="s">using the optional keyword argument `encoding`:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest4.txt&#39;, encoding=&#39;latin-1&#39;) # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...&quot;, line 7, in test_doctest4.txt</span>
<span class="s">    Failed example:</span>
<span class="s">        &#39;...&#39;</span>
<span class="s">    Expected:</span>
<span class="s">        &#39;f\xf6\xf6&#39;</span>
<span class="s">    Got:</span>
<span class="s">        &#39;f\xc3\xb6\xc3\xb6&#39;</span>
<span class="s">    **********************************************************************</span>
<span class="s">    ...</span>
<span class="s">    **********************************************************************</span>
<span class="s">    1 items had failures:</span>
<span class="s">       2 of   2 in test_doctest4.txt</span>
<span class="s">    ***Test Failed*** 2 failures.</span>
<span class="s">    TestResults(failed=2, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest4.txt&#39;, encoding=&#39;utf-8&#39;)</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>

<span class="s">Test the verbose output:</span>

<span class="s">    &gt;&gt;&gt; doctest.testfile(&#39;test_doctest4.txt&#39;, encoding=&#39;utf-8&#39;, verbose=True)</span>
<span class="s">    Trying:</span>
<span class="s">        &#39;f&#39;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;f\xf6\xf6&#39;</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        &#39;br&#39;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;b\u0105r&#39;</span>
<span class="s">    ok</span>
<span class="s">    1 items passed all tests:</span>
<span class="s">       2 tests in test_doctest4.txt</span>
<span class="s">    2 tests in 1 items.</span>
<span class="s">    2 passed and 0 failed.</span>
<span class="s">    Test passed.</span>
<span class="s">    TestResults(failed=0, attempted=2)</span>
<span class="s">    &gt;&gt;&gt; doctest.master = None  # Reset master.</span>
<span class="s">    &gt;&gt;&gt; sys.argv = save_argv</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_testmod"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_testmod">[docs]</a><span class="k">def</span> <span class="nf">test_testmod</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">Tests for the testmod function.  More might be useful, but for now we&#39;re just</span>
<span class="s">testing the case raised by Issue 6195, where trying to doctest a C module would</span>
<span class="s">fail with a UnicodeDecodeError because doctest tried to read the &quot;source&quot; lines</span>
<span class="s">out of the binary module.</span>

<span class="s">    &gt;&gt;&gt; import unicodedata</span>
<span class="s">    &gt;&gt;&gt; doctest.testmod(unicodedata, verbose=False)</span>
<span class="s">    TestResults(failed=0, attempted=0)</span>
<span class="s">&quot;&quot;&quot;</span>
</div>
<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">fsencode</span><span class="p">(</span><span class="s">&quot;foo-br@baz.py&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
    <span class="c"># Skip the test: the filesystem encoding is unable to encode the filename</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
<div class="viewcode-block" id="test_unicode"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_unicode">[docs]</a>    <span class="k">def</span> <span class="nf">test_unicode</span><span class="p">():</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Check doctest with a non-ascii filename:</span>

<span class="s">    &gt;&gt;&gt; doc = &#39;&#39;&#39;</span>
<span class="s">    ... &gt;&gt;&gt; raise Exception(&#39;cl&#39;)</span>
<span class="s">    ... &#39;&#39;&#39;</span>
<span class="s">    ...</span>
<span class="s">    &gt;&gt;&gt; parser = doctest.DocTestParser()</span>
<span class="s">    &gt;&gt;&gt; test = parser.get_doctest(doc, {}, &quot;foo-br@baz&quot;, &quot;foo-br@baz.py&quot;, 0)</span>
<span class="s">    &gt;&gt;&gt; test</span>
<span class="s">    &lt;DocTest foo-br@baz from foo-br@baz.py:0 (1 example)&gt;</span>
<span class="s">    &gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)</span>
<span class="s">    &gt;&gt;&gt; runner.run(test) # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;foo-br@baz.py&quot;, line 2, in foo-br@baz</span>
<span class="s">    Failed example:</span>
<span class="s">        raise Exception(&#39;cl&#39;)</span>
<span class="s">    Exception raised:</span>
<span class="s">        Traceback (most recent call last):</span>
<span class="s">          File ...</span>
<span class="s">            compileflags, 1), test.globs)</span>
<span class="s">          File &quot;&lt;doctest foo-br@baz[0]&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="s">            raise Exception(&#39;cl&#39;)</span>
<span class="s">        Exception: cl</span>
<span class="s">    TestResults(failed=1, attempted=1)</span>
<span class="s">    &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="test_CLI"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_CLI">[docs]</a><span class="k">def</span> <span class="nf">test_CLI</span><span class="p">():</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">The doctest module can be used to run doctests against an arbitrary file.</span>
<span class="s">These tests test this CLI functionality.</span>

<span class="s">We&#39;ll use the support module&#39;s script_helpers for this, and write a test files</span>
<span class="s">to a temp dir to run the command against.  Due to a current limitation in</span>
<span class="s">script_helpers, though, we need a little utility function to turn the returned</span>
<span class="s">output into something we can doctest against:</span>

<span class="s">    &gt;&gt;&gt; def normalize(s):</span>
<span class="s">    ...     return &#39;\n&#39;.join(s.decode().splitlines())</span>

<span class="s">Note: we also pass TERM=&#39;&#39; to all the assert_python calls to avoid a bug</span>
<span class="s">in the readline library that is triggered in these tests because we are</span>
<span class="s">running them in a new python process.  See:</span>

<span class="s">  http://lists.gnu.org/archive/html/bug-readline/2013-06/msg00000.html</span>

<span class="s">With those preliminaries out of the way, we&#39;ll start with a file with two</span>
<span class="s">simple tests and no errors.  We&#39;ll run both the unadorned doctest command, and</span>
<span class="s">the verbose version, and then check the output:</span>

<span class="s">    &gt;&gt;&gt; from test import script_helper</span>
<span class="s">    &gt;&gt;&gt; with script_helper.temp_dir() as tmpdir:</span>
<span class="s">    ...     fn = os.path.join(tmpdir, &#39;myfile.doc&#39;)</span>
<span class="s">    ...     with open(fn, &#39;w&#39;) as f:</span>
<span class="s">    ...         _ = f.write(&#39;This is a very simple test file.\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   &gt;&gt;&gt; 1 + 1\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   2\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   &gt;&gt;&gt; &quot;a&quot;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&quot;   &#39;a&#39;\n&quot;)</span>
<span class="s">    ...         _ = f.write(&#39;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;And that is it.\n&#39;)</span>
<span class="s">    ...     rc1, out1, err1 = script_helper.assert_python_ok(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, fn, TERM=&#39;&#39;)</span>
<span class="s">    ...     rc2, out2, err2 = script_helper.assert_python_ok(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, &#39;-v&#39;, fn, TERM=&#39;&#39;)</span>

<span class="s">With no arguments and passing tests, we should get no output:</span>

<span class="s">    &gt;&gt;&gt; rc1, out1, err1</span>
<span class="s">    (0, b&#39;&#39;, b&#39;&#39;)</span>

<span class="s">With the verbose flag, we should see the test output, but no error output:</span>

<span class="s">    &gt;&gt;&gt; rc2, err2</span>
<span class="s">    (0, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(out2))</span>
<span class="s">    Trying:</span>
<span class="s">        1 + 1</span>
<span class="s">    Expecting:</span>
<span class="s">        2</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        &quot;a&quot;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;a&#39;</span>
<span class="s">    ok</span>
<span class="s">    1 items passed all tests:</span>
<span class="s">       2 tests in myfile.doc</span>
<span class="s">    2 tests in 1 items.</span>
<span class="s">    2 passed and 0 failed.</span>
<span class="s">    Test passed.</span>

<span class="s">Now we&#39;ll write a couple files, one with three tests, the other a python module</span>
<span class="s">with two tests, both of the files having &quot;errors&quot; in the tests that can be made</span>
<span class="s">non-errors by applying the appropriate doctest options to the run (ELLIPSIS in</span>
<span class="s">the first file, NORMALIZE_WHITESPACE in the second).  This combination will</span>
<span class="s">allow to thoroughly test the -f and -o flags, as well as the doctest command&#39;s</span>
<span class="s">ability to process more than one file on the command line and, since the second</span>
<span class="s">file ends in &#39;.py&#39;, its handling of python module files (as opposed to straight</span>
<span class="s">text files).</span>

<span class="s">    &gt;&gt;&gt; from test import script_helper</span>
<span class="s">    &gt;&gt;&gt; with script_helper.temp_dir() as tmpdir:</span>
<span class="s">    ...     fn = os.path.join(tmpdir, &#39;myfile.doc&#39;)</span>
<span class="s">    ...     with open(fn, &#39;w&#39;) as f:</span>
<span class="s">    ...         _ = f.write(&#39;This is another simple test file.\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   &gt;&gt;&gt; 1 + 1\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   2\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   &gt;&gt;&gt; &quot;abcdef&quot;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&quot;   &#39;a...f&#39;\n&quot;)</span>
<span class="s">    ...         _ = f.write(&#39;   &gt;&gt;&gt; &quot;ajkml&quot;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&quot;   &#39;a...l&#39;\n&quot;)</span>
<span class="s">    ...         _ = f.write(&#39;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;And that is it.\n&#39;)</span>
<span class="s">    ...     fn2 = os.path.join(tmpdir, &#39;myfile2.py&#39;)</span>
<span class="s">    ...     with open(fn2, &#39;w&#39;) as f:</span>
<span class="s">    ...         _ = f.write(&#39;def test_func():\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   \&quot;\&quot;\&quot;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;   This is simple python test function.\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;       &gt;&gt;&gt; 1 + 1\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;       2\n&#39;)</span>
<span class="s">    ...         _ = f.write(&#39;       &gt;&gt;&gt; &quot;abc   def&quot;\n&#39;)</span>
<span class="s">    ...         _ = f.write(&quot;       &#39;abc def&#39;\n&quot;)</span>
<span class="s">    ...         _ = f.write(&quot;\n&quot;)</span>
<span class="s">    ...         _ = f.write(&#39;   \&quot;\&quot;\&quot;\n&#39;)</span>
<span class="s">    ...     import shutil</span>
<span class="s">    ...     rc1, out1, err1 = script_helper.assert_python_failure(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, fn, fn2, TERM=&#39;&#39;)</span>
<span class="s">    ...     rc2, out2, err2 = script_helper.assert_python_ok(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, &#39;-o&#39;, &#39;ELLIPSIS&#39;, fn, TERM=&#39;&#39;)</span>
<span class="s">    ...     rc3, out3, err3 = script_helper.assert_python_ok(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, &#39;-o&#39;, &#39;ELLIPSIS&#39;,</span>
<span class="s">    ...             &#39;-o&#39;, &#39;NORMALIZE_WHITESPACE&#39;, fn, fn2, TERM=&#39;&#39;)</span>
<span class="s">    ...     rc4, out4, err4 = script_helper.assert_python_failure(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, &#39;-f&#39;, fn, fn2, TERM=&#39;&#39;)</span>
<span class="s">    ...     rc5, out5, err5 = script_helper.assert_python_ok(</span>
<span class="s">    ...             &#39;-m&#39;, &#39;doctest&#39;, &#39;-v&#39;, &#39;-o&#39;, &#39;ELLIPSIS&#39;,</span>
<span class="s">    ...             &#39;-o&#39;, &#39;NORMALIZE_WHITESPACE&#39;, fn, fn2, TERM=&#39;&#39;)</span>

<span class="s">Our first test run will show the errors from the first file (doctest stops if a</span>
<span class="s">file has errors).  Note that doctest test-run error output appears on stdout,</span>
<span class="s">not stderr:</span>

<span class="s">    &gt;&gt;&gt; rc1, err1</span>
<span class="s">    (1, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(out1))                # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...myfile.doc&quot;, line 4, in myfile.doc</span>
<span class="s">    Failed example:</span>
<span class="s">        &quot;abcdef&quot;</span>
<span class="s">    Expected:</span>
<span class="s">        &#39;a...f&#39;</span>
<span class="s">    Got:</span>
<span class="s">        &#39;abcdef&#39;</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...myfile.doc&quot;, line 6, in myfile.doc</span>
<span class="s">    Failed example:</span>
<span class="s">        &quot;ajkml&quot;</span>
<span class="s">    Expected:</span>
<span class="s">        &#39;a...l&#39;</span>
<span class="s">    Got:</span>
<span class="s">        &#39;ajkml&#39;</span>
<span class="s">    **********************************************************************</span>
<span class="s">    1 items had failures:</span>
<span class="s">       2 of   3 in myfile.doc</span>
<span class="s">    ***Test Failed*** 2 failures.</span>

<span class="s">With -o ELLIPSIS specified, the second run, against just the first file, should</span>
<span class="s">produce no errors, and with -o NORMALIZE_WHITESPACE also specified, neither</span>
<span class="s">should the third, which ran against both files:</span>

<span class="s">    &gt;&gt;&gt; rc2, out2, err2</span>
<span class="s">    (0, b&#39;&#39;, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; rc3, out3, err3</span>
<span class="s">    (0, b&#39;&#39;, b&#39;&#39;)</span>

<span class="s">The fourth run uses FAIL_FAST, so we should see only one error:</span>

<span class="s">    &gt;&gt;&gt; rc4, err4</span>
<span class="s">    (1, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(out4))                # doctest: +ELLIPSIS</span>
<span class="s">    **********************************************************************</span>
<span class="s">    File &quot;...myfile.doc&quot;, line 4, in myfile.doc</span>
<span class="s">    Failed example:</span>
<span class="s">        &quot;abcdef&quot;</span>
<span class="s">    Expected:</span>
<span class="s">        &#39;a...f&#39;</span>
<span class="s">    Got:</span>
<span class="s">        &#39;abcdef&#39;</span>
<span class="s">    **********************************************************************</span>
<span class="s">    1 items had failures:</span>
<span class="s">       1 of   2 in myfile.doc</span>
<span class="s">    ***Test Failed*** 1 failures.</span>

<span class="s">The fifth test uses verbose with the two options, so we should get verbose</span>
<span class="s">success output for the tests in both files:</span>

<span class="s">    &gt;&gt;&gt; rc5, err5</span>
<span class="s">    (0, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(out5))</span>
<span class="s">    Trying:</span>
<span class="s">        1 + 1</span>
<span class="s">    Expecting:</span>
<span class="s">        2</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        &quot;abcdef&quot;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;a...f&#39;</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        &quot;ajkml&quot;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;a...l&#39;</span>
<span class="s">    ok</span>
<span class="s">    1 items passed all tests:</span>
<span class="s">       3 tests in myfile.doc</span>
<span class="s">    3 tests in 1 items.</span>
<span class="s">    3 passed and 0 failed.</span>
<span class="s">    Test passed.</span>
<span class="s">    Trying:</span>
<span class="s">        1 + 1</span>
<span class="s">    Expecting:</span>
<span class="s">        2</span>
<span class="s">    ok</span>
<span class="s">    Trying:</span>
<span class="s">        &quot;abc   def&quot;</span>
<span class="s">    Expecting:</span>
<span class="s">        &#39;abc def&#39;</span>
<span class="s">    ok</span>
<span class="s">    1 items had no tests:</span>
<span class="s">        myfile2</span>
<span class="s">    1 items passed all tests:</span>
<span class="s">       2 tests in myfile2.test_func</span>
<span class="s">    2 tests in 2 items.</span>
<span class="s">    2 passed and 0 failed.</span>
<span class="s">    Test passed.</span>

<span class="s">We should also check some typical error cases.</span>

<span class="s">Invalid file name:</span>

<span class="s">    &gt;&gt;&gt; rc, out, err = script_helper.assert_python_failure(</span>
<span class="s">    ...         &#39;-m&#39;, &#39;doctest&#39;, &#39;nosuchfile&#39;, TERM=&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; rc, out</span>
<span class="s">    (1, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(err))                    # doctest: +ELLIPSIS</span>
<span class="s">    Traceback (most recent call last):</span>
<span class="s">      ...</span>
<span class="s">    FileNotFoundError: [Errno ...] No such file or directory: &#39;nosuchfile&#39;</span>

<span class="s">Invalid doctest option:</span>

<span class="s">    &gt;&gt;&gt; rc, out, err = script_helper.assert_python_failure(</span>
<span class="s">    ...         &#39;-m&#39;, &#39;doctest&#39;, &#39;-o&#39;, &#39;nosuchoption&#39;, TERM=&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; rc, out</span>
<span class="s">    (2, b&#39;&#39;)</span>
<span class="s">    &gt;&gt;&gt; print(normalize(err))                    # doctest: +ELLIPSIS</span>
<span class="s">    usage...invalid...nosuchoption...</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="c">######################################################################</span>
<span class="c">## Main</span>
<span class="c">######################################################################</span>
</div>
<div class="viewcode-block" id="test_main"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_main">[docs]</a><span class="k">def</span> <span class="nf">test_main</span><span class="p">():</span>
    <span class="c"># Check the doctest cases in doctest itself:</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_doctest</span><span class="p">(</span><span class="n">doctest</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># Check the doctest cases defined here:</span>
    <span class="kn">from</span> <span class="nn">test</span> <span class="kn">import</span> <span class="n">test_doctest</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_doctest</span><span class="p">(</span><span class="n">test_doctest</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">io</span>

<div class="viewcode-block" id="test_coverage"><a class="viewcode-back" href="../../test.html#test.test_doctest.test_coverage">[docs]</a><span class="k">def</span> <span class="nf">test_coverage</span><span class="p">(</span><span class="n">coverdir</span><span class="p">):</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">support</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s">&#39;trace&#39;</span><span class="p">)</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">ignoredirs</span><span class="o">=</span><span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">base_prefix</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">base_exec_prefix</span><span class="p">,],</span>
                         <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tracer</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">&#39;test_main()&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">tracer</span><span class="o">.</span><span class="n">results</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Writing coverage results...&#39;</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">write_results</span><span class="p">(</span><span class="n">show_missing</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">coverdir</span><span class="o">=</span><span class="n">coverdir</span><span class="p">)</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;-c&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
        <span class="n">test_coverage</span><span class="p">(</span><span class="s">&#39;/tmp/doctest.cover&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">test_main</span><span class="p">()</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Weldon Henson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.0.',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>