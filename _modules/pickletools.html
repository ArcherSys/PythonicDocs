

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pickletools &mdash; ArcherBashPYDocs 1.0.0. documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ArcherBashPYDocs 1.0.0. documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> ArcherBashPYDocs</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">ArcherBashPYDocs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>pickletools</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for pickletools</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;&quot;Executable documentation&quot; for the pickle module.</span>

<span class="sd">Extensive comments about the pickle protocols and pickle-machine opcodes</span>
<span class="sd">can be found here.  Some functions meant for external use:</span>

<span class="sd">genops(pickle)</span>
<span class="sd">   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.</span>

<span class="sd">dis(pickle, out=None, memo=None, indentlevel=4)</span>
<span class="sd">   Print a symbolic disassembly of a pickle.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;dis&#39;</span><span class="p">,</span> <span class="s">&#39;genops&#39;</span><span class="p">,</span> <span class="s">&#39;optimize&#39;</span><span class="p">]</span>

<span class="n">bytes_types</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">bytes_types</span>

<span class="c"># Other ideas:</span>
<span class="c">#</span>
<span class="c"># - A pickle verifier:  read a pickle and check it exhaustively for</span>
<span class="c">#   well-formedness.  dis() does a lot of this already.</span>
<span class="c">#</span>
<span class="c"># - A protocol identifier:  examine a pickle and return its protocol number</span>
<span class="c">#   (== the highest .proto attr value among all the opcodes in the pickle).</span>
<span class="c">#   dis() already prints this info at the end.</span>
<span class="c">#</span>
<span class="c"># - A pickle optimizer:  for example, tuple-building code is sometimes more</span>
<span class="c">#   elaborate than necessary, catering for the possibility that the tuple</span>
<span class="c">#   is recursive.  Or lots of times a PUT is generated that&#39;s never accessed</span>
<span class="c">#   by a later GET.</span>


<span class="c"># &quot;A pickle&quot; is a program for a virtual pickle machine (PM, but more accurately</span>
<span class="c"># called an unpickling machine).  It&#39;s a sequence of opcodes, interpreted by the</span>
<span class="c"># PM, building an arbitrarily complex Python object.</span>
<span class="c">#</span>
<span class="c"># For the most part, the PM is very simple:  there are no looping, testing, or</span>
<span class="c"># conditional instructions, no arithmetic and no function calls.  Opcodes are</span>
<span class="c"># executed once each, from first to last, until a STOP opcode is reached.</span>
<span class="c">#</span>
<span class="c"># The PM has two data areas, &quot;the stack&quot; and &quot;the memo&quot;.</span>
<span class="c">#</span>
<span class="c"># Many opcodes push Python objects onto the stack; e.g., INT pushes a Python</span>
<span class="c"># integer object on the stack, whose value is gotten from a decimal string</span>
<span class="c"># literal immediately following the INT opcode in the pickle bytestream.  Other</span>
<span class="c"># opcodes take Python objects off the stack.  The result of unpickling is</span>
<span class="c"># whatever object is left on the stack when the final STOP opcode is executed.</span>
<span class="c">#</span>
<span class="c"># The memo is simply an array of objects, or it can be implemented as a dict</span>
<span class="c"># mapping little integers to objects.  The memo serves as the PM&#39;s &quot;long term</span>
<span class="c"># memory&quot;, and the little integers indexing the memo are akin to variable</span>
<span class="c"># names.  Some opcodes pop a stack object into the memo at a given index,</span>
<span class="c"># and others push a memo object at a given index onto the stack again.</span>
<span class="c">#</span>
<span class="c"># At heart, that&#39;s all the PM has.  Subtleties arise for these reasons:</span>
<span class="c">#</span>
<span class="c"># + Object identity.  Objects can be arbitrarily complex, and subobjects</span>
<span class="c">#   may be shared (for example, the list [a, a] refers to the same object a</span>
<span class="c">#   twice).  It can be vital that unpickling recreate an isomorphic object</span>
<span class="c">#   graph, faithfully reproducing sharing.</span>
<span class="c">#</span>
<span class="c"># + Recursive objects.  For example, after &quot;L = []; L.append(L)&quot;, L is a</span>
<span class="c">#   list, and L[0] is the same list.  This is related to the object identity</span>
<span class="c">#   point, and some sequences of pickle opcodes are subtle in order to</span>
<span class="c">#   get the right result in all cases.</span>
<span class="c">#</span>
<span class="c"># + Things pickle doesn&#39;t know everything about.  Examples of things pickle</span>
<span class="c">#   does know everything about are Python&#39;s builtin scalar and container</span>
<span class="c">#   types, like ints and tuples.  They generally have opcodes dedicated to</span>
<span class="c">#   them.  For things like module references and instances of user-defined</span>
<span class="c">#   classes, pickle&#39;s knowledge is limited.  Historically, many enhancements</span>
<span class="c">#   have been made to the pickle protocol in order to do a better (faster,</span>
<span class="c">#   and/or more compact) job on those.</span>
<span class="c">#</span>
<span class="c"># + Backward compatibility and micro-optimization.  As explained below,</span>
<span class="c">#   pickle opcodes never go away, not even when better ways to do a thing</span>
<span class="c">#   get invented.  The repertoire of the PM just keeps growing over time.</span>
<span class="c">#   For example, protocol 0 had two opcodes for building Python integers (INT</span>
<span class="c">#   and LONG), protocol 1 added three more for more-efficient pickling of short</span>
<span class="c">#   integers, and protocol 2 added two more for more-efficient pickling of</span>
<span class="c">#   long integers (before protocol 2, the only ways to pickle a Python long</span>
<span class="c">#   took time quadratic in the number of digits, for both pickling and</span>
<span class="c">#   unpickling).  &quot;Opcode bloat&quot; isn&#39;t so much a subtlety as a source of</span>
<span class="c">#   wearying complication.</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c"># Pickle protocols:</span>
<span class="c">#</span>
<span class="c"># For compatibility, the meaning of a pickle opcode never changes.  Instead new</span>
<span class="c"># pickle opcodes get added, and each version&#39;s unpickler can handle all the</span>
<span class="c"># pickle opcodes in all protocol versions to date.  So old pickles continue to</span>
<span class="c"># be readable forever.  The pickler can generally be told to restrict itself to</span>
<span class="c"># the subset of opcodes available under previous protocol versions too, so that</span>
<span class="c"># users can create pickles under the current version readable by older</span>
<span class="c"># versions.  However, a pickle does not contain its version number embedded</span>
<span class="c"># within it.  If an older unpickler tries to read a pickle using a later</span>
<span class="c"># protocol, the result is most likely an exception due to seeing an unknown (in</span>
<span class="c"># the older unpickler) opcode.</span>
<span class="c">#</span>
<span class="c"># The original pickle used what&#39;s now called &quot;protocol 0&quot;, and what was called</span>
<span class="c"># &quot;text mode&quot; before Python 2.3.  The entire pickle bytestream is made up of</span>
<span class="c"># printable 7-bit ASCII characters, plus the newline character, in protocol 0.</span>
<span class="c"># That&#39;s why it was called text mode.  Protocol 0 is small and elegant, but</span>
<span class="c"># sometimes painfully inefficient.</span>
<span class="c">#</span>
<span class="c"># The second major set of additions is now called &quot;protocol 1&quot;, and was called</span>
<span class="c"># &quot;binary mode&quot; before Python 2.3.  This added many opcodes with arguments</span>
<span class="c"># consisting of arbitrary bytes, including NUL bytes and unprintable &quot;high bit&quot;</span>
<span class="c"># bytes.  Binary mode pickles can be substantially smaller than equivalent</span>
<span class="c"># text mode pickles, and sometimes faster too; e.g., BININT represents a 4-byte</span>
<span class="c"># int as 4 bytes following the opcode, which is cheaper to unpickle than the</span>
<span class="c"># (perhaps) 11-character decimal string attached to INT.  Protocol 1 also added</span>
<span class="c"># a number of opcodes that operate on many stack elements at once (like APPENDS</span>
<span class="c"># and SETITEMS), and &quot;shortcut&quot; opcodes (like EMPTY_DICT and EMPTY_TUPLE).</span>
<span class="c">#</span>
<span class="c"># The third major set of additions came in Python 2.3, and is called &quot;protocol</span>
<span class="c"># 2&quot;.  This added:</span>
<span class="c">#</span>
<span class="c"># - A better way to pickle instances of new-style classes (NEWOBJ).</span>
<span class="c">#</span>
<span class="c"># - A way for a pickle to identify its protocol (PROTO).</span>
<span class="c">#</span>
<span class="c"># - Time- and space- efficient pickling of long ints (LONG{1,4}).</span>
<span class="c">#</span>
<span class="c"># - Shortcuts for small tuples (TUPLE{1,2,3}}.</span>
<span class="c">#</span>
<span class="c"># - Dedicated opcodes for bools (NEWTRUE, NEWFALSE).</span>
<span class="c">#</span>
<span class="c"># - The &quot;extension registry&quot;, a vector of popular objects that can be pushed</span>
<span class="c">#   efficiently by index (EXT{1,2,4}).  This is akin to the memo and GET, but</span>
<span class="c">#   the registry contents are predefined (there&#39;s nothing akin to the memo&#39;s</span>
<span class="c">#   PUT).</span>
<span class="c">#</span>
<span class="c"># Another independent change with Python 2.3 is the abandonment of any</span>
<span class="c"># pretense that it might be safe to load pickles received from untrusted</span>
<span class="c"># parties -- no sufficient security analysis has been done to guarantee</span>
<span class="c"># this and there isn&#39;t a use case that warrants the expense of such an</span>
<span class="c"># analysis.</span>
<span class="c">#</span>
<span class="c"># To this end, all tests for __safe_for_unpickling__ or for</span>
<span class="c"># copyreg.safe_constructors are removed from the unpickling code.</span>
<span class="c"># References to these variables in the descriptions below are to be seen</span>
<span class="c"># as describing unpickling in Python 2.2 and before.</span>


<span class="c"># Meta-rule:  Descriptions are stored in instances of descriptor objects,</span>
<span class="c"># with plain constructors.  No meta-language is defined from which</span>
<span class="c"># descriptors could be constructed.  If you want, e.g., XML, write a little</span>
<span class="c"># program to generate XML from the objects.</span>

<span class="c">##############################################################################</span>
<span class="c"># Some pickle opcodes have an argument, following the opcode in the</span>
<span class="c"># bytestream.  An argument is of a specific type, described by an instance</span>
<span class="c"># of ArgumentDescriptor.  These are not to be confused with arguments taken</span>
<span class="c"># off the stack -- ArgumentDescriptor applies only to arguments embedded in</span>
<span class="c"># the opcode stream, immediately following an opcode.</span>

<span class="c"># Represents the number of bytes consumed by an argument delimited by the</span>
<span class="c"># next newline character.</span>
<span class="n">UP_TO_NEWLINE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c"># Represents the number of bytes consumed by a two-argument opcode where</span>
<span class="c"># the first argument gives the number of bytes in the second argument.</span>
<span class="n">TAKEN_FROM_ARGUMENT1</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>   <span class="c"># num bytes is 1-byte unsigned int</span>
<span class="n">TAKEN_FROM_ARGUMENT4</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>   <span class="c"># num bytes is 4-byte signed little-endian int</span>
<span class="n">TAKEN_FROM_ARGUMENT4U</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>   <span class="c"># num bytes is 4-byte unsigned little-endian int</span>
<span class="n">TAKEN_FROM_ARGUMENT8U</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>   <span class="c"># num bytes is 8-byte unsigned little-endian int</span>

<span class="k">class</span> <span class="nc">ArgumentDescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c"># name of descriptor record, also a module global name; a string</span>
        <span class="s">&#39;name&#39;</span><span class="p">,</span>

        <span class="c"># length of argument, in bytes; an int; UP_TO_NEWLINE and</span>
        <span class="c"># TAKEN_FROM_ARGUMENT{1,4,8} are negative values for variable-length</span>
        <span class="c"># cases</span>
        <span class="s">&#39;n&#39;</span><span class="p">,</span>

        <span class="c"># a function taking a file-like object, reading this kind of argument</span>
        <span class="c"># from the object at the current position, advancing the current</span>
        <span class="c"># position by n bytes, and returning the value of the argument</span>
        <span class="s">&#39;reader&#39;</span><span class="p">,</span>

        <span class="c"># human-readable docs for this arg descriptor; a string</span>
        <span class="s">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                                       <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT4U</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT8U</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">reader</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">unpack</span> <span class="k">as</span> <span class="n">_unpack</span>

<span class="k">def</span> <span class="nf">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_uint1(io.BytesIO(b&#39;\xff&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read uint1&quot;</span><span class="p">)</span>

<span class="n">uint1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&#39;uint1&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint1</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s">&quot;One-byte unsigned integer.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_uint2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_uint2(io.BytesIO(b&#39;\xff\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_uint2(io.BytesIO(b&#39;\xff\xff&#39;))</span>
<span class="sd">    65535</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s">&quot;&lt;H&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read uint2&quot;</span><span class="p">)</span>

<span class="n">uint2</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&#39;uint2&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint2</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Two-byte unsigned integer, little-endian.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_int4(io.BytesIO(b&#39;\xff\x00\x00\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_int4(io.BytesIO(b&#39;\x00\x00\x00\x80&#39;)) == -(2**31)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s">&quot;&lt;i&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read int4&quot;</span><span class="p">)</span>

<span class="n">int4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
           <span class="n">name</span><span class="o">=</span><span class="s">&#39;int4&#39;</span><span class="p">,</span>
           <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
           <span class="n">reader</span><span class="o">=</span><span class="n">read_int4</span><span class="p">,</span>
           <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Four-byte signed integer, little-endian, 2&#39;s complement.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_uint4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_uint4(io.BytesIO(b&#39;\xff\x00\x00\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_uint4(io.BytesIO(b&#39;\x00\x00\x00\x80&#39;)) == 2**31</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read uint4&quot;</span><span class="p">)</span>

<span class="n">uint4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&#39;uint4&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint4</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Four-byte unsigned integer, little-endian.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_uint8</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_uint8(io.BytesIO(b&#39;\xff\x00\x00\x00\x00\x00\x00\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_uint8(io.BytesIO(b&#39;\xff&#39; * 8)) == 2**64-1</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s">&quot;&lt;Q&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read uint8&quot;</span><span class="p">)</span>

<span class="n">uint8</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&#39;uint8&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint8</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Eight-byte unsigned integer, little-endian.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;&#39;abcd&#39;\nefg\n&quot;))</span>
<span class="sd">    &#39;abcd&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;\n&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: no string quotes around b&#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;\n&quot;), stripquotes=False)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;&#39;&#39;\n&quot;))</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(b&#39;&quot;abcd&quot;&#39;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: no newline found when trying to read stringnl</span>

<span class="sd">    Embedded escapes are undone in the result.</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl(io.BytesIO(br&quot;&#39;a\n\\b\x00c\td&#39;&quot; + b&quot;\n&#39;e&#39;&quot;))</span>
<span class="sd">    &#39;a\n\\b\x00c\td&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no newline found when trying to read stringnl&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c"># lose the newline</span>

    <span class="k">if</span> <span class="n">stripquotes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="p">(</span><span class="n">b</span><span class="s">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">b</span><span class="s">&quot;&#39;&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;strinq quote </span><span class="si">%r</span><span class="s"> not found at both &quot;</span>
                                     <span class="s">&quot;ends of </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no string quotes around </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">decode</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">escape_decode</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;ascii&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">stringnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
               <span class="n">name</span><span class="o">=</span><span class="s">&#39;stringnl&#39;</span><span class="p">,</span>
               <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
               <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl</span><span class="p">,</span>
               <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated string.</span>

<span class="s">                   This is a repr-style string, with embedded escapes, and</span>
<span class="s">                   bracketing quotes.</span>
<span class="s">                   &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">stringnl_noescape</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s">&#39;stringnl_noescape&#39;</span><span class="p">,</span>
                        <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                        <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl_noescape</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated string.</span>

<span class="s">                        This is a str-style string, without embedded escapes,</span>
<span class="s">                        or bracketing quotes.  It should consist solely of</span>
<span class="s">                        printable ASCII characters.</span>
<span class="s">                        &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_stringnl_noescape_pair</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl_noescape_pair(io.BytesIO(b&quot;Queue\nEmpty\njunk&quot;))</span>
<span class="sd">    &#39;Queue Empty&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

<span class="n">stringnl_noescape_pair</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                             <span class="n">name</span><span class="o">=</span><span class="s">&#39;stringnl_noescape_pair&#39;</span><span class="p">,</span>
                             <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                             <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl_noescape_pair</span><span class="p">,</span>
                             <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A pair of newline-terminated strings.</span>

<span class="s">                             These are str-style strings, without embedded</span>
<span class="s">                             escapes, or bracketing quotes.  They should</span>
<span class="s">                             consist solely of printable ASCII characters.</span>
<span class="s">                             The pair is returned as a single string, with</span>
<span class="s">                             a single blank separating the two strings.</span>
<span class="s">                             &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_string1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_string1(io.BytesIO(b&quot;\x00&quot;))</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string1(io.BytesIO(b&quot;\x03abcdef&quot;))</span>
<span class="sd">    &#39;abc&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;latin-1&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a string1, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">string1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;string1&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_string1</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted string.</span>

<span class="s">              The first argument is a 1-byte unsigned int giving the number</span>
<span class="s">              of bytes in the string, and the second argument is that many</span>
<span class="s">              bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_string4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x00\x00\x00\x00abc&quot;))</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x03\x00\x00\x00abcdef&quot;))</span>
<span class="sd">    &#39;abc&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x00\x00\x00\x03abcdef&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 50331648 bytes in a string4, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;string4 byte count &lt; 0: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;latin-1&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a string4, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">string4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;string4&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_string4</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted string.</span>

<span class="s">              The first argument is a 4-byte little-endian signed int giving</span>
<span class="s">              the number of bytes in the string, and the second argument is</span>
<span class="s">              that many bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_bytes1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x00&quot;))</span>
<span class="sd">    b&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x03abcdef&quot;))</span>
<span class="sd">    b&#39;abc&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a bytes1, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">bytes1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;bytes1&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_bytes1</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted bytes string.</span>

<span class="s">              The first argument is a 1-byte unsigned int giving the number</span>
<span class="s">              of bytes in the string, and the second argument is that many</span>
<span class="s">              bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_bytes1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x00&quot;))</span>
<span class="sd">    b&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x03abcdef&quot;))</span>
<span class="sd">    b&#39;abc&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a bytes1, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">bytes1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;bytes1&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_bytes1</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted bytes string.</span>

<span class="s">              The first argument is a 1-byte unsigned int giving the number</span>
<span class="s">              of bytes, and the second argument is that many bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_bytes4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x00\x00\x00\x00abc&quot;))</span>
<span class="sd">    b&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x03\x00\x00\x00abcdef&quot;))</span>
<span class="sd">    b&#39;abc&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x00\x00\x00\x03abcdef&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 50331648 bytes in a bytes4, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;bytes4 byte count &gt; sys.maxsize: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a bytes4, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">bytes4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;bytes4&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4U</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_bytes4</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted bytes string.</span>

<span class="s">              The first argument is a 4-byte little-endian unsigned int giving</span>
<span class="s">              the number of bytes, and the second argument is that many bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_bytes8</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io, struct, sys</span>
<span class="sd">    &gt;&gt;&gt; read_bytes8(io.BytesIO(b&quot;\x00\x00\x00\x00\x00\x00\x00\x00abc&quot;))</span>
<span class="sd">    b&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_bytes8(io.BytesIO(b&quot;\x03\x00\x00\x00\x00\x00\x00\x00abcdef&quot;))</span>
<span class="sd">    b&#39;abc&#39;</span>
<span class="sd">    &gt;&gt;&gt; bigsize8 = struct.pack(&quot;&lt;Q&quot;, sys.maxsize//3)</span>
<span class="sd">    &gt;&gt;&gt; read_bytes8(io.BytesIO(bigsize8 + b&quot;abcdef&quot;))  #doctest: +ELLIPSIS</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected ... bytes in a bytes8, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint8</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;bytes8 byte count &gt; sys.maxsize: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a bytes8, but only </span><span class="si">%d</span><span class="s"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">bytes8</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&quot;bytes8&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT8U</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_bytes8</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted bytes string.</span>

<span class="s">              The first argument is a 8-byte little-endian unsigned int giving</span>
<span class="s">              the number of bytes, and the second argument is that many bytes.</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_unicodestringnl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_unicodestringnl(io.BytesIO(b&quot;abc\\uabcd\njunk&quot;)) == &#39;abc\uabcd&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no newline found when trying to read &quot;</span>
                         <span class="s">&quot;unicodestringnl&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c"># lose the newline</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;raw-unicode-escape&#39;</span><span class="p">)</span>

<span class="n">unicodestringnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                      <span class="n">name</span><span class="o">=</span><span class="s">&#39;unicodestringnl&#39;</span><span class="p">,</span>
                      <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                      <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestringnl</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated Unicode string.</span>

<span class="s">                      This is raw-unicode-escape encoded, so consists of</span>
<span class="s">                      printable ASCII characters, and may contain embedded</span>
<span class="s">                      escape sequences.</span>
<span class="s">                      &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_unicodestring1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; s = &#39;abcd\uabcd&#39;</span>
<span class="sd">    &gt;&gt;&gt; enc = s.encode(&#39;utf-8&#39;)</span>
<span class="sd">    &gt;&gt;&gt; enc</span>
<span class="sd">    b&#39;abcd\xea\xaf\x8d&#39;</span>
<span class="sd">    &gt;&gt;&gt; n = bytes([len(enc)])  # little-endian 1-byte length</span>
<span class="sd">    &gt;&gt;&gt; t = read_unicodestring1(io.BytesIO(n + enc + b&#39;junk&#39;))</span>
<span class="sd">    &gt;&gt;&gt; s == t</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; read_unicodestring1(io.BytesIO(n + enc[:-1]))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 7 bytes in a unicodestring1, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="s">&#39;surrogatepass&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a unicodestring1, but only </span><span class="si">%d</span><span class="s"> &quot;</span>
                     <span class="s">&quot;remain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">unicodestring1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s">&quot;unicodestring1&quot;</span><span class="p">,</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
                    <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestring1</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted Unicode string.</span>

<span class="s">                    The first argument is a 1-byte little-endian signed int</span>
<span class="s">                    giving the number of bytes in the string, and the second</span>
<span class="s">                    argument-- the UTF-8 encoding of the Unicode string --</span>
<span class="s">                    contains that many bytes.</span>
<span class="s">                    &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_unicodestring4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; s = &#39;abcd\uabcd&#39;</span>
<span class="sd">    &gt;&gt;&gt; enc = s.encode(&#39;utf-8&#39;)</span>
<span class="sd">    &gt;&gt;&gt; enc</span>
<span class="sd">    b&#39;abcd\xea\xaf\x8d&#39;</span>
<span class="sd">    &gt;&gt;&gt; n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length</span>
<span class="sd">    &gt;&gt;&gt; t = read_unicodestring4(io.BytesIO(n + enc + b&#39;junk&#39;))</span>
<span class="sd">    &gt;&gt;&gt; s == t</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; read_unicodestring4(io.BytesIO(n + enc[:-1]))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 7 bytes in a unicodestring4, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unicodestring4 byte count &gt; sys.maxsize: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="s">&#39;surrogatepass&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a unicodestring4, but only </span><span class="si">%d</span><span class="s"> &quot;</span>
                     <span class="s">&quot;remain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">unicodestring4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s">&quot;unicodestring4&quot;</span><span class="p">,</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4U</span><span class="p">,</span>
                    <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestring4</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted Unicode string.</span>

<span class="s">                    The first argument is a 4-byte little-endian signed int</span>
<span class="s">                    giving the number of bytes in the string, and the second</span>
<span class="s">                    argument-- the UTF-8 encoding of the Unicode string --</span>
<span class="s">                    contains that many bytes.</span>
<span class="s">                    &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_unicodestring8</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; s = &#39;abcd\uabcd&#39;</span>
<span class="sd">    &gt;&gt;&gt; enc = s.encode(&#39;utf-8&#39;)</span>
<span class="sd">    &gt;&gt;&gt; enc</span>
<span class="sd">    b&#39;abcd\xea\xaf\x8d&#39;</span>
<span class="sd">    &gt;&gt;&gt; n = bytes([len(enc)]) + bytes(7)  # little-endian 8-byte length</span>
<span class="sd">    &gt;&gt;&gt; t = read_unicodestring8(io.BytesIO(n + enc + b&#39;junk&#39;))</span>
<span class="sd">    &gt;&gt;&gt; s == t</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; read_unicodestring8(io.BytesIO(n + enc[:-1]))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 7 bytes in a unicodestring8, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint8</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unicodestring8 byte count &gt; sys.maxsize: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="s">&#39;surrogatepass&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;expected </span><span class="si">%d</span><span class="s"> bytes in a unicodestring8, but only </span><span class="si">%d</span><span class="s"> &quot;</span>
                     <span class="s">&quot;remain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

<span class="n">unicodestring8</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s">&quot;unicodestring8&quot;</span><span class="p">,</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT8U</span><span class="p">,</span>
                    <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestring8</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A counted Unicode string.</span>

<span class="s">                    The first argument is a 8-byte little-endian signed int</span>
<span class="s">                    giving the number of bytes in the string, and the second</span>
<span class="s">                    argument-- the UTF-8 encoding of the Unicode string --</span>
<span class="s">                    contains that many bytes.</span>
<span class="s">                    &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_decimalnl_short</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_decimalnl_short(io.BytesIO(b&quot;1234\n56&quot;))</span>
<span class="sd">    1234</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_short(io.BytesIO(b&quot;1234L\n56&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: invalid literal for int() with base 10: b&#39;1234L&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c"># There&#39;s a hack for True and False here.</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">b</span><span class="s">&quot;00&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="n">b</span><span class="s">&quot;01&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_decimalnl_long</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_long(io.BytesIO(b&quot;1234L\n56&quot;))</span>
<span class="sd">    1234</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_long(io.BytesIO(b&quot;123456789012345678901234L\n6&quot;))</span>
<span class="sd">    123456789012345678901234</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">b</span><span class="s">&#39;L&#39;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="n">decimalnl_short</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                      <span class="n">name</span><span class="o">=</span><span class="s">&#39;decimalnl_short&#39;</span><span class="p">,</span>
                      <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                      <span class="n">reader</span><span class="o">=</span><span class="n">read_decimalnl_short</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated decimal integer literal.</span>

<span class="s">                          This never has a trailing &#39;L&#39;, and the integer fit</span>
<span class="s">                          in a short Python int on the box where the pickle</span>
<span class="s">                          was written -- but there&#39;s no guarantee it will fit</span>
<span class="s">                          in a short Python int on the box where the pickle</span>
<span class="s">                          is read.</span>
<span class="s">                          &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">decimalnl_long</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                     <span class="n">name</span><span class="o">=</span><span class="s">&#39;decimalnl_long&#39;</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                     <span class="n">reader</span><span class="o">=</span><span class="n">read_decimalnl_long</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated decimal integer literal.</span>

<span class="s">                         This has a trailing &#39;L&#39;, and can represent integers</span>
<span class="s">                         of any size.</span>
<span class="s">                         &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_floatnl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_floatnl(io.BytesIO(b&quot;-1.25\n6&quot;))</span>
<span class="sd">    -1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="n">floatnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s">&#39;floatnl&#39;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_floatnl</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A newline-terminated decimal floating literal.</span>

<span class="s">              In general this requires 17 significant digits for roundtrip</span>
<span class="s">              identity, and pickling then unpickling infinities, NaNs, and</span>
<span class="s">              minus zero doesn&#39;t work across boxes, or on some boxes even</span>
<span class="s">              on itself (e.g., Windows can&#39;t read the strings it produces</span>
<span class="s">              for infinities or NaNs).</span>
<span class="s">              &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_float8</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io, struct</span>
<span class="sd">    &gt;&gt;&gt; raw = struct.pack(&quot;&gt;d&quot;, -1.25)</span>
<span class="sd">    &gt;&gt;&gt; raw</span>
<span class="sd">    b&#39;\xbf\xf4\x00\x00\x00\x00\x00\x00&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_float8(io.BytesIO(raw + b&quot;\n&quot;))</span>
<span class="sd">    -1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s">&quot;&gt;d&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read float8&quot;</span><span class="p">)</span>


<span class="n">float8</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s">&#39;float8&#39;</span><span class="p">,</span>
             <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
             <span class="n">reader</span><span class="o">=</span><span class="n">read_float8</span><span class="p">,</span>
             <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;An 8-byte binary representation of a float, big-endian.</span>

<span class="s">             The format is unique to Python, and shared with the struct</span>
<span class="s">             module (format string &#39;&gt;d&#39;) &quot;in theory&quot; (the struct and pickle</span>
<span class="s">             implementations don&#39;t share the code -- they should).  It&#39;s</span>
<span class="s">             strongly related to the IEEE-754 double format, and, in normal</span>
<span class="s">             cases, is in fact identical to the big-endian 754 double format.</span>
<span class="s">             On other boxes the dynamic range is limited to that of a 754</span>
<span class="s">             double, and &quot;add a half and chop&quot; rounding is used to reduce</span>
<span class="s">             the precision to 53 bits.  However, even on a 754 box,</span>
<span class="s">             infinities, NaNs, and minus zero may not be handled correctly</span>
<span class="s">             (may not survive roundtrip pickling intact).</span>
<span class="s">             &quot;&quot;&quot;</span><span class="p">)</span>

<span class="c"># Protocol 2 formats</span>

<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">decode_long</span>

<span class="k">def</span> <span class="nf">read_long1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x00&quot;))</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x02\xff\x00&quot;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x02\xff\x7f&quot;))</span>
<span class="sd">    32767</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x02\x00\xff&quot;))</span>
<span class="sd">    -256</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x02\x00\x80&quot;))</span>
<span class="sd">    -32768</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read long1&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decode_long</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">long1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;long1&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
    <span class="n">reader</span><span class="o">=</span><span class="n">read_long1</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A binary long, little-endian, using 1-byte size.</span>

<span class="s">    This first reads one byte as an unsigned size, then reads that</span>
<span class="s">    many bytes and interprets them as a little-endian 2&#39;s-complement long.</span>
<span class="s">    If the size is 0, that&#39;s taken as a shortcut for the long 0L.</span>
<span class="s">    &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_long4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; read_long4(io.BytesIO(b&quot;\x02\x00\x00\x00\xff\x00&quot;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_long4(io.BytesIO(b&quot;\x02\x00\x00\x00\xff\x7f&quot;))</span>
<span class="sd">    32767</span>
<span class="sd">    &gt;&gt;&gt; read_long4(io.BytesIO(b&quot;\x02\x00\x00\x00\x00\xff&quot;))</span>
<span class="sd">    -256</span>
<span class="sd">    &gt;&gt;&gt; read_long4(io.BytesIO(b&quot;\x02\x00\x00\x00\x00\x80&quot;))</span>
<span class="sd">    -32768</span>
<span class="sd">    &gt;&gt;&gt; read_long1(io.BytesIO(b&quot;\x00\x00\x00\x00&quot;))</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;long4 byte count &lt; 0: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;not enough data in stream to read long4&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decode_long</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">long4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;long4&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
    <span class="n">reader</span><span class="o">=</span><span class="n">read_long4</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;A binary representation of a long, little-endian.</span>

<span class="s">    This first reads four bytes as a signed size (but requires the</span>
<span class="s">    size to be &gt;= 0), then reads that many bytes and interprets them</span>
<span class="s">    as a little-endian 2&#39;s-complement long.  If the size is 0, that&#39;s taken</span>
<span class="s">    as a shortcut for the int 0, although LONG1 should really be used</span>
<span class="s">    then instead (and in any case where # of bytes &lt; 256).</span>
<span class="s">    &quot;&quot;&quot;</span><span class="p">)</span>


<span class="c">##############################################################################</span>
<span class="c"># Object descriptors.  The stack used by the pickle machine holds objects,</span>
<span class="c"># and in the stack_before and stack_after attributes of OpcodeInfo</span>
<span class="c"># descriptors we need names to describe the various types of objects that can</span>
<span class="c"># appear on the stack.</span>

<span class="k">class</span> <span class="nc">StackObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c"># name of descriptor record, for info only</span>
        <span class="s">&#39;name&#39;</span><span class="p">,</span>

        <span class="c"># type of object, or tuple of type objects (meaning the object can</span>
        <span class="c"># be of any type in the tuple)</span>
        <span class="s">&#39;obtype&#39;</span><span class="p">,</span>

        <span class="c"># human-readable docs for this kind of stack object; a string</span>
        <span class="s">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obtype</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">contained</span> <span class="ow">in</span> <span class="n">obtype</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">contained</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obtype</span> <span class="o">=</span> <span class="n">obtype</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="n">pyint</span> <span class="o">=</span> <span class="n">pylong</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python integer object.&quot;</span><span class="p">)</span>

<span class="n">pyinteger_or_bool</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;int_or_bool&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python integer or boolean object.&quot;</span><span class="p">)</span>

<span class="n">pybool</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python boolean object.&quot;</span><span class="p">)</span>

<span class="n">pyfloat</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python float object.&quot;</span><span class="p">)</span>

<span class="n">pybytes_or_str</span> <span class="o">=</span> <span class="n">pystring</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;bytes_or_str&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python bytes or (Unicode) string object.&quot;</span><span class="p">)</span>

<span class="n">pybytes</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;bytes&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">bytes</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python bytes object.&quot;</span><span class="p">)</span>

<span class="n">pyunicode</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python (Unicode) string object.&quot;</span><span class="p">)</span>

<span class="n">pynone</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;None&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;The Python None object.&quot;</span><span class="p">)</span>

<span class="n">pytuple</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;tuple&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python tuple object.&quot;</span><span class="p">)</span>

<span class="n">pylist</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;list&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python list object.&quot;</span><span class="p">)</span>

<span class="n">pydict</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;dict&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python dict object.&quot;</span><span class="p">)</span>

<span class="n">pyset</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;set&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">set</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python set object.&quot;</span><span class="p">)</span>

<span class="n">pyfrozenset</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;frozenset&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">set</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;A Python frozenset object.&quot;</span><span class="p">)</span>

<span class="n">anyobject</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;any&#39;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Any kind of object whatsoever.&quot;</span><span class="p">)</span>

<span class="n">markobject</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;mark&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="n">StackObject</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;&#39;The mark&#39; is a unique object.</span>

<span class="s">Opcodes that operate on a variable number of objects</span>
<span class="s">generally don&#39;t embed the count of objects in the opcode,</span>
<span class="s">or pull it off the stack.  Instead the MARK opcode is used</span>
<span class="s">to push a special marker object on the stack, and then</span>
<span class="s">some other opcodes grab all the objects from the top of</span>
<span class="s">the stack down to (but not including) the topmost marker</span>
<span class="s">object.</span>
<span class="s">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">stackslice</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;stackslice&quot;</span><span class="p">,</span>
    <span class="n">obtype</span><span class="o">=</span><span class="n">StackObject</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;An object representing a contiguous slice of the stack.</span>

<span class="s">This is used in conjunction with markobject, to represent all</span>
<span class="s">of the stack following the topmost markobject.  For example,</span>
<span class="s">the POP_MARK opcode changes the stack from</span>

<span class="s">    [..., markobject, stackslice]</span>
<span class="s">to</span>
<span class="s">    [...]</span>

<span class="s">No matter how many object are on the stack after the topmost</span>
<span class="s">markobject, POP_MARK gets rid of all of them (including the</span>
<span class="s">topmost markobject too).</span>
<span class="s">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c">##############################################################################</span>
<span class="c"># Descriptors for pickle opcodes.</span>

<span class="k">class</span> <span class="nc">OpcodeInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c"># symbolic name of opcode; a string</span>
        <span class="s">&#39;name&#39;</span><span class="p">,</span>

        <span class="c"># the code used in a bytestream to represent the opcode; a</span>
        <span class="c"># one-character string</span>
        <span class="s">&#39;code&#39;</span><span class="p">,</span>

        <span class="c"># If the opcode has an argument embedded in the byte string, an</span>
        <span class="c"># instance of ArgumentDescriptor specifying its type.  Note that</span>
        <span class="c"># arg.reader(s) can be used to read and decode the argument from</span>
        <span class="c"># the bytestream s, and arg.doc documents the format of the raw</span>
        <span class="c"># argument bytes.  If the opcode doesn&#39;t have an argument embedded</span>
        <span class="c"># in the bytestream, arg should be None.</span>
        <span class="s">&#39;arg&#39;</span><span class="p">,</span>

        <span class="c"># what the stack looks like before this opcode runs; a list</span>
        <span class="s">&#39;stack_before&#39;</span><span class="p">,</span>

        <span class="c"># what the stack looks like after this opcode runs; a list</span>
        <span class="s">&#39;stack_after&#39;</span><span class="p">,</span>

        <span class="c"># the protocol number in which this opcode was introduced; an int</span>
        <span class="s">&#39;proto&#39;</span><span class="p">,</span>

        <span class="c"># human-readable docs for this opcode; a string</span>
        <span class="s">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
                 <span class="n">stack_before</span><span class="p">,</span> <span class="n">stack_after</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>

        <span class="k">assert</span> <span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ArgumentDescriptor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_before</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack_before</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">StackObject</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_before</span> <span class="o">=</span> <span class="n">stack_before</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_after</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack_after</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">StackObject</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_after</span> <span class="o">=</span> <span class="n">stack_after</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">proto</span> <span class="o">&lt;=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proto</span> <span class="o">=</span> <span class="n">proto</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">OpcodeInfo</span>
<span class="n">opcodes</span> <span class="o">=</span> <span class="p">[</span>

    <span class="c"># Ways to spell integers.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;INT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyinteger_or_bool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push an integer or bool.</span>

<span class="s">      The argument is a newline-terminated decimal literal string.</span>

<span class="s">      The intent may have been that this always fit in a short Python int,</span>
<span class="s">      but INT can be generated in pickles written on a 64-bit box that</span>
<span class="s">      require a Python long on a 32-bit box.  The difference between this</span>
<span class="s">      and LONG then is that INT skips a trailing &#39;L&#39;, and produces a short</span>
<span class="s">      int whenever possible.</span>

<span class="s">      Another difference is due to that, when bool was introduced as a</span>
<span class="s">      distinct type in 2.3, builtin names True and False were also added to</span>
<span class="s">      2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,</span>
<span class="s">      True gets pickled as INT + &quot;I01</span><span class="se">\\</span><span class="s">n&quot;, and False as INT + &quot;I00</span><span class="se">\\</span><span class="s">n&quot;.</span>
<span class="s">      Leading zeroes are never produced for a genuine integer.  The 2.3</span>
<span class="s">      (and later) unpicklers special-case these and return bool instead;</span>
<span class="s">      earlier unpicklers ignore the leading &quot;0&quot; and return the int.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BININT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;J&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a four-byte signed integer.</span>

<span class="s">      This handles the full range of Python (short) integers on a 32-bit</span>
<span class="s">      box, directly as binary bytes (1 for the opcode and 4 for the integer).</span>
<span class="s">      If the integer is non-negative and fits in 1 or 2 bytes, pickling via</span>
<span class="s">      BININT1 or BININT2 saves space.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BININT1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;K&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a one-byte unsigned integer.</span>

<span class="s">      This is a space optimization for pickling very small non-negative ints,</span>
<span class="s">      in range(256).</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BININT2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;M&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint2</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a two-byte unsigned integer.</span>

<span class="s">      This is a space optimization for pickling small positive ints, in</span>
<span class="s">      range(256, 2**16).  Integers in range(256) can also be pickled via</span>
<span class="s">      BININT2, but BININT1 instead saves a byte.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;LONG&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;L&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_long</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a long integer.</span>

<span class="s">      The same as INT, except that the literal ends with &#39;L&#39;, and always</span>
<span class="s">      unpickles to a Python long.  There doesn&#39;t seem a real purpose to the</span>
<span class="s">      trailing &#39;L&#39;.</span>

<span class="s">      Note that LONG takes time quadratic in the number of digits when</span>
<span class="s">      unpickling (this is simply due to the nature of decimal-&gt;binary</span>
<span class="s">      conversion).  Proto 2 added linear-time (in C; still quadratic-time</span>
<span class="s">      in Python) LONG1 and LONG4 opcodes.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;LONG1&quot;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8a</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">long1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Long integer using one-byte length.</span>

<span class="s">      A more efficient encoding of a Python long; the long1 encoding</span>
<span class="s">      says it all.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;LONG4&quot;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8b</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">long4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Long integer using found-byte length.</span>

<span class="s">      A more efficient encoding of a Python long; the long4 encoding</span>
<span class="s">      says it all.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to spell strings (8-bit, not Unicode).</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;STRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;S&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes_or_str</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s">      The argument is a repr-style string, with bracketing quote characters,</span>
<span class="s">      and perhaps embedded escapes.  The argument extends until the next</span>
<span class="s">      newline character.  These are usually decoded into a str instance</span>
<span class="s">      using the encoding given to the Unpickler constructor. or the default,</span>
<span class="s">      &#39;ASCII&#39;.  If the encoding given was &#39;bytes&#39; however, they will be</span>
<span class="s">      decoded as bytes object instead.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINSTRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">string4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes_or_str</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s">      There are two arguments: the first is a 4-byte little-endian</span>
<span class="s">      signed int giving the number of bytes in the string, and the</span>
<span class="s">      second is that many bytes, which are taken literally as the string</span>
<span class="s">      content.  These are usually decoded into a str instance using the</span>
<span class="s">      encoding given to the Unpickler constructor. or the default,</span>
<span class="s">      &#39;ASCII&#39;.  If the encoding given was &#39;bytes&#39; however, they will be</span>
<span class="s">      decoded as bytes object instead.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;SHORT_BINSTRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;U&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">string1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes_or_str</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s">      There are two arguments: the first is a 1-byte unsigned int giving</span>
<span class="s">      the number of bytes in the string, and the second is that many</span>
<span class="s">      bytes, which are taken literally as the string content.  These are</span>
<span class="s">      usually decoded into a str instance using the encoding given to</span>
<span class="s">      the Unpickler constructor. or the default, &#39;ASCII&#39;.  If the</span>
<span class="s">      encoding given was &#39;bytes&#39; however, they will be decoded as bytes</span>
<span class="s">      object instead.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Bytes (protocol 3 only; older protocols don&#39;t support bytes at all)</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINBYTES&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">bytes4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python bytes object.</span>

<span class="s">      There are two arguments:  the first is a 4-byte little-endian unsigned int</span>
<span class="s">      giving the number of bytes, and the second is that many bytes, which are</span>
<span class="s">      taken literally as the bytes content.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;SHORT_BINBYTES&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">bytes1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python bytes object.</span>

<span class="s">      There are two arguments:  the first is a 1-byte unsigned int giving</span>
<span class="s">      the number of bytes, and the second is that many bytes, which are taken</span>
<span class="s">      literally as the string content.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINBYTES8&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8e</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">bytes8</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybytes</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python bytes object.</span>

<span class="s">      There are two arguments:  the first is a 8-byte unsigned int giving</span>
<span class="s">      the number of bytes in the string, and the second is that many bytes,</span>
<span class="s">      which are taken literally as the string content.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to spell None.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;NONE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;N&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pynone</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push None on the stack.&quot;</span><span class="p">),</span>

    <span class="c"># Ways to spell bools, starting with proto 2.  See INT for how this was</span>
    <span class="c"># done before proto 2.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;NEWTRUE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x88</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;True.</span>

<span class="s">      Push True onto the stack.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;NEWFALSE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x89</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;True.</span>

<span class="s">      Push False onto the stack.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to spell Unicode strings.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;UNICODE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;V&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestringnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c"># this may be pure-text, but it&#39;s a later addition</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s">      The argument is a raw-unicode-escape encoding of a Unicode string,</span>
<span class="s">      and so may contain embedded escape sequences.  The argument extends</span>
<span class="s">      until the next newline character.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;SHORT_BINUNICODE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8c</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestring1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s">      There are two arguments:  the first is a 1-byte little-endian signed int</span>
<span class="s">      giving the number of bytes in the string.  The second is that many</span>
<span class="s">      bytes, and is the UTF-8 encoding of the Unicode string.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINUNICODE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestring4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s">      There are two arguments:  the first is a 4-byte little-endian unsigned int</span>
<span class="s">      giving the number of bytes in the string.  The second is that many</span>
<span class="s">      bytes, and is the UTF-8 encoding of the Unicode string.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINUNICODE8&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8d</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestring8</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s">      There are two arguments:  the first is a 8-byte little-endian signed int</span>
<span class="s">      giving the number of bytes in the string.  The second is that many</span>
<span class="s">      bytes, and is the UTF-8 encoding of the Unicode string.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to spell floats.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;FLOAT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">floatnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyfloat</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Newline-terminated decimal float literal.</span>

<span class="s">      The argument is repr(a_float), and in general requires 17 significant</span>
<span class="s">      digits for roundtrip conversion to be an identity (this is so for</span>
<span class="s">      IEEE-754 double precision values, which is what Python float maps to</span>
<span class="s">      on most boxes).</span>

<span class="s">      In general, FLOAT cannot be used to transport infinities, NaNs, or</span>
<span class="s">      minus zero across boxes (or even on a single box, if the platform C</span>
<span class="s">      library can&#39;t read the strings it produces for such things -- Windows</span>
<span class="s">      is like that), but may do less damage than BINFLOAT on boxes with</span>
<span class="s">      greater precision or dynamic range than IEEE-754 double.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINFLOAT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;G&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">float8</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyfloat</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Float stored in binary form, with 8 bytes of data.</span>

<span class="s">      This generally requires less than half the space of FLOAT encoding.</span>
<span class="s">      In general, BINFLOAT cannot be used to transport infinities, NaNs, or</span>
<span class="s">      minus zero, raises an exception if the exponent exceeds the range of</span>
<span class="s">      an IEEE-754 double, and retains no more than 53 bits of precision (if</span>
<span class="s">      there are more than that, &quot;add a half and chop&quot; rounding is used to</span>
<span class="s">      cut it back to 53 significant bits).</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to build lists.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EMPTY_LIST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;]&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push an empty list.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;APPEND&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Append an object to a list.</span>

<span class="s">      Stack before:  ... pylist anyobject</span>
<span class="s">      Stack after:   ... pylist+[anyobject]</span>

<span class="s">      although pylist is really extended in-place.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;APPENDS&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;e&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">,</span> <span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Extend a list by a slice of stack objects.</span>

<span class="s">      Stack before:  ... pylist markobject stackslice</span>
<span class="s">      Stack after:   ... pylist+stackslice</span>

<span class="s">      although pylist is really extended in-place.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;LIST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;l&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a list out of the topmost stack slice, after markobject.</span>

<span class="s">      All the stack entries following the topmost markobject are placed into</span>
<span class="s">      a single Python list, which single list object replaces all of the</span>
<span class="s">      stack from the topmost markobject onward.  For example,</span>

<span class="s">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s">      Stack after:  ... [1, 2, 3, &#39;abc&#39;]</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to build tuples.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EMPTY_TUPLE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;)&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push an empty tuple.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;TUPLE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a tuple out of the topmost stack slice, after markobject.</span>

<span class="s">      All the stack entries following the topmost markobject are placed into</span>
<span class="s">      a single Python tuple, which single tuple object replaces all of the</span>
<span class="s">      stack from the topmost markobject onward.  For example,</span>

<span class="s">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s">      Stack after:  ... (1, 2, 3, &#39;abc&#39;)</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;TUPLE1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x85</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a one-tuple out of the topmost item on the stack.</span>

<span class="s">      This code pops one value off the stack and pushes a tuple of</span>
<span class="s">      length 1 whose one item is that value back onto it.  In other</span>
<span class="s">      words:</span>

<span class="s">          stack[-1] = tuple(stack[-1:])</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;TUPLE2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x86</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a two-tuple out of the top two items on the stack.</span>

<span class="s">      This code pops two values off the stack and pushes a tuple of</span>
<span class="s">      length 2 whose items are those values back onto it.  In other</span>
<span class="s">      words:</span>

<span class="s">          stack[-2:] = [tuple(stack[-2:])]</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;TUPLE3&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x87</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a three-tuple out of the top three items on the stack.</span>

<span class="s">      This code pops three values off the stack and pushes a tuple of</span>
<span class="s">      length 3 whose items are those values back onto it.  In other</span>
<span class="s">      words:</span>

<span class="s">          stack[-3:] = [tuple(stack[-3:])]</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to build dicts.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EMPTY_DICT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;}&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push an empty dict.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;DICT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a dict out of the topmost stack slice, after markobject.</span>

<span class="s">      All the stack entries following the topmost markobject are placed into</span>
<span class="s">      a single Python dict, which single dict object replaces all of the</span>
<span class="s">      stack from the topmost markobject onward.  The stack slice alternates</span>
<span class="s">      key, value, key, value, ....  For example,</span>

<span class="s">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s">      Stack after:  ... {1: 2, 3: &#39;abc&#39;}</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;SETITEM&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Add a key+value pair to an existing dict.</span>

<span class="s">      Stack before:  ... pydict key value</span>
<span class="s">      Stack after:   ... pydict</span>

<span class="s">      where pydict has been modified via pydict[key] = value.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;SETITEMS&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">,</span> <span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Add an arbitrary number of key+value pairs to an existing dict.</span>

<span class="s">      The slice of the stack following the topmost markobject is taken as</span>
<span class="s">      an alternating sequence of keys and values, added to the dict</span>
<span class="s">      immediately under the topmost markobject.  Everything at and after the</span>
<span class="s">      topmost markobject is popped, leaving the mutated dict at the top</span>
<span class="s">      of the stack.</span>

<span class="s">      Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n</span>
<span class="s">      Stack after:   ... pydict</span>

<span class="s">      where pydict has been modified via pydict[key_i] = value_i for i in</span>
<span class="s">      1, 2, ..., n, and in that order.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to build sets</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EMPTY_SET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x8f</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyset</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push an empty set.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;ADDITEMS&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x90</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pyset</span><span class="p">,</span> <span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyset</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Add an arbitrary number of items to an existing set.</span>

<span class="s">      The slice of the stack following the topmost markobject is taken as</span>
<span class="s">      a sequence of items, added to the set immediately under the topmost</span>
<span class="s">      markobject.  Everything at and after the topmost markobject is popped,</span>
<span class="s">      leaving the mutated set at the top of the stack.</span>

<span class="s">      Stack before:  ... pyset markobject item_1 ... item_n</span>
<span class="s">      Stack after:   ... pyset</span>

<span class="s">      where pyset has been modified via pyset.add(item_i) = item_i for i in</span>
<span class="s">      1, 2, ..., n, and in that order.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Way to build frozensets</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;FROZENSET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x91</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyfrozenset</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a frozenset out of the topmost slice, after markobject.</span>

<span class="s">      All the stack entries following the topmost markobject are placed into</span>
<span class="s">      a single Python frozenset, which single frozenset object replaces all</span>
<span class="s">      of the stack from the topmost markobject onward.  For example,</span>

<span class="s">      Stack before: ... markobject 1 2 3</span>
<span class="s">      Stack after:  ... frozenset({1, 2, 3})</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Stack manipulation.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;POP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Discard the top stack item, shrinking the stack by one item.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;DUP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;2&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Push the top stack item onto the stack again, duplicating it.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;MARK&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;(&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push markobject onto the stack.</span>

<span class="s">      markobject is a unique object, used by other opcodes to identify a</span>
<span class="s">      region of the stack containing a variable number of objects for them</span>
<span class="s">      to work on.  See markobject.doc for more detail.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;POP_MARK&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;1&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Pop all the stack objects at and above the topmost markobject.</span>

<span class="s">      When an opcode using a variable number of stack objects is done,</span>
<span class="s">      POP_MARK is used to remove those objects, and to remove the markobject</span>
<span class="s">      that delimited their starting position on the stack.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Memo manipulation.  There are really only two operations (get and put),</span>
    <span class="c"># each in all-text, &quot;short binary&quot;, and &quot;long binary&quot; flavors.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;GET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;g&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s">      The index of the memo object to push is given by the newline-terminated</span>
<span class="s">      decimal string following.  BINGET and LONG_BINGET are space-optimized</span>
<span class="s">      versions.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINGET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;h&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s">      The index of the memo object to push is given by the 1-byte unsigned</span>
<span class="s">      integer following.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;LONG_BINGET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;j&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s">      The index of the memo object to push is given by the 4-byte unsigned</span>
<span class="s">      little-endian integer following.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;PUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;p&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s">      The index of the memo location to write into is given by the newline-</span>
<span class="s">      terminated decimal string following.  BINPUT and LONG_BINPUT are</span>
<span class="s">      space-optimized versions.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINPUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;q&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s">      The index of the memo location to write into is given by the 1-byte</span>
<span class="s">      unsigned integer following.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;LONG_BINPUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s">      The index of the memo location to write into is given by the 4-byte</span>
<span class="s">      unsigned little-endian integer following.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;MEMOIZE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x94</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s">      The index of the memo location to write is the number of</span>
<span class="s">      elements currently present in the memo.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Access the extension registry (predefined objects).  Akin to the GET</span>
    <span class="c"># family.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EXT1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x82</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Extension code.</span>

<span class="s">      This code and the similar EXT2 and EXT4 allow using a registry</span>
<span class="s">      of popular objects that are pickled by name, typically classes.</span>
<span class="s">      It is envisioned that through a global negotiation and</span>
<span class="s">      registration process, third parties can set up a mapping between</span>
<span class="s">      ints and object names.</span>

<span class="s">      In order to guarantee pickle interchangeability, the extension</span>
<span class="s">      code registry ought to be global, although a range of codes may</span>
<span class="s">      be reserved for private use.</span>

<span class="s">      EXT1 has a 1-byte integer argument.  This is used to index into the</span>
<span class="s">      extension registry, and the object at that index is pushed on the stack.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EXT2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x83</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint2</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Extension code.</span>

<span class="s">      See EXT1.  EXT2 has a two-byte integer argument.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;EXT4&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x84</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Extension code.</span>

<span class="s">      See EXT1.  EXT4 has a four-byte integer argument.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Push a class object, or module function, on the stack, via its module</span>
    <span class="c"># and name.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;GLOBAL&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape_pair</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a global object (module.attr) on the stack.</span>

<span class="s">      Two newline-terminated strings follow the GLOBAL opcode.  The first is</span>
<span class="s">      taken as a module name, and the second as a class name.  The class</span>
<span class="s">      object module.class is pushed on the stack.  More accurately, the</span>
<span class="s">      object returned by self.find_class(module, class) is pushed on the</span>
<span class="s">      stack, so unpickling subclasses can override this form of lookup.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;STACK_GLOBAL&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x93</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">,</span> <span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push a global object (module.attr) on the stack.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to build objects of classes pickle doesn&#39;t know about directly</span>
    <span class="c"># (user-defined classes).  I despair of documenting this accurately</span>
    <span class="c"># and comprehensibly -- you really have to read the pickle code to</span>
    <span class="c"># find all the special cases.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;REDUCE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;R&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push an object built from a callable and an argument tuple.</span>

<span class="s">      The opcode is named to remind of the __reduce__() method.</span>

<span class="s">      Stack before: ... callable pytuple</span>
<span class="s">      Stack after:  ... callable(*pytuple)</span>

<span class="s">      The callable and the argument tuple are the first two items returned</span>
<span class="s">      by a __reduce__ method.  Applying the callable to the argtuple is</span>
<span class="s">      supposed to reproduce the original object, or at least get it started.</span>
<span class="s">      If the __reduce__ method returns a 3-tuple, the last component is an</span>
<span class="s">      argument to be passed to the object&#39;s __setstate__, and then the REDUCE</span>
<span class="s">      opcode is followed by code to create setstate&#39;s argument, and then a</span>
<span class="s">      BUILD opcode to apply  __setstate__ to that argument.</span>

<span class="s">      If not isinstance(callable, type), REDUCE complains unless the</span>
<span class="s">      callable has been registered with the copyreg module&#39;s</span>
<span class="s">      safe_constructors dict, or the callable has a magic</span>
<span class="s">      &#39;__safe_for_unpickling__&#39; attribute with a true value.  I&#39;m not sure</span>
<span class="s">      why it does this, but I&#39;ve sure seen this complaint often enough when</span>
<span class="s">      I didn&#39;t want to &lt;wink&gt;.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BUILD&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Finish building an object, via __setstate__ or dict update.</span>

<span class="s">      Stack before: ... anyobject argument</span>
<span class="s">      Stack after:  ... anyobject</span>

<span class="s">      where anyobject may have been mutated, as follows:</span>

<span class="s">      If the object has a __setstate__ method,</span>

<span class="s">          anyobject.__setstate__(argument)</span>

<span class="s">      is called.</span>

<span class="s">      Else the argument must be a dict, the object must have a __dict__, and</span>
<span class="s">      the object is updated via</span>

<span class="s">          anyobject.__dict__.update(argument)</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;INST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;i&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape_pair</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a class instance.</span>

<span class="s">      This is the protocol 0 version of protocol 1&#39;s OBJ opcode.</span>
<span class="s">      INST is followed by two newline-terminated strings, giving a</span>
<span class="s">      module and class name, just as for the GLOBAL opcode (and see</span>
<span class="s">      GLOBAL for more details about that).  self.find_class(module, name)</span>
<span class="s">      is used to get a class object.</span>

<span class="s">      In addition, all the objects on the stack following the topmost</span>
<span class="s">      markobject are gathered into a tuple and popped (along with the</span>
<span class="s">      topmost markobject), just as for the TUPLE opcode.</span>

<span class="s">      Now it gets complicated.  If all of these are true:</span>

<span class="s">        + The argtuple is empty (markobject was at the top of the stack</span>
<span class="s">          at the start).</span>

<span class="s">        + The class object does not have a __getinitargs__ attribute.</span>

<span class="s">      then we want to create an old-style class instance without invoking</span>
<span class="s">      its __init__() method (pickle has waffled on this over the years; not</span>
<span class="s">      calling __init__() is current wisdom).  In this case, an instance of</span>
<span class="s">      an old-style dummy class is created, and then we try to rebind its</span>
<span class="s">      __class__ attribute to the desired class object.  If this succeeds,</span>
<span class="s">      the new instance object is pushed on the stack, and we&#39;re done.</span>

<span class="s">      Else (the argtuple is not empty, it&#39;s not an old-style class object,</span>
<span class="s">      or the class object does have a __getinitargs__ attribute), the code</span>
<span class="s">      first insists that the class object have a __safe_for_unpickling__</span>
<span class="s">      attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,</span>
<span class="s">      it doesn&#39;t matter whether this attribute has a true or false value, it</span>
<span class="s">      only matters whether it exists (XXX this is a bug).  If</span>
<span class="s">      __safe_for_unpickling__ doesn&#39;t exist, UnpicklingError is raised.</span>

<span class="s">      Else (the class object does have a __safe_for_unpickling__ attr),</span>
<span class="s">      the class object obtained from INST&#39;s arguments is applied to the</span>
<span class="s">      argtuple obtained from the stack, and the resulting instance object</span>
<span class="s">      is pushed on the stack.</span>

<span class="s">      NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.</span>
<span class="s">      NOTE:  the distinction between old-style and new-style classes does</span>
<span class="s">             not make sense in Python 3.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;OBJ&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build a class instance.</span>

<span class="s">      This is the protocol 1 version of protocol 0&#39;s INST opcode, and is</span>
<span class="s">      very much like it.  The major difference is that the class object</span>
<span class="s">      is taken off the stack, allowing it to be retrieved from the memo</span>
<span class="s">      repeatedly if several instances of the same class are created.  This</span>
<span class="s">      can be much more efficient (in both time and space) than repeatedly</span>
<span class="s">      embedding the module and class names in INST opcodes.</span>

<span class="s">      Unlike INST, OBJ takes no arguments from the opcode stream.  Instead</span>
<span class="s">      the class object is taken off the stack, immediately above the</span>
<span class="s">      topmost markobject:</span>

<span class="s">      Stack before: ... markobject classobject stackslice</span>
<span class="s">      Stack after:  ... new_instance_object</span>

<span class="s">      As for INST, the remainder of the stack above the markobject is</span>
<span class="s">      gathered into an argument tuple, and then the logic seems identical,</span>
<span class="s">      except that no __safe_for_unpickling__ check is done (XXX this is</span>
<span class="s">      a bug).  See INST for the gory details.</span>

<span class="s">      NOTE:  In Python 2.3, INST and OBJ are identical except for how they</span>
<span class="s">      get the class object.  That was always the intent; the implementations</span>
<span class="s">      had diverged for accidental reasons.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;NEWOBJ&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x81</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build an object instance.</span>

<span class="s">      The stack before should be thought of as containing a class</span>
<span class="s">      object followed by an argument tuple (the tuple being the stack</span>
<span class="s">      top).  Call these cls and args.  They are popped off the stack,</span>
<span class="s">      and the value returned by cls.__new__(cls, *args) is pushed back</span>
<span class="s">      onto the stack.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;NEWOBJ_EX&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x92</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Build an object instance.</span>

<span class="s">      The stack before should be thought of as containing a class</span>
<span class="s">      object followed by an argument tuple and by a keyword argument dict</span>
<span class="s">      (the dict being the stack top).  Call these cls and args.  They are</span>
<span class="s">      popped off the stack, and the value returned by</span>
<span class="s">      cls.__new__(cls, *args, *kwargs) is  pushed back  onto the stack.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Machine control.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;PROTO&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x80</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Protocol version indicator.</span>

<span class="s">      For protocol 2 and above, a pickle must start with this opcode.</span>
<span class="s">      The argument is the protocol version, an int in range(2, 256).</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;STOP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Stop the unpickling machine.</span>

<span class="s">      Every pickle ends with this opcode.  The object at the top of the stack</span>
<span class="s">      is popped, and that&#39;s the result of unpickling.  The stack should be</span>
<span class="s">      empty then.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Framing support.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;FRAME&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\x95</span><span class="s">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint8</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Indicate the beginning of a new frame.</span>

<span class="s">      The unpickler may use this opcode to safely prefetch data from its</span>
<span class="s">      underlying stream.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c"># Ways to deal with persistent IDs.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;PERSID&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;P&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push an object identified by a persistent ID.</span>

<span class="s">      The pickle module doesn&#39;t define what a persistent ID means.  PERSID&#39;s</span>
<span class="s">      argument is a newline-terminated str-style (no embedded escapes, no</span>
<span class="s">      bracketing quote characters) string, which *is* &quot;the persistent ID&quot;.</span>
<span class="s">      The unpickler passes this string to self.persistent_load().  Whatever</span>
<span class="s">      object that returns is pushed on the stack.  There is no implementation</span>
<span class="s">      of persistent_load() in Python&#39;s unpickler:  it must be supplied by an</span>
<span class="s">      unpickler subclass.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;BINPERSID&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s">&#39;Q&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Push an object identified by a persistent ID.</span>

<span class="s">      Like PERSID, except the persistent ID is popped off the stack (instead</span>
<span class="s">      of being a string embedded in the opcode bytestream).  The persistent</span>
<span class="s">      ID is passed to self.persistent_load(), and whatever object that</span>
<span class="s">      returns is pushed on the stack.  See PERSID for more detail.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">),</span>
<span class="p">]</span>
<span class="k">del</span> <span class="n">I</span>

<span class="c"># Verify uniqueness of .name and .code members.</span>
<span class="n">name2i</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">code2i</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opcodes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">name2i</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;repeated name </span><span class="si">%r</span><span class="s"> at indices </span><span class="si">%d</span><span class="s"> and </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">code</span> <span class="ow">in</span> <span class="n">code2i</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;repeated code </span><span class="si">%r</span><span class="s"> at indices </span><span class="si">%d</span><span class="s"> and </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">code2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">name2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">code2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="k">del</span> <span class="n">name2i</span><span class="p">,</span> <span class="n">code2i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span>

<span class="c">##############################################################################</span>
<span class="c"># Build a code2op dict, mapping opcode characters to OpcodeInfo records.</span>
<span class="c"># Also ensure we&#39;ve got the same stuff as pickle.py, although the</span>
<span class="c"># introspection here is dicey.</span>

<span class="n">code2op</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>
    <span class="n">code2op</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
<span class="k">del</span> <span class="n">d</span>

<span class="k">def</span> <span class="nf">assure_pickle_consistency</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="n">copy</span> <span class="o">=</span> <span class="n">code2op</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pickle</span><span class="o">.</span><span class="n">__all__</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;[A-Z][A-Z0-9_]+$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;skipping </span><span class="si">%r</span><span class="s">: it doesn&#39;t look like an opcode name&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">picklecode</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">picklecode</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">picklecode</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s">&quot;skipping </span><span class="si">%r</span><span class="s">: value </span><span class="si">%r</span><span class="s"> doesn&#39;t look like a pickle &quot;</span>
                       <span class="s">&quot;code&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">)))</span>
            <span class="k">continue</span>
        <span class="n">picklecode</span> <span class="o">=</span> <span class="n">picklecode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;latin-1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">picklecode</span> <span class="ow">in</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;checking name </span><span class="si">%r</span><span class="s"> w/ code </span><span class="si">%r</span><span class="s"> for consistency&quot;</span> <span class="o">%</span> <span class="p">(</span>
                      <span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="p">[</span><span class="n">picklecode</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;for pickle code </span><span class="si">%r</span><span class="s">, pickle.py uses name </span><span class="si">%r</span><span class="s"> &quot;</span>
                                 <span class="s">&quot;but we&#39;re using name </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">picklecode</span><span class="p">,</span>
                                                              <span class="n">name</span><span class="p">,</span>
                                                              <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="c"># Forget this one.  Any left over in copy at the end are a problem</span>
            <span class="c"># of a different kind.</span>
            <span class="k">del</span> <span class="n">copy</span><span class="p">[</span><span class="n">picklecode</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;pickle.py appears to have a pickle opcode with &quot;</span>
                             <span class="s">&quot;name </span><span class="si">%r</span><span class="s"> and code </span><span class="si">%r</span><span class="s">, but we don&#39;t&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;we appear to have pickle opcodes that pickle.py doesn&#39;t have:&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">copy</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;    name </span><span class="si">%r</span><span class="s"> with code </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">assure_pickle_consistency</span><span class="p">()</span>
<span class="k">del</span> <span class="n">assure_pickle_consistency</span>

<span class="c">##############################################################################</span>
<span class="c"># A pickle opcode generator.</span>

<span class="k">def</span> <span class="nf">_genops</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">yield_end_pos</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bytes_types</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;tell&quot;</span><span class="p">):</span>
        <span class="n">getpos</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tell</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">getpos</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">getpos</span><span class="p">()</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">opcode</span> <span class="o">=</span> <span class="n">code2op</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;latin-1&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="n">b</span><span class="s">&quot;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;pickle exhausted before seeing STOP&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;at position </span><span class="si">%s</span><span class="s">, opcode </span><span class="si">%r</span><span class="s"> unknown&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                 <span class="s">&quot;&lt;unknown&gt;&quot;</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">pos</span><span class="p">,</span>
                                 <span class="n">code</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">opcode</span><span class="o">.</span><span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yield_end_pos</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">getpos</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="n">b</span><span class="s">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;STOP&#39;</span>
            <span class="k">break</span>

<div class="viewcode-block" id="genops"><a class="viewcode-back" href="../pickletools.html#pickletools.genops">[docs]</a><span class="k">def</span> <span class="nf">genops</span><span class="p">(</span><span class="n">pickle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate all the opcodes in a pickle.</span>

<span class="sd">    &#39;pickle&#39; is a file-like object, or string, containing the pickle.</span>

<span class="sd">    Each opcode in the pickle is generated, from the current pickle position,</span>
<span class="sd">    stopping after a STOP opcode is delivered.  A triple is generated for</span>
<span class="sd">    each opcode:</span>

<span class="sd">        opcode, arg, pos</span>

<span class="sd">    opcode is an OpcodeInfo record, describing the current opcode.</span>

<span class="sd">    If the opcode has an argument embedded in the pickle, arg is its decoded</span>
<span class="sd">    value, as a Python object.  If the opcode doesn&#39;t have an argument, arg</span>
<span class="sd">    is None.</span>

<span class="sd">    If the pickle has a tell() method, pos was the value of pickle.tell()</span>
<span class="sd">    before reading the current opcode.  If the pickle is a bytes object,</span>
<span class="sd">    it&#39;s wrapped in a BytesIO object, and the latter&#39;s tell() result is</span>
<span class="sd">    used.  Else (the pickle doesn&#39;t have a tell(), and it&#39;s not obvious how</span>
<span class="sd">    to query its current position) pos is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_genops</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>

<span class="c">##############################################################################</span>
<span class="c"># A pickle optimizer.</span>
</div>
<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../pickletools.html#pickletools.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="s">&#39;Optimize a pickle string by removing unused PUT opcodes&#39;</span>
    <span class="n">not_a_put</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">gets</span> <span class="o">=</span> <span class="p">{</span> <span class="n">not_a_put</span> <span class="p">}</span>    <span class="c"># set of args used by a GET opcode</span>
    <span class="n">opcodes</span> <span class="o">=</span> <span class="p">[]</span>            <span class="c"># (startpos, stoppos, putid)</span>
    <span class="n">proto</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end_pos</span> <span class="ow">in</span> <span class="n">_genops</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">yield_end_pos</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;PUT&#39;</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">opcodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s">&#39;FRAME&#39;</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&#39;GET&#39;</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">gets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PROTO&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span>
                <span class="n">proto</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="n">opcodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">,</span> <span class="n">not_a_put</span><span class="p">))</span>
            <span class="n">prevpos</span><span class="p">,</span> <span class="n">prevarg</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="bp">None</span>

    <span class="c"># Copy the opcodes except for PUTS without a corresponding GET</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">opcodes</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">opcodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proto</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c"># Write the PROTO header before any framing</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">opcodes</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">_Framer</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proto</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">buf</span><span class="o">.</span><span class="n">start_framing</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">putid</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">putid</span> <span class="ow">in</span> <span class="n">gets</span><span class="p">:</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">commit_frame</span><span class="p">()</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">proto</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">buf</span><span class="o">.</span><span class="n">end_framing</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<span class="c">##############################################################################</span>
<span class="c"># A symbolic pickle disassembler.</span>
</div>
<div class="viewcode-block" id="dis"><a class="viewcode-back" href="../pickletools.html#pickletools.dis">[docs]</a><span class="k">def</span> <span class="nf">dis</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">indentlevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a symbolic disassembly of a pickle.</span>

<span class="sd">    &#39;pickle&#39; is a file-like object, or string, containing a (at least one)</span>
<span class="sd">    pickle.  The pickle is disassembled from the current position, through</span>
<span class="sd">    the first STOP opcode encountered.</span>

<span class="sd">    Optional arg &#39;out&#39; is a file-like object to which the disassembly is</span>
<span class="sd">    printed.  It defaults to sys.stdout.</span>

<span class="sd">    Optional arg &#39;memo&#39; is a Python dict, used as the pickle&#39;s memo.  It</span>
<span class="sd">    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.</span>
<span class="sd">    Passing the same memo object to another dis() call then allows disassembly</span>
<span class="sd">    to proceed across multiple pickles that were all created by the same</span>
<span class="sd">    pickler with the same memo.  Ordinarily you don&#39;t need to worry about this.</span>

<span class="sd">    Optional arg &#39;indentlevel&#39; is the number of blanks by which to indent</span>
<span class="sd">    a new MARK level.  It defaults to 4.</span>

<span class="sd">    Optional arg &#39;annotate&#39; if nonzero instructs dis() to add short</span>
<span class="sd">    description of the opcode on each line of disassembled output.</span>
<span class="sd">    The value given to &#39;annotate&#39; must be an integer and is used as a</span>
<span class="sd">    hint for the column where annotation should start.  The default</span>
<span class="sd">    value is 0, meaning no annotations.</span>

<span class="sd">    In addition to printing the disassembly, some sanity checks are made:</span>

<span class="sd">    + All embedded opcode arguments &quot;make sense&quot;.</span>

<span class="sd">    + Explicit and implicit pop operations have enough items on the stack.</span>

<span class="sd">    + When an opcode implicitly refers to a markobject, a markobject is</span>
<span class="sd">      actually on the stack.</span>

<span class="sd">    + A memo entry isn&#39;t referenced before it&#39;s defined.</span>

<span class="sd">    + The markobject isn&#39;t stored in the memo.</span>

<span class="sd">    + A memo entry isn&#39;t redefined.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Most of the hair here is for sanity checks, but most of it is needed</span>
    <span class="c"># anyway to detect when a protocol 0 POP takes a MARK off the stack</span>
    <span class="c"># (which in turn is needed to indent MARK blocks correctly).</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c"># crude emulation of unpickler stack</span>
    <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>       <span class="c"># crude emulation of unpickler memo</span>
    <span class="n">maxproto</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>       <span class="c"># max protocol number seen</span>
    <span class="n">markstack</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c"># bytecode positions of MARK opcodes</span>
    <span class="n">indentchunk</span> <span class="o">=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="n">indentlevel</span>
    <span class="n">errormsg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">annocol</span> <span class="o">=</span> <span class="n">annotate</span>  <span class="c"># column hint for annotations</span>
    <span class="k">for</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">genops</span><span class="p">(</span><span class="n">pickle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%5d</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%-4s</span><span class="s"> </span><span class="si">%s%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">code</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">indentchunk</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">markstack</span><span class="p">),</span>
                              <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">maxproto</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxproto</span><span class="p">,</span> <span class="n">opcode</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span>
        <span class="n">before</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">stack_before</span>    <span class="c"># don&#39;t mutate</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">stack_after</span>      <span class="c"># don&#39;t mutate</span>
        <span class="n">numtopop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>

        <span class="c"># See whether a MARK should be popped.</span>
        <span class="n">markmsg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">before</span> <span class="ow">or</span> <span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;POP&quot;</span> <span class="ow">and</span>
                                    <span class="n">stack</span> <span class="ow">and</span>
                                    <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">markobject</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">markobject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">after</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">before</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">before</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">stackslice</span>
            <span class="k">if</span> <span class="n">markstack</span><span class="p">:</span>
                <span class="n">markpos</span> <span class="o">=</span> <span class="n">markstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">markpos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">markmsg</span> <span class="o">=</span> <span class="s">&quot;(MARK at unknown opcode offset)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">markmsg</span> <span class="o">=</span> <span class="s">&quot;(MARK at </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">markpos</span>
                <span class="c"># Pop everything at and after the topmost markobject.</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">markobject</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c"># Stop later code from popping too much.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">numtopop</span> <span class="o">=</span> <span class="n">before</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">markobject</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;POP&quot;</span>
                    <span class="n">numtopop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="n">markmsg</span> <span class="o">=</span> <span class="s">&quot;no MARK exists on stack&quot;</span>

        <span class="c"># Check for correct memo usage.</span>
        <span class="k">if</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;PUT&quot;</span><span class="p">,</span> <span class="s">&quot;BINPUT&quot;</span><span class="p">,</span> <span class="s">&quot;LONG_BINPUT&quot;</span><span class="p">,</span> <span class="s">&quot;MEMOIZE&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;MEMOIZE&quot;</span><span class="p">:</span>
                <span class="n">memo_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                <span class="n">memo_idx</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">if</span> <span class="n">memo_idx</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s">&quot;memo key </span><span class="si">%r</span><span class="s"> already defined&quot;</span> <span class="o">%</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s">&quot;stack is empty -- can&#39;t store into memo&quot;</span>
            <span class="k">elif</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">markobject</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s">&quot;can&#39;t store markobject in the memo&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">memo_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span> <span class="s">&quot;BINGET&quot;</span><span class="p">,</span> <span class="s">&quot;LONG_BINGET&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">after</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">after</span> <span class="o">=</span> <span class="p">[</span><span class="n">memo</span><span class="p">[</span><span class="n">arg</span><span class="p">]]</span>     <span class="c"># for better stack emulation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s">&quot;memo key </span><span class="si">%r</span><span class="s"> has never been stored into&quot;</span> <span class="o">%</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">markmsg</span><span class="p">:</span>
            <span class="c"># make a mild effort to align arguments</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">markmsg</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">markmsg</span>
        <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">annocol</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="c"># make a mild effort to align annotations</span>
            <span class="n">annocol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annocol</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                <span class="n">annocol</span> <span class="o">=</span> <span class="n">annotate</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">opcode</span><span class="o">.</span><span class="n">doc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errormsg</span><span class="p">:</span>
            <span class="c"># Note that we delayed complaining until the offending opcode</span>
            <span class="c"># was printed.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errormsg</span><span class="p">)</span>

        <span class="c"># Emulate the stack effects.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">numtopop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tries to pop </span><span class="si">%d</span><span class="s"> items from stack with &quot;</span>
                             <span class="s">&quot;only </span><span class="si">%d</span><span class="s"> items&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">numtopop</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">numtopop</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">numtopop</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">markobject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">before</span>
            <span class="n">markstack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&quot;highest protocol among opcodes =&quot;</span><span class="p">,</span> <span class="n">maxproto</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;stack not empty after STOP: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">stack</span><span class="p">)</span>

<span class="c"># For use in the doctest, simply as an example of a class to pickle.</span></div>
<span class="k">class</span> <span class="nc">_Example</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">_dis_test</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">&gt;&gt;&gt; import pickle</span>
<span class="s">&gt;&gt;&gt; x = [1, 2, (3, 4), {b&#39;abc&#39;: &quot;def&quot;}]</span>
<span class="s">&gt;&gt;&gt; pkl0 = pickle.dumps(x, 0)</span>
<span class="s">&gt;&gt;&gt; dis(pkl0)</span>
<span class="s">    0: (    MARK</span>
<span class="s">    1: l        LIST       (MARK at 0)</span>
<span class="s">    2: p    PUT        0</span>
<span class="s">    5: L    LONG       1</span>
<span class="s">    9: a    APPEND</span>
<span class="s">   10: L    LONG       2</span>
<span class="s">   14: a    APPEND</span>
<span class="s">   15: (    MARK</span>
<span class="s">   16: L        LONG       3</span>
<span class="s">   20: L        LONG       4</span>
<span class="s">   24: t        TUPLE      (MARK at 15)</span>
<span class="s">   25: p    PUT        1</span>
<span class="s">   28: a    APPEND</span>
<span class="s">   29: (    MARK</span>
<span class="s">   30: d        DICT       (MARK at 29)</span>
<span class="s">   31: p    PUT        2</span>
<span class="s">   34: c    GLOBAL     &#39;_codecs encode&#39;</span>
<span class="s">   50: p    PUT        3</span>
<span class="s">   53: (    MARK</span>
<span class="s">   54: V        UNICODE    &#39;abc&#39;</span>
<span class="s">   59: p        PUT        4</span>
<span class="s">   62: V        UNICODE    &#39;latin1&#39;</span>
<span class="s">   70: p        PUT        5</span>
<span class="s">   73: t        TUPLE      (MARK at 53)</span>
<span class="s">   74: p    PUT        6</span>
<span class="s">   77: R    REDUCE</span>
<span class="s">   78: p    PUT        7</span>
<span class="s">   81: V    UNICODE    &#39;def&#39;</span>
<span class="s">   86: p    PUT        8</span>
<span class="s">   89: s    SETITEM</span>
<span class="s">   90: a    APPEND</span>
<span class="s">   91: .    STOP</span>
<span class="s">highest protocol among opcodes = 0</span>

<span class="s">Try again with a &quot;binary&quot; pickle.</span>

<span class="s">&gt;&gt;&gt; pkl1 = pickle.dumps(x, 1)</span>
<span class="s">&gt;&gt;&gt; dis(pkl1)</span>
<span class="s">    0: ]    EMPTY_LIST</span>
<span class="s">    1: q    BINPUT     0</span>
<span class="s">    3: (    MARK</span>
<span class="s">    4: K        BININT1    1</span>
<span class="s">    6: K        BININT1    2</span>
<span class="s">    8: (        MARK</span>
<span class="s">    9: K            BININT1    3</span>
<span class="s">   11: K            BININT1    4</span>
<span class="s">   13: t            TUPLE      (MARK at 8)</span>
<span class="s">   14: q        BINPUT     1</span>
<span class="s">   16: }        EMPTY_DICT</span>
<span class="s">   17: q        BINPUT     2</span>
<span class="s">   19: c        GLOBAL     &#39;_codecs encode&#39;</span>
<span class="s">   35: q        BINPUT     3</span>
<span class="s">   37: (        MARK</span>
<span class="s">   38: X            BINUNICODE &#39;abc&#39;</span>
<span class="s">   46: q            BINPUT     4</span>
<span class="s">   48: X            BINUNICODE &#39;latin1&#39;</span>
<span class="s">   59: q            BINPUT     5</span>
<span class="s">   61: t            TUPLE      (MARK at 37)</span>
<span class="s">   62: q        BINPUT     6</span>
<span class="s">   64: R        REDUCE</span>
<span class="s">   65: q        BINPUT     7</span>
<span class="s">   67: X        BINUNICODE &#39;def&#39;</span>
<span class="s">   75: q        BINPUT     8</span>
<span class="s">   77: s        SETITEM</span>
<span class="s">   78: e        APPENDS    (MARK at 3)</span>
<span class="s">   79: .    STOP</span>
<span class="s">highest protocol among opcodes = 1</span>

<span class="s">Exercise the INST/OBJ/BUILD family.</span>

<span class="s">&gt;&gt;&gt; import pickletools</span>
<span class="s">&gt;&gt;&gt; dis(pickle.dumps(pickletools.dis, 0))</span>
<span class="s">    0: c    GLOBAL     &#39;pickletools dis&#39;</span>
<span class="s">   17: p    PUT        0</span>
<span class="s">   20: .    STOP</span>
<span class="s">highest protocol among opcodes = 0</span>

<span class="s">&gt;&gt;&gt; from pickletools import _Example</span>
<span class="s">&gt;&gt;&gt; x = [_Example(42)] * 2</span>
<span class="s">&gt;&gt;&gt; dis(pickle.dumps(x, 0))</span>
<span class="s">    0: (    MARK</span>
<span class="s">    1: l        LIST       (MARK at 0)</span>
<span class="s">    2: p    PUT        0</span>
<span class="s">    5: c    GLOBAL     &#39;copy_reg _reconstructor&#39;</span>
<span class="s">   30: p    PUT        1</span>
<span class="s">   33: (    MARK</span>
<span class="s">   34: c        GLOBAL     &#39;pickletools _Example&#39;</span>
<span class="s">   56: p        PUT        2</span>
<span class="s">   59: c        GLOBAL     &#39;__builtin__ object&#39;</span>
<span class="s">   79: p        PUT        3</span>
<span class="s">   82: N        NONE</span>
<span class="s">   83: t        TUPLE      (MARK at 33)</span>
<span class="s">   84: p    PUT        4</span>
<span class="s">   87: R    REDUCE</span>
<span class="s">   88: p    PUT        5</span>
<span class="s">   91: (    MARK</span>
<span class="s">   92: d        DICT       (MARK at 91)</span>
<span class="s">   93: p    PUT        6</span>
<span class="s">   96: V    UNICODE    &#39;value&#39;</span>
<span class="s">  103: p    PUT        7</span>
<span class="s">  106: L    LONG       42</span>
<span class="s">  111: s    SETITEM</span>
<span class="s">  112: b    BUILD</span>
<span class="s">  113: a    APPEND</span>
<span class="s">  114: g    GET        5</span>
<span class="s">  117: a    APPEND</span>
<span class="s">  118: .    STOP</span>
<span class="s">highest protocol among opcodes = 0</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(x, 1))</span>
<span class="s">    0: ]    EMPTY_LIST</span>
<span class="s">    1: q    BINPUT     0</span>
<span class="s">    3: (    MARK</span>
<span class="s">    4: c        GLOBAL     &#39;copy_reg _reconstructor&#39;</span>
<span class="s">   29: q        BINPUT     1</span>
<span class="s">   31: (        MARK</span>
<span class="s">   32: c            GLOBAL     &#39;pickletools _Example&#39;</span>
<span class="s">   54: q            BINPUT     2</span>
<span class="s">   56: c            GLOBAL     &#39;__builtin__ object&#39;</span>
<span class="s">   76: q            BINPUT     3</span>
<span class="s">   78: N            NONE</span>
<span class="s">   79: t            TUPLE      (MARK at 31)</span>
<span class="s">   80: q        BINPUT     4</span>
<span class="s">   82: R        REDUCE</span>
<span class="s">   83: q        BINPUT     5</span>
<span class="s">   85: }        EMPTY_DICT</span>
<span class="s">   86: q        BINPUT     6</span>
<span class="s">   88: X        BINUNICODE &#39;value&#39;</span>
<span class="s">   98: q        BINPUT     7</span>
<span class="s">  100: K        BININT1    42</span>
<span class="s">  102: s        SETITEM</span>
<span class="s">  103: b        BUILD</span>
<span class="s">  104: h        BINGET     5</span>
<span class="s">  106: e        APPENDS    (MARK at 3)</span>
<span class="s">  107: .    STOP</span>
<span class="s">highest protocol among opcodes = 1</span>

<span class="s">Try &quot;the canonical&quot; recursive-object test.</span>

<span class="s">&gt;&gt;&gt; L = []</span>
<span class="s">&gt;&gt;&gt; T = L,</span>
<span class="s">&gt;&gt;&gt; L.append(T)</span>
<span class="s">&gt;&gt;&gt; L[0] is T</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; T[0] is L</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; L[0][0] is L</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; T[0][0] is T</span>
<span class="s">True</span>
<span class="s">&gt;&gt;&gt; dis(pickle.dumps(L, 0))</span>
<span class="s">    0: (    MARK</span>
<span class="s">    1: l        LIST       (MARK at 0)</span>
<span class="s">    2: p    PUT        0</span>
<span class="s">    5: (    MARK</span>
<span class="s">    6: g        GET        0</span>
<span class="s">    9: t        TUPLE      (MARK at 5)</span>
<span class="s">   10: p    PUT        1</span>
<span class="s">   13: a    APPEND</span>
<span class="s">   14: .    STOP</span>
<span class="s">highest protocol among opcodes = 0</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(L, 1))</span>
<span class="s">    0: ]    EMPTY_LIST</span>
<span class="s">    1: q    BINPUT     0</span>
<span class="s">    3: (    MARK</span>
<span class="s">    4: h        BINGET     0</span>
<span class="s">    6: t        TUPLE      (MARK at 3)</span>
<span class="s">    7: q    BINPUT     1</span>
<span class="s">    9: a    APPEND</span>
<span class="s">   10: .    STOP</span>
<span class="s">highest protocol among opcodes = 1</span>

<span class="s">Note that, in the protocol 0 pickle of the recursive tuple, the disassembler</span>
<span class="s">has to emulate the stack in order to realize that the POP opcode at 16 gets</span>
<span class="s">rid of the MARK at 0.</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(T, 0))</span>
<span class="s">    0: (    MARK</span>
<span class="s">    1: (        MARK</span>
<span class="s">    2: l            LIST       (MARK at 1)</span>
<span class="s">    3: p        PUT        0</span>
<span class="s">    6: (        MARK</span>
<span class="s">    7: g            GET        0</span>
<span class="s">   10: t            TUPLE      (MARK at 6)</span>
<span class="s">   11: p        PUT        1</span>
<span class="s">   14: a        APPEND</span>
<span class="s">   15: 0        POP</span>
<span class="s">   16: 0        POP        (MARK at 0)</span>
<span class="s">   17: g    GET        1</span>
<span class="s">   20: .    STOP</span>
<span class="s">highest protocol among opcodes = 0</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(T, 1))</span>
<span class="s">    0: (    MARK</span>
<span class="s">    1: ]        EMPTY_LIST</span>
<span class="s">    2: q        BINPUT     0</span>
<span class="s">    4: (        MARK</span>
<span class="s">    5: h            BINGET     0</span>
<span class="s">    7: t            TUPLE      (MARK at 4)</span>
<span class="s">    8: q        BINPUT     1</span>
<span class="s">   10: a        APPEND</span>
<span class="s">   11: 1        POP_MARK   (MARK at 0)</span>
<span class="s">   12: h    BINGET     1</span>
<span class="s">   14: .    STOP</span>
<span class="s">highest protocol among opcodes = 1</span>

<span class="s">Try protocol 2.</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(L, 2))</span>
<span class="s">    0: \x80 PROTO      2</span>
<span class="s">    2: ]    EMPTY_LIST</span>
<span class="s">    3: q    BINPUT     0</span>
<span class="s">    5: h    BINGET     0</span>
<span class="s">    7: \x85 TUPLE1</span>
<span class="s">    8: q    BINPUT     1</span>
<span class="s">   10: a    APPEND</span>
<span class="s">   11: .    STOP</span>
<span class="s">highest protocol among opcodes = 2</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(T, 2))</span>
<span class="s">    0: \x80 PROTO      2</span>
<span class="s">    2: ]    EMPTY_LIST</span>
<span class="s">    3: q    BINPUT     0</span>
<span class="s">    5: h    BINGET     0</span>
<span class="s">    7: \x85 TUPLE1</span>
<span class="s">    8: q    BINPUT     1</span>
<span class="s">   10: a    APPEND</span>
<span class="s">   11: 0    POP</span>
<span class="s">   12: h    BINGET     1</span>
<span class="s">   14: .    STOP</span>
<span class="s">highest protocol among opcodes = 2</span>

<span class="s">Try protocol 3 with annotations:</span>

<span class="s">&gt;&gt;&gt; dis(pickle.dumps(T, 3), annotate=1)</span>
<span class="s">    0: \x80 PROTO      3 Protocol version indicator.</span>
<span class="s">    2: ]    EMPTY_LIST   Push an empty list.</span>
<span class="s">    3: q    BINPUT     0 Store the stack top into the memo.  The stack is not popped.</span>
<span class="s">    5: h    BINGET     0 Read an object from the memo and push it on the stack.</span>
<span class="s">    7: \x85 TUPLE1       Build a one-tuple out of the topmost item on the stack.</span>
<span class="s">    8: q    BINPUT     1 Store the stack top into the memo.  The stack is not popped.</span>
<span class="s">   10: a    APPEND       Append an object to a list.</span>
<span class="s">   11: 0    POP          Discard the top stack item, shrinking the stack by one item.</span>
<span class="s">   12: h    BINGET     1 Read an object from the memo and push it on the stack.</span>
<span class="s">   14: .    STOP         Stop the unpickling machine.</span>
<span class="s">highest protocol among opcodes = 2</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="n">_memo_test</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">&gt;&gt;&gt; import pickle</span>
<span class="s">&gt;&gt;&gt; import io</span>
<span class="s">&gt;&gt;&gt; f = io.BytesIO()</span>
<span class="s">&gt;&gt;&gt; p = pickle.Pickler(f, 2)</span>
<span class="s">&gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="s">&gt;&gt;&gt; p.dump(x)</span>
<span class="s">&gt;&gt;&gt; p.dump(x)</span>
<span class="s">&gt;&gt;&gt; f.seek(0)</span>
<span class="s">0</span>
<span class="s">&gt;&gt;&gt; memo = {}</span>
<span class="s">&gt;&gt;&gt; dis(f, memo=memo)</span>
<span class="s">    0: \x80 PROTO      2</span>
<span class="s">    2: ]    EMPTY_LIST</span>
<span class="s">    3: q    BINPUT     0</span>
<span class="s">    5: (    MARK</span>
<span class="s">    6: K        BININT1    1</span>
<span class="s">    8: K        BININT1    2</span>
<span class="s">   10: K        BININT1    3</span>
<span class="s">   12: e        APPENDS    (MARK at 5)</span>
<span class="s">   13: .    STOP</span>
<span class="s">highest protocol among opcodes = 2</span>
<span class="s">&gt;&gt;&gt; dis(f, memo=memo)</span>
<span class="s">   14: \x80 PROTO      2</span>
<span class="s">   16: h    BINGET     0</span>
<span class="s">   18: .    STOP</span>
<span class="s">highest protocol among opcodes = 2</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">__test__</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;disassembler_test&#39;</span><span class="p">:</span> <span class="n">_dis_test</span><span class="p">,</span>
            <span class="s">&#39;disassembler_memo_test&#39;</span><span class="p">:</span> <span class="n">_memo_test</span><span class="p">,</span>
           <span class="p">}</span>

<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="k">return</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s">&#39;disassemble one or more pickle files&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;pickle_file&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s">&#39;br&#39;</span><span class="p">),</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;the pickle file&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-o&#39;</span><span class="p">,</span> <span class="s">&#39;--output&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">),</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;the file where the output should be written&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-m&#39;</span><span class="p">,</span> <span class="s">&#39;--memo&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;preserve memo between disassemblies&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="s">&#39;--indentlevel&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;the number of blanks by which to indent a new MARK level&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-a&#39;</span><span class="p">,</span> <span class="s">&#39;--annotate&#39;</span><span class="p">,</span>  <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;annotate each line with a short opcode description&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-p&#39;</span><span class="p">,</span> <span class="s">&#39;--preamble&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&quot;==&gt; {name} &lt;==&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;if more than one pickle file is specified, print this before&#39;</span>
        <span class="s">&#39; each disassembly&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-t&#39;</span><span class="p">,</span> <span class="s">&#39;--test&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;run self-test suite&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s">&#39;-v&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;run verbosely; only affects self-test run&#39;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">test</span><span class="p">:</span>
        <span class="n">_test</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">annotate</span> <span class="o">=</span> <span class="mi">30</span> <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">annotate</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">pickle_file</span><span class="p">:</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">pickle_file</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dis</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">pickle_file</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                <span class="n">args</span><span class="o">.</span><span class="n">indentlevel</span><span class="p">,</span> <span class="n">annotate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">memo</span> <span class="k">else</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">pickle_file</span><span class="p">:</span>
                <span class="n">preamble</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">preamble</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">preamble</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
                <span class="n">dis</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">indentlevel</span><span class="p">,</span> <span class="n">annotate</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Weldon Henson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0.',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>